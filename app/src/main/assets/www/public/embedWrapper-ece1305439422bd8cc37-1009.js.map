{"version":3,"file":"embedWrapper-ece1305439422bd8cc37-1009.js","mappings":"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","sources":["webpack://odysee.com/../ui/page/embedWrapper/view.jsx","webpack://odysee.com/../ui/page/embedWrapper/index.js"],"sourcesContent":["// @flow\nimport * as PAGES from 'constants/pages';\nimport * as COLLECTIONS_CONSTS from 'constants/collections';\nimport React from 'react';\nimport classnames from 'classnames';\nimport { useHistory, Redirect } from 'react-router';\nimport PropTypes from 'prop-types';\nimport { lazyImport } from 'util/lazyImport';\nimport * as RENDER_MODES from 'constants/file_render_modes';\nimport { EmbedContext } from 'contexts/embed';\nimport Spinner from 'component/spinner';\nimport { buildURI, normalizeURI, parseURI } from 'util/lbryURI';\nimport { formatLbryUrlForWeb } from 'util/url';\nconst ClaimPage = lazyImport(() => import('page/claim' /* webpackChunkName: \"claimPage\" */));\nconst CollectionPage = lazyImport(() => import('page/collection' /* webpackChunkName: \"collection\" */));\nconst EmbedClaimComponent = lazyImport(() =>\n  import('page/embedWrapper/internal/embedClaimComponent' /* webpackChunkName: \"embedClaimComponent\" */)\n);\n\n// Keep uri derivation logic here and delegate full rendering to existing pages\n\ntype Props = {\n  uri?: string,\n  collectionId?: string,\n  collectionFirstItemUri?: string,\n  isCollection?: boolean,\n  renderMode?: string,\n  doFetchItemsInCollection?: ({ collectionId: string }) => void,\n};\n\nconst EmbedWrapperPage = (props: Props) => {\n  const [videoEnded, setVideoEnded] = React.useState(false);\n  const {\n    uri: incomingUri,\n    collectionId,\n    collectionFirstItemUri,\n    isCollection,\n    renderMode,\n    doFetchItemsInCollection,\n  } = props;\n\n  const {\n    location: { search, pathname },\n    match,\n  } = useHistory();\n\n  const urlParams = new URLSearchParams(search);\n  const featureParam = urlParams.get('feature');\n  const latestContentPath = featureParam === PAGES.LATEST;\n  const liveContentPath = featureParam === PAGES.LIVE_NOW;\n\n  // Detect if this is a playlist page URL\n  const isPlaylistPath = pathname && pathname.includes('/playlist/');\n\n  // For live/latest content, use the URI from selector (which resolves to the actual stream)\n  // Otherwise, try to derive from match first\n  let uri;\n  if (liveContentPath || latestContentPath) {\n    uri = incomingUri;\n  } else {\n    const matchedPath = buildMatchWithHash(match, window?.location?.hash);\n    uri = getUriFromMatch(matchedPath);\n    if (!uri) uri = incomingUri;\n  }\n  const embedLightBackground = urlParams.get('embedBackgroundLight');\n\n  // Fetch collection items when we have a collectionId\n  React.useEffect(() => {\n    if (collectionId && doFetchItemsInCollection) {\n      doFetchItemsInCollection({ collectionId });\n    }\n  }, [collectionId, doFetchItemsInCollection]);\n\n  // For playlist URLs in embed mode, redirect to first item with lid parameter\n  if (isPlaylistPath && collectionId && collectionFirstItemUri) {\n    const firstItemPath = formatLbryUrlForWeb(collectionFirstItemUri);\n    const redirectUrl = `/$/embed${firstItemPath}?${COLLECTIONS_CONSTS.COLLECTION_ID}=${collectionId}`;\n    return <Redirect to={redirectUrl} />;\n  }\n\n  // Show loading while waiting for collection first item\n  if (isPlaylistPath && collectionId && !collectionFirstItemUri) {\n    return (\n      <div className=\"main--empty\">\n        <Spinner text={__('Loading playlist...')} />\n      </div>\n    );\n  }\n\n  // Determine if this should render like a full page (channels/collections) or minimal (videos/posts)\n  const { isChannel } = uri ? parseURI(uri) : { isChannel: false };\n  const isMarkdown = renderMode === RENDER_MODES.MARKDOWN;\n  const isPageLike = Boolean(isChannel || isCollection || isMarkdown);\n\n  return (\n    <EmbedContext.Provider value={{ videoEnded, setVideoEnded }}>\n      <div\n        className={classnames('embed__wrapper', {\n          'embed__wrapper--light-background': embedLightBackground,\n          'embed__wrapper--page': isPageLike,\n        })}\n      >\n        <React.Suspense\n          fallback={\n            <div className=\"main--empty\">\n              <Spinner text={__('Loading...')} />\n            </div>\n          }\n        >\n          {collectionId && !isPlaylistPath ? (\n            <CollectionPage collectionId={collectionId} />\n          ) : isPageLike ? (\n            <ClaimPage uri={uri} latestContentPath={latestContentPath} liveContentPath={liveContentPath} />\n          ) : (\n            <EmbedClaimComponent uri={uri} />\n          )}\n        </React.Suspense>\n      </div>\n    </EmbedContext.Provider>\n  );\n};\n\nEmbedWrapperPage.propTypes = {\n  uri: PropTypes.string,\n  collectionId: PropTypes.string,\n  collectionFirstItemUri: PropTypes.string,\n  isCollection: PropTypes.bool,\n  renderMode: PropTypes.string,\n  doFetchItemsInCollection: PropTypes.func,\n};\n\nexport default EmbedWrapperPage;\n\nfunction getUriFromMatch(match) {\n  if (match) {\n    const { claimName, claimId } = match.params || {};\n\n    // Special case: don't resolve \"home\" as a claim (it has its own route)\n    if (claimName === 'home' && !claimId) {\n      return '';\n    }\n\n    // https://{DOMAIN}/claimName/claimId\n    const isOldPermanentUriFormat =\n      claimName && !claimName.startsWith('@') && !claimName.includes(':') && !claimName.includes('#') && claimId;\n\n    // https://{DOMAIN}/channelName/claimName/\n    // on match channelName = claimName / claimName = claimId\n    const isCanonicalUriFormat = !isOldPermanentUriFormat;\n\n    if (isOldPermanentUriFormat) {\n      try {\n        return buildURI({ claimName, claimId });\n      } catch (error) {}\n    }\n\n    if (isCanonicalUriFormat && claimName) {\n      return normalizeURI(claimName + '/' + (claimId || ''));\n    }\n  }\n\n  return '';\n}\n\nfunction buildMatchWithHash(match, hash) {\n  const matchedPath = Object.assign({}, match || {});\n\n  // if a claim is using the hash canonical format (\"lbry://@chanelName#channelClaimId/streamName#streamClaimId\"\n  // instead of \"lbry://@chanelName:channelClaimId/streamName:streamClaimId\")\n  if (hash && hash.length > 0 && matchedPath.params) {\n    // the hash is on the channel part of the uri\n    if (hash.includes('/')) {\n      const newClaimNameParam = matchedPath.params.claimName;\n      const claimIdPart = hash.substring(0, hash.indexOf('/'));\n\n      if (newClaimNameParam && !newClaimNameParam.includes(claimIdPart)) {\n        matchedPath.params.claimName = newClaimNameParam + claimIdPart;\n        matchedPath.params.claimId = hash.substring(hash.indexOf('/') + 1);\n      }\n    } else {\n      // the hash is on the stream part of the uri, so it looks like\n      // \"lbry://@chanelName:channelClaimId/streamName#streamClaimId\" instead of\n      // \"lbry://@chanelName:channelClaimId/streamName:streamClaimId\"\n      matchedPath.params.claimId = (matchedPath.params.claimId || '') + hash;\n    }\n  }\n\n  return matchedPath;\n}\n","import { connect } from 'react-redux';\nimport EmbedWrapperPage from './view';\nimport * as PAGES from 'constants/pages';\nimport { selectClaimForUri, selectIsUriResolving, selectLatestClaimForUri } from 'redux/selectors/claims';\nimport { doFetchLatestClaimForChannel } from 'redux/actions/claims';\nimport { buildURI, normalizeURI } from 'util/lbryURI';\nimport { getChannelIdFromClaim, isStreamPlaceholderClaim, getChannelFromClaim } from 'util/claim';\nimport { doCommentSocketConnect, doCommentSocketDisconnect } from 'redux/actions/websocket';\nimport { doFetchChannelIsLiveForId } from 'redux/actions/livestream';\nimport { selectLatestLiveClaimForChannel, selectLatestLiveUriForChannel } from 'redux/selectors/livestream';\nimport { makeSelectFileRenderModeForUri } from 'redux/selectors/content';\nimport { selectNoRestrictionOrUserIsMemberForContentClaimId } from 'redux/selectors/memberships';\nimport { selectFirstItemUrlForCollection } from 'redux/selectors/collections';\nimport { doFetchItemsInCollection } from 'redux/actions/collections';\n\nconst select = (state, props) => {\n  const { search, hash } = state.router.location;\n  const { match } = props || {};\n  const { pathname } = state.router.location || {};\n\n  const matchedPath = match ? buildMatchWithHash(match, hash) : buildMatchFromPath(pathname);\n  let uri = getUriFromMatch(matchedPath);\n\n  const urlParams = new URLSearchParams(search);\n  const featureParam = urlParams.get('feature');\n\n  // Detect playlist page URLs (e.g., /$/playlist/:collectionId or /$/embed/playlist/:collectionId)\n  let playlistCollectionId = null;\n  const playlistMatch = pathname && pathname.match(/\\/\\$\\/(?:embed\\/)?playlist\\/([a-f0-9]{40})/i);\n  if (playlistMatch) {\n    playlistCollectionId = playlistMatch[1];\n  }\n\n  const claim = selectClaimForUri(state, uri);\n  const { canonical_url: canonicalUrl } = claim || {};\n  const claimId = claim?.claim_id;\n\n  const channelClaim = getChannelFromClaim(claim);\n  const channelClaimId = getChannelIdFromClaim(claim);\n  const { canonical_url: channelUri } = channelClaim || {};\n\n  const latestContentClaim =\n    featureParam === PAGES.LIVE_NOW\n      ? selectLatestLiveClaimForChannel(state, channelClaimId)\n      : selectLatestClaimForUri(state, canonicalUrl);\n\n  const latestClaimUrl =\n    featureParam === PAGES.LIVE_NOW\n      ? selectLatestLiveUriForChannel(state, channelClaimId)\n      : latestContentClaim && latestContentClaim.canonical_url;\n  const latestClaimId = latestContentClaim && latestContentClaim.claim_id;\n\n  if (latestClaimUrl) uri = latestClaimUrl;\n\n  // Detect collections from playlist-style URIs even if claim isn't resolved as a collection\n  let detectedCollectionId = playlistCollectionId;\n  if (!detectedCollectionId && uri && typeof uri === 'string' && uri.toLowerCase().includes('/playlist')) {\n    const collectionIdMatch = uri.match(/[#:/]([0-9a-f]{40})/i);\n    if (collectionIdMatch) detectedCollectionId = collectionIdMatch[1];\n  }\n\n  const isCollection = (claim && claim.value_type === 'collection') || Boolean(detectedCollectionId);\n  const collectionId = claim && claim.value_type === 'collection' ? claim.claim_id : detectedCollectionId;\n  const collectionFirstItemUri = collectionId ? selectFirstItemUrlForCollection(state, collectionId) : null;\n  const renderMode = uri ? makeSelectFileRenderModeForUri(uri)(state) : undefined;\n\n  return {\n    uri,\n    claimId,\n    latestClaimId,\n    canonicalUrl,\n    channelUri,\n    channelClaimId,\n    isCollection,\n    collectionId,\n    collectionFirstItemUri,\n    renderMode,\n    latestClaimUrl,\n    isResolvingUri: uri && selectIsUriResolving(state, uri),\n    isLivestreamClaim: featureParam === PAGES.LIVE_NOW || isStreamPlaceholderClaim(claim),\n    contentUnlocked: claim && selectNoRestrictionOrUserIsMemberForContentClaimId(state, claim.claim_id),\n  };\n};\n\nconst perform = {\n  doFetchChannelIsLiveForId,\n  doCommentSocketConnect,\n  doCommentSocketDisconnect,\n  doFetchLatestClaimForChannel,\n  doFetchItemsInCollection,\n};\n\nexport default connect(select, perform)(EmbedWrapperPage);\n\nfunction getUriFromMatch(match) {\n  if (match && match.params) {\n    const { claimName, claimId } = match.params || {};\n\n    if (!claimName) {\n      return '';\n    }\n\n    // Special case: don't resolve \"home\" as a claim (it has its own route)\n    if (claimName === 'home' && !claimId) {\n      return '';\n    }\n\n    // https://{DOMAIN}/claimName/claimId\n    const isOldPermanentUriFormat =\n      typeof claimName === 'string' &&\n      !claimName.startsWith('@') &&\n      !claimName.includes(':') &&\n      !claimName.includes('#') &&\n      claimId;\n\n    // https://{DOMAIN}/channelName/claimName/\n    // on match channelName = claimName / claimName = claimId\n    const isCanonicalUriFormat = !isOldPermanentUriFormat;\n\n    if (isOldPermanentUriFormat) {\n      try {\n        return buildURI({ claimName, claimId });\n      } catch (error) {}\n    }\n\n    if (isCanonicalUriFormat) {\n      return normalizeURI(String(claimName) + '/' + (claimId || ''));\n    }\n  }\n\n  return '';\n}\n\nfunction buildMatchWithHash(match, hash) {\n  const matchedPath = Object.assign({}, match);\n\n  // Ensure params object exists\n  if (!matchedPath.params) {\n    matchedPath.params = {};\n  }\n\n  // if a claim is using the hash canonical format (\"lbry://@chanelName#channelClaimId/streamName#streamClaimId\"\n  // instead of \"lbry://@chanelName:channelClaimId/streamName:streamClaimId\")\n  if (hash && hash.length > 0 && matchedPath.params) {\n    // the hash is on the channel part of the uri\n    if (hash.includes('/')) {\n      const newClaimNameParam = matchedPath.params.claimName;\n      const claimIdPart = hash.substring(0, hash.indexOf('/'));\n\n      if (newClaimNameParam && !newClaimNameParam.includes(claimIdPart)) {\n        matchedPath.params.claimName = newClaimNameParam + claimIdPart;\n        matchedPath.params.claimId = hash.substring(hash.indexOf('/') + 1);\n      }\n    } else {\n      // the hash is on the stream part of the uri, so it looks like\n      // \"lbry://@chanelName:channelClaimId/streamName#streamClaimId\" instead of\n      // \"lbry://@chanelName:channelClaimId/streamName:streamClaimId\"\n      matchedPath.params.claimId = (matchedPath.params.claimId || '') + hash;\n    }\n  }\n\n  return matchedPath;\n}\n\nfunction buildMatchFromPath(pathname) {\n  const matchedPath = { params: {} };\n  try {\n    if (!pathname) return matchedPath;\n    const parts = pathname.split('/').filter(Boolean);\n    // Expect ['$', 'embed', <claimName>, <claimId>?]\n    const embedIdx = parts.indexOf('embed');\n    if (embedIdx > -1) {\n      const claimName = decodeURIComponent(parts[embedIdx + 1] || '');\n      const claimId = decodeURIComponent(parts[embedIdx + 2] || '');\n      matchedPath.params.claimName = claimName;\n      if (claimId) matchedPath.params.claimId = claimId;\n    }\n  } catch (e) {}\n  return matchedPath;\n}\n"],"names":["ClaimPage","lazyImport","CollectionPage","EmbedClaimComponent","EmbedWrapperPage","props","uri","_React$useState2","_slicedToArray","React","videoEnded","setVideoEnded","incomingUri","collectionId","collectionFirstItemUri","isCollection","renderMode","doFetchItemsInCollection","_useHistory","useHistory","_useHistory$location","location","search","pathname","match","urlParams","URLSearchParams","featureParam","get","latestContentPath","PAGES","liveContentPath","isPlaylistPath","includes","_window","_window$location","matchedPath","hash","Object","assign","length","params","newClaimNameParam","claimName","claimIdPart","substring","indexOf","claimId","buildMatchWithHash","window","_ref2","isOldPermanentUriFormat","startsWith","isCanonicalUriFormat","buildURI","error","normalizeURI","getUriFromMatch","embedLightBackground","firstItemPath","formatLbryUrlForWeb","redirectUrl","concat","COLLECTIONS_CONSTS","Redirect","to","className","Spinner","text","__","isChannel","parseURI","isMarkdown","RENDER_MODES","isPageLike","Boolean","EmbedContext","value","classnames","fallback","propTypes","PropTypes","perform","doFetchChannelIsLiveForId","doCommentSocketConnect","doCommentSocketDisconnect","doFetchLatestClaimForChannel","connect","state","_state$router$locatio","router","parts","split","filter","embedIdx","decodeURIComponent","e","buildMatchFromPath","_ref5","String","playlistCollectionId","playlistMatch","claim","selectClaimForUri","canonicalUrl","canonical_url","claim_id","channelClaim","getChannelFromClaim","channelClaimId","getChannelIdFromClaim","channelUri","latestContentClaim","selectLatestLiveClaimForChannel","selectLatestClaimForUri","latestClaimUrl","selectLatestLiveUriForChannel","latestClaimId","detectedCollectionId","toLowerCase","collectionIdMatch","value_type","selectFirstItemUrlForCollection","makeSelectFileRenderModeForUri","undefined","isResolvingUri","selectIsUriResolving","isLivestreamClaim","isStreamPlaceholderClaim","contentUnlocked","selectNoRestrictionOrUserIsMemberForContentClaimId"],"sourceRoot":""}