(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~membershipsLanding"],{

/***/ "../node_modules/balance-text/balancetext.js":
/*!***************************************************!*\
  !*** ../node_modules/balance-text/balancetext.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n/*\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License. *\n */\n\n/**\n * balancetext.js\n *\n * Author: Randy Edmunds\n */\n\n/* global define, module */\n\n/*\n * Copyright (c) 2007-2009 unscriptable.com and John M. Hann\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the “Software”), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Except as contained in this notice, the name(s) of the above\n * copyright holders (unscriptable.com and John M. Hann) shall not be\n * used in advertising or otherwise to promote the sale, use or other\n * dealings in this Software without prior written authorization.\n *\n * http://unscriptable.com/index.php/2009/03/20/debouncing-javascript-methods/\n *\n * Tested to work on (lowest browser):\n * - Sarari 4\n * - Chrome 16\n * - Firefox 10\n * - IE 9\n * - Edge 13\n */\n\n\n(function (root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function () {\n  /**\n   * Line breaking global vars\n   */\n  var breakMatches, wsnwMatches, wsnwOffset;\n  /**\n   * Selectors and elements to watch;\n   * calling $.balanceText(elements) adds \"elements\" to this list.\n   */\n\n  var watching = {\n    sel: [],\n    // default class to watch\n    el: []\n  };\n  /**\n   * Have handlers been initialized?\n   */\n\n  var handlersInitialized = false;\n  /**\n   * Is this a polyfill?\n   */\n\n  var polyfilled = false;\n  /**\n   * Do nothing\n   */\n\n  function noop() {}\n  /**\n   * Loop that works with array-likes\n   * @param {Array-like} elements - List of elements to run a function on\n   * @param {Function}   callback - The function to call on each supplied element\n   */\n\n\n  function forEach(elements, callback) {\n    Array.prototype.forEach.call(elements, callback);\n  }\n  /**\n   * Polyfill for $(document).ready()\n   *\n   * @param {Function} fn - The function to execute when the document is ready\n   */\n\n\n  function ready(fn) {\n    if (document.readyState !== \"loading\") {\n      fn();\n    } else if (document.addEventListener) {\n      document.addEventListener(\"DOMContentLoaded\", fn);\n    } else {\n      document.attachEvent(\"onreadystatechange\", function () {\n        if (document.readyState !== \"loading\") {\n          fn();\n        }\n      });\n    }\n  }\n  /**\n   * Debounces a function over a threshold\n   *\n   * @param {Function} func      - The function to debounce\n   * @param {number}   threshold - time in ms\n   * @param {boolean}  execAsap  - when true, execute immediately\n   * @param args\n   * @return {Function} Debounced function\n   */\n\n\n  function debounce(func, threshold, execAsap) {\n    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      args[_key - 3] = arguments[_key];\n    }\n\n    var timeout;\n    return function () {\n      var obj = this;\n\n      function delayed() {\n        if (!execAsap) {\n          func.apply(obj, args);\n        }\n\n        timeout = null;\n      }\n\n      if (timeout) {\n        clearTimeout(timeout);\n      } else if (execAsap) {\n        func.apply(obj, args);\n      }\n\n      timeout = setTimeout(delayed, threshold || 100);\n    };\n  }\n  /**\n   * Determine whether the document supports TextWrap\n   * @return {boolean}\n   */\n\n\n  function hasTextWrap() {\n    if (typeof window === \"undefined\") {\n      return false;\n    }\n\n    var style = document.documentElement.style;\n    return style.textWrap || style.WebkitTextWrap || style.MozTextWrap || style.MsTextWrap;\n  }\n  /**\n   * Object for tracking next whitespace params\n   */\n  // eslint-disable-next-line camelcase\n\n\n  function NextWS_params() {\n    this.reset();\n  }\n\n  NextWS_params.prototype.reset = function () {\n    this.index = 0;\n    this.width = 0;\n  };\n  /**\n   * Check if index is contained in previously calculated list of white-space:nowrap ranges\n   *\n   * @param {number} index - the index of the character to check\n   * @return {boolean}\n   */\n\n\n  function isWhiteSpaceNoWrap(index) {\n    // Is index inside 1 of the ranges?\n    // start and end are breakable, but not inside range\n    return wsnwMatches.some(function (range) {\n      return range.start < index && index < range.end;\n    });\n  }\n  /**\n   * Recursively calculate white-space:nowrap offsets for line.\n   *\n   * @param {Node}    el         - the element to act on\n   * @param {boolean} includeTag - include length of tag itself\n   */\n\n\n  function recursiveCalcNoWrapOffsetsForLine(el, includeTag) {\n    if (el.nodeType === el.ELEMENT_NODE) {\n      // Found an embedded tag\n      var style = window.getComputedStyle(el);\n\n      if (style.whiteSpace === \"nowrap\") {\n        // Tag with white-space:nowrap - add match, skip children\n        var len = el.outerHTML.length;\n        wsnwMatches.push({\n          start: wsnwOffset,\n          end: wsnwOffset + len\n        });\n        wsnwOffset += len;\n      } else {\n        // Tag without white-space:nowrap - recursively check children of tag\n        forEach(el.childNodes, function (child) {\n          recursiveCalcNoWrapOffsetsForLine(child, true);\n        });\n\n        if (includeTag) {\n          // Length of opening tag, attributes, and closing tag\n          wsnwOffset += el.outerHTML.length - el.innerHTML.length;\n        }\n      }\n    } else if (el.nodeType === el.COMMENT_NODE) {\n      wsnwOffset += el.length + 7; // delimiter: <!-- -->\n    } else if (el.nodeType === el.PROCESSING_INSTRUCTION_NODE) {\n      wsnwOffset += el.length + 2; // delimiter: < >\n    } else {\n      // Text node: add length\n      wsnwOffset += el.length;\n    }\n  }\n  /**\n   * Calculate white-space:nowrap offsets for line.\n   *\n   * @param {Node}    el             - the element to act on\n   * @param {string}  oldWS          - \"old\" whitespace setting for temporarily resetting\n   * @param {number}  lineCharOffset - char offset of current line from start of text\n   */\n\n\n  function calcNoWrapOffsetsForLine(el, oldWS, lineCharOffset) {\n    // For first line (lineCharOffset === 0), calculate start and end offsets for each\n    // white-space:nowrap element in the line.\n    if (lineCharOffset === 0) {\n      // Reset whiteSpace setting when breakMatches is being calculated\n      // so white-space:nowrap can be detected in text\n      el.style.whiteSpace = oldWS;\n      wsnwOffset = 0;\n      wsnwMatches = [];\n      recursiveCalcNoWrapOffsetsForLine(el, false); // Restore temporary whitespace setting to recalc width\n\n      el.style.whiteSpace = \"nowrap\";\n    } else {\n      // For all other lines, update the offsets for current line\n      // 1. Ignore matches less than offset\n      // 2. Subtract offset from remaining matches\n      var newMatches = [];\n      wsnwMatches.forEach(function (match) {\n        if (match.start > lineCharOffset) {\n          newMatches.push({\n            start: match.start - lineCharOffset,\n            end: match.end - lineCharOffset\n          });\n        }\n      });\n      wsnwMatches = newMatches;\n    }\n  }\n  /**\n   * Strip balance-text tags from an element inserted in previous run\n   *\n   * @param {Node} el - the element to act on\n   */\n\n\n  function removeTags(el) {\n    // Remove soft-hyphen breaks\n    var brs = el.querySelectorAll('br[data-owner=\"balance-text-hyphen\"]');\n    forEach(brs, function (br) {\n      br.outerHTML = \"\";\n    }); // Replace other breaks with whitespace\n\n    brs = el.querySelectorAll('br[data-owner=\"balance-text\"]');\n    forEach(brs, function (br) {\n      br.outerHTML = \" \";\n    }); // Restore hyphens inserted for soft-hyphens\n\n    var spans = el.querySelectorAll('span[data-owner=\"balance-text-softhyphen\"]');\n\n    if (spans.length > 0) {\n      forEach(spans, function (span) {\n        var textNode = document.createTextNode(\"\\xAD\");\n        span.parentNode.insertBefore(textNode, span);\n        span.parentNode.removeChild(span);\n      });\n    } // Remove spans inserted for justified text\n\n\n    spans = el.querySelectorAll('span[data-owner=\"balance-text-justify\"]');\n\n    if (spans.length > 0) {\n      var txt = \"\";\n      forEach(spans, function (span) {\n        txt += span.textContent;\n        span.parentNode.removeChild(span);\n      });\n      el.innerHTML = txt;\n    }\n  }\n  /**\n   * Checks to see if we should justify the balanced text with the\n   * element based on the textAlign property in the computed CSS\n   *\n   * @param {Node} el - element to check\n   * @return {boolean}\n   */\n\n\n  var isJustified = function isJustified(el) {\n    var style = el.currentStyle || window.getComputedStyle(el, null);\n    return style.textAlign === \"justify\";\n  };\n  /**\n   * Add whitespace after words in text to justify the string to\n   * the specified size.\n   * @param {Node}    el       - the element to justify\n   * @param {string}  txt      - text string\n   * @param {number}  conWidth - container width\n   * @return {string} Justified text\n   */\n\n\n  function justify(el, txt, conWidth) {\n    txt = txt.trim();\n    var words = txt.split(\" \").length;\n    txt = \"\".concat(txt, \" \"); // if we don't have at least 2 words, no need to justify.\n\n    if (words < 2) {\n      return txt;\n    } // Find width of text in the DOM\n\n\n    var tmp = document.createElement(\"span\");\n    tmp.innerHTML = txt;\n    el.appendChild(tmp);\n    var size = tmp.offsetWidth;\n    tmp.parentNode.removeChild(tmp); // Figure out our word spacing and return the element\n\n    var wordSpacing = Math.floor((conWidth - size) / (words - 1));\n    tmp.style.wordSpacing = \"\".concat(wordSpacing, \"px\");\n    tmp.setAttribute(\"data-owner\", \"balance-text-justify\");\n    var div = document.createElement(\"div\");\n    div.appendChild(tmp);\n    return div.innerHTML;\n  }\n  /**\n   * Returns true iff char at index is a break char outside of HTML < > tags.\n   * Break char can be: whitespace (except non-breaking-space: u00a0),\n   * hypen, emdash (u2014), endash (u2013), or soft-hyphen (u00ad).\n   *\n   * @param {string} txt   - the text to check\n   * @param {number} index - the index of the character to check\n   * @return {boolean}\n   */\n\n\n  function isBreakChar(txt, index) {\n    var re = /([^\\S\\u00a0]|-|\\u2014|\\u2013|\\u00ad)(?![^<]*>)/g;\n    var match;\n\n    if (!breakMatches) {\n      // Only calc break matches once per line\n      breakMatches = [];\n      match = re.exec(txt);\n\n      while (match !== null) {\n        if (!isWhiteSpaceNoWrap(match.index)) {\n          breakMatches.push(match.index);\n        }\n\n        match = re.exec(txt);\n      }\n    }\n\n    return breakMatches.indexOf(index) !== -1;\n  }\n  /**\n   * In the current implementation, an index is a break\n   * opportunity in txt iff it is:\n   * - 0 or txt.length\n   * - index of a non-whitespace char immediately preceded by a\n   *   whitespace, hyphen, soft-hyphen, em-dash, or en-dash char.\n   *\n   * Thus, it doesn't honour \"white-space\" or any other Unicode\n   * line-breaking classes.)\n   *\n   * @precondition 0 <= index && index <= txt.length\n   *\n   * @param {string} txt   - the text to check\n   * @param {number} index - the index to check\n   * @return {boolean}\n   */\n\n\n  function isBreakOpportunity(txt, index) {\n    return index === 0 || index === txt.length || isBreakChar(txt, index - 1) && !isBreakChar(txt, index);\n  }\n  /**\n   * Finds the first break opportunity (@see isBreakOpportunity)\n   * in txt that's both after-or-equal-to index c in the direction dir\n   * and resulting in line width equal to or past clamp(desWidth,\n   * 0, conWidth) in direction dir.  Sets ret.index and ret.width\n   * to the corresponding index and line width (from the start of\n   * txt to ret.index).\n   *\n   * @param {Node}    el       - element\n   * @param {string}  txt      - text string\n   * @param {number}  conWidth - container width\n   * @param {number}  desWidth - desired width\n   * @param {number}  dir      - direction (-1 or +1)\n   * @param {number}  c        - char index (0 <= c && c <= txt.length)\n   * @param {Object}  ret      - return {index: {number}, width: {number}} of previous/next break\n   */\n\n\n  function findBreakOpportunity(el, txt, conWidth, desWidth, dir, c, ret) {\n    var w;\n\n    if (txt && typeof txt === \"string\") {\n      for (;;) {\n        while (!isBreakOpportunity(txt, c)) {\n          c += dir;\n        }\n\n        el.innerHTML = txt.substr(0, c);\n        w = el.offsetWidth;\n\n        if (dir < 0) {\n          if (w <= desWidth || w <= 0 || c === 0) {\n            break;\n          }\n        } else if (desWidth <= w || conWidth <= w || c === txt.length) {\n          break;\n        }\n\n        c += dir;\n      }\n    }\n\n    ret.index = c;\n    ret.width = w;\n  }\n  /**\n   * Detects the width of a non-breaking space character, given the height of\n   * the element with no-wrap applied.\n   *\n   * @param {Node}   el - element\n   * @param {number} h  - height\n   * @return {number}\n   */\n\n\n  function getSpaceWidth(el, h) {\n    var container = document.createElement(\"div\");\n    container.style.display = \"block\";\n    container.style.position = \"absolute\";\n    container.style.bottom = 0;\n    container.style.right = 0;\n    container.style.width = 0;\n    container.style.height = 0;\n    container.style.margin = 0;\n    container.style.padding = 0;\n    container.style.visibility = \"hidden\";\n    container.style.overflow = \"hidden\";\n    var space = document.createElement(\"span\");\n    space.style.fontSize = \"2000px\";\n    space.innerHTML = \"&nbsp;\";\n    container.appendChild(space);\n    el.appendChild(container);\n    var dims = space.getBoundingClientRect();\n    container.parentNode.removeChild(container);\n    var spaceRatio = dims.height / dims.width;\n    return h / spaceRatio;\n  }\n  /**\n   * Get a list of elements regardless of input\n   *\n   * @param {string|Node|Array-like} elements - The selector to query, one or more elements\n   * @return {Array<{Node}>}\n   */\n\n\n  function getElementsList(elements) {\n    if (!elements) {\n      return [];\n    } // is selector\n\n\n    if (typeof elements === \"string\") {\n      return document.querySelectorAll(elements);\n    } // is single element\n\n\n    if (elements.tagName && elements.querySelectorAll) {\n      return [elements];\n    }\n\n    return elements;\n  }\n  /**\n   *  When a browser has native support for the text-wrap property,\n   * the text balanceText plugin will let the browser handle it natively,\n   * otherwise it will apply its own text balancing code.\n   *\n   * @param {string|Node|Array-like} elements - the list of elements to balance\n   */\n\n\n  function balanceText(elements) {\n    forEach(getElementsList(elements), function (el) {\n      // In a lower level language, this algorithm takes time\n      // comparable to normal text layout other than the fact\n      // that we do two passes instead of one, so we should\n      // be able to do without this limit.\n      var maxTextWidth = 5000; // strip balance-text generated tags\n\n      removeTags(el); // save settings\n\n      var oldWS = el.style.whiteSpace;\n      var oldFloat = el.style[\"float\"];\n      var oldDisplay = el.style.display;\n      var oldPosition = el.style.position;\n      var oldLH = el.style.lineHeight; // remove line height before measuring container size\n\n      el.style.lineHeight = \"normal\";\n      var containerWidth = el.offsetWidth;\n      var containerHeight = el.offsetHeight; // temporary settings\n\n      el.style.whiteSpace = \"nowrap\";\n      el.style[\"float\"] = \"none\";\n      el.style.display = \"inline\";\n      el.style.position = \"static\";\n      var nowrapWidth = el.offsetWidth;\n      var nowrapHeight = el.offsetHeight; // An estimate of the average line width reduction due\n      // to trimming trailing space that we expect over all\n      // lines other than the last.\n\n      var spaceWidth = oldWS === \"pre-wrap\" ? 0 : getSpaceWidth(el, nowrapHeight);\n\n      if (containerWidth > 0 && // prevent divide by zero\n      nowrapWidth > containerWidth && // text is more than 1 line\n      nowrapWidth < maxTextWidth) {\n        // text is less than arbitrary limit (make this a param?)\n        var remainingText = el.innerHTML;\n        var newText = \"\";\n        var lineText = \"\";\n        var shouldJustify = isJustified(el);\n        var totLines = Math.round(containerHeight / nowrapHeight);\n        var remLines = totLines;\n        var lineCharOffset = 0; // loop vars\n\n        var desiredWidth, guessIndex, le, ge, splitIndex, isHyphen, isSoftHyphen; // Determine where to break:\n\n        while (remLines > 1) {\n          // clear whitespace match cache for each line\n          breakMatches = null; // Must calc white-space:nowrap offsets before first call to findBreakOpportunity()\n\n          calcNoWrapOffsetsForLine(el, oldWS, lineCharOffset);\n          desiredWidth = Math.round((nowrapWidth + spaceWidth) / remLines - spaceWidth); // Guessed char index\n\n          guessIndex = Math.round((remainingText.length + 1) / remLines) - 1;\n          le = new NextWS_params(); // Find a breaking space somewhere before (or equal to) desired width,\n          // not necessarily the closest to the desired width.\n\n          findBreakOpportunity(el, remainingText, containerWidth, desiredWidth, -1, guessIndex, le); // Find first breaking char after (or equal to) desired width.\n\n          ge = new NextWS_params();\n          guessIndex = le.index;\n          findBreakOpportunity(el, remainingText, containerWidth, desiredWidth, +1, guessIndex, ge); // Find first breaking char before (or equal to) desired width.\n\n          le.reset();\n          guessIndex = ge.index;\n          findBreakOpportunity(el, remainingText, containerWidth, desiredWidth, -1, guessIndex, le); // Find closest string to desired length\n\n          if (le.index === 0) {\n            splitIndex = ge.index;\n          } else if (containerWidth < ge.width || le.index === ge.index) {\n            splitIndex = le.index;\n          } else {\n            splitIndex = Math.abs(desiredWidth - le.width) < Math.abs(ge.width - desiredWidth) ? le.index : ge.index;\n          } // Break string\n\n\n          lineText = remainingText.substr(0, splitIndex).replace(/\\s$/, \"\");\n          isSoftHyphen = Boolean(lineText.match(/\\u00ad$/));\n\n          if (isSoftHyphen) {\n            // Replace soft-hyphen causing break with explicit hyphen\n            lineText = lineText.replace(/\\u00ad$/, '<span data-owner=\"balance-text-softhyphen\">-</span>');\n          }\n\n          if (shouldJustify) {\n            newText += justify(el, lineText, containerWidth);\n          } else {\n            newText += lineText;\n            isHyphen = isSoftHyphen || Boolean(lineText.match(/(-|\\u2014|\\u2013)$/));\n            newText += isHyphen ? '<br data-owner=\"balance-text-hyphen\" />' : '<br data-owner=\"balance-text\" aria-hidden=\"true\" />';\n          }\n\n          remainingText = remainingText.substr(splitIndex);\n          lineCharOffset = splitIndex; // update counters\n\n          remLines--;\n          el.innerHTML = remainingText;\n          nowrapWidth = el.offsetWidth;\n        }\n\n        if (shouldJustify) {\n          el.innerHTML = newText + justify(el, remainingText, containerWidth);\n        } else {\n          el.innerHTML = newText + remainingText;\n        }\n      } // restore settings\n\n\n      el.style.whiteSpace = oldWS;\n      el.style[\"float\"] = oldFloat;\n      el.style.display = oldDisplay;\n      el.style.position = oldPosition;\n      el.style.lineHeight = oldLH;\n    });\n  }\n  /**\n   * Call the balanceText plugin on elements that it's watching.\n   */\n\n\n  function updateWatched() {\n    var selectors = watching.sel.join(\",\");\n    var selectedElements = getElementsList(selectors);\n    var elements = Array.prototype.concat.apply(watching.el, selectedElements);\n    balanceText(elements);\n  }\n  /**\n   * Initialize the events for which to re-apply BalanceText.  They are:\n   * - Document ready\n   * - Document full load\n   * - Window resize\n   */\n\n\n  function initHandlers() {\n    if (handlersInitialized) {\n      return;\n    } // Apply on DOM ready\n\n\n    ready(updateWatched); // Reapply on full load\n\n    window.addEventListener(\"load\", updateWatched); // Reapply on resize\n\n    window.addEventListener(\"resize\", debounce(updateWatched));\n    handlersInitialized = true;\n  }\n  /**\n   * Apply the BalanceText routine on the document and watch the list\n   * of elements.  On window resize, re-apply BalanceText to the given elements\n   *\n   * @param {string|Node|Array-like} elements - the elements to watch after applying BalanceText\n   */\n\n\n  function balanceTextAndWatch(elements) {\n    if (typeof elements === \"string\") {\n      watching.sel.push(elements);\n    } else {\n      forEach(getElementsList(elements), function (el) {\n        watching.el.push(el);\n      });\n    }\n\n    initHandlers();\n    updateWatched();\n  }\n  /**\n   * Stop watching elements\n   *\n   * @param {string|Node|Array-like} elements\n   */\n\n\n  function unwatch(elements) {\n    if (typeof elements === \"string\") {\n      watching.sel = watching.sel.filter(function (el) {\n        return el !== elements;\n      });\n    } else {\n      elements = getElementsList(elements);\n      watching.el = watching.el.filter(function (el) {\n        return elements.indexOf(el) === -1;\n      });\n    }\n  }\n  /**\n   * Treat this app as a polyfill.  Watch for changes to the .balance-text selector\n   */\n\n\n  function polyfill() {\n    if (polyfilled) {\n      return;\n    }\n\n    watching.sel.push(\".balance-text\");\n    initHandlers();\n    polyfilled = true;\n  }\n  /**\n   * Public interface\n   *\n   * @param {string|Node|Array-like} elements - elements to balance\n   * @param {Object}                 options  - processing options\n   *  - {boolean} watch - watch elements for resize\n   */\n\n\n  function publicInterface(elements, options) {\n    if (!elements) {\n      // empty call means polyfill (watch for changes)\n      polyfill();\n    } else if (options && options.watch === true) {\n      balanceTextAndWatch(elements);\n    } else if (options && options.watch === false) {\n      unwatch(elements);\n    } else {\n      balanceText(elements);\n    }\n  }\n\n  publicInterface.updateWatched = updateWatched;\n\n  if (hasTextWrap()) {\n    noop.updateWatched = noop;\n    return noop;\n  }\n\n  return publicInterface;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2JhbGFuY2UtdGV4dC9iYWxhbmNldGV4dC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYmFsYW5jZS10ZXh0L2JhbGFuY2V0ZXh0LmpzPzIzMDAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxMiBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4gKlxuICovXG4vKipcbiAqIGJhbGFuY2V0ZXh0LmpzXG4gKlxuICogQXV0aG9yOiBSYW5keSBFZG11bmRzXG4gKi9cblxuLyogZ2xvYmFsIGRlZmluZSwgbW9kdWxlICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDctMjAwOSB1bnNjcmlwdGFibGUuY29tIGFuZCBKb2huIE0uIEhhbm5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUg4oCcU29mdHdhcmXigJ0pLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQg4oCcQVMgSVPigJ0sIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKiBFeGNlcHQgYXMgY29udGFpbmVkIGluIHRoaXMgbm90aWNlLCB0aGUgbmFtZShzKSBvZiB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBob2xkZXJzICh1bnNjcmlwdGFibGUuY29tIGFuZCBKb2huIE0uIEhhbm4pIHNoYWxsIG5vdCBiZVxuICogdXNlZCBpbiBhZHZlcnRpc2luZyBvciBvdGhlcndpc2UgdG8gcHJvbW90ZSB0aGUgc2FsZSwgdXNlIG9yIG90aGVyXG4gKiBkZWFsaW5ncyBpbiB0aGlzIFNvZnR3YXJlIHdpdGhvdXQgcHJpb3Igd3JpdHRlbiBhdXRob3JpemF0aW9uLlxuICpcbiAqIGh0dHA6Ly91bnNjcmlwdGFibGUuY29tL2luZGV4LnBocC8yMDA5LzAzLzIwL2RlYm91bmNpbmctamF2YXNjcmlwdC1tZXRob2RzL1xuICpcbiAqIFRlc3RlZCB0byB3b3JrIG9uIChsb3dlc3QgYnJvd3Nlcik6XG4gKiAtIFNhcmFyaSA0XG4gKiAtIENocm9tZSAxNlxuICogLSBGaXJlZm94IDEwXG4gKiAtIElFIDlcbiAqIC0gRWRnZSAxM1xuICovXG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmJhbGFuY2VUZXh0ID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIExpbmUgYnJlYWtpbmcgZ2xvYmFsIHZhcnNcbiAgICAgKi9cbiAgICBsZXQgYnJlYWtNYXRjaGVzLCB3c253TWF0Y2hlcywgd3Nud09mZnNldDtcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdG9ycyBhbmQgZWxlbWVudHMgdG8gd2F0Y2g7XG4gICAgICogY2FsbGluZyAkLmJhbGFuY2VUZXh0KGVsZW1lbnRzKSBhZGRzIFwiZWxlbWVudHNcIiB0byB0aGlzIGxpc3QuXG4gICAgICovXG4gICAgY29uc3Qgd2F0Y2hpbmcgPSB7XG4gICAgICAgIHNlbDogW10sIC8vIGRlZmF1bHQgY2xhc3MgdG8gd2F0Y2hcbiAgICAgICAgZWw6IFtdLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYXZlIGhhbmRsZXJzIGJlZW4gaW5pdGlhbGl6ZWQ/XG4gICAgICovXG4gICAgbGV0IGhhbmRsZXJzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgYSBwb2x5ZmlsbD9cbiAgICAgKi9cbiAgICBsZXQgcG9seWZpbGxlZCA9IGZhbHNlO1xuXG5cbiAgICAvKipcbiAgICAgKiBEbyBub3RoaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHsgfVxuXG4gICAgLyoqXG4gICAgICogTG9vcCB0aGF0IHdvcmtzIHdpdGggYXJyYXktbGlrZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LWxpa2V9IGVsZW1lbnRzIC0gTGlzdCBvZiBlbGVtZW50cyB0byBydW4gYSBmdW5jdGlvbiBvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIHN1cHBsaWVkIGVsZW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoKGVsZW1lbnRzLCBjYWxsYmFjaykge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVsZW1lbnRzLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9seWZpbGwgZm9yICQoZG9jdW1lbnQpLnJlYWR5KClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZG9jdW1lbnQgaXMgcmVhZHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWFkeShmbikge1xuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZm4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuYXR0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVib3VuY2VzIGEgZnVuY3Rpb24gb3ZlciBhIHRocmVzaG9sZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAgICAgIC0gVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICAgdGhyZXNob2xkIC0gdGltZSBpbiBtc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gIGV4ZWNBc2FwICAtIHdoZW4gdHJ1ZSwgZXhlY3V0ZSBpbW1lZGlhdGVseVxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IERlYm91bmNlZCBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHRocmVzaG9sZCwgZXhlY0FzYXAsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHRpbWVvdXQ7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGF5ZWQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFleGVjQXNhcCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhlY0FzYXApIHtcbiAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChkZWxheWVkLCB0aHJlc2hvbGQgfHwgMTAwKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgZG9jdW1lbnQgc3VwcG9ydHMgVGV4dFdyYXBcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc1RleHRXcmFwKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3R5bGUgfSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmV0dXJuIHN0eWxlLnRleHRXcmFwIHx8IHN0eWxlLldlYmtpdFRleHRXcmFwIHx8IHN0eWxlLk1velRleHRXcmFwIHx8IHN0eWxlLk1zVGV4dFdyYXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IGZvciB0cmFja2luZyBuZXh0IHdoaXRlc3BhY2UgcGFyYW1zXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICAgIGZ1bmN0aW9uIE5leHRXU19wYXJhbXMoKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICBOZXh0V1NfcGFyYW1zLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBpbmRleCBpcyBjb250YWluZWQgaW4gcHJldmlvdXNseSBjYWxjdWxhdGVkIGxpc3Qgb2Ygd2hpdGUtc3BhY2U6bm93cmFwIHJhbmdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2hpdGVTcGFjZU5vV3JhcChpbmRleCkge1xuICAgICAgICAvLyBJcyBpbmRleCBpbnNpZGUgMSBvZiB0aGUgcmFuZ2VzP1xuICAgICAgICAvLyBzdGFydCBhbmQgZW5kIGFyZSBicmVha2FibGUsIGJ1dCBub3QgaW5zaWRlIHJhbmdlXG4gICAgICAgIHJldHVybiB3c253TWF0Y2hlcy5zb21lKHJhbmdlID0+IChyYW5nZS5zdGFydCA8IGluZGV4ICYmIGluZGV4IDwgcmFuZ2UuZW5kKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgY2FsY3VsYXRlIHdoaXRlLXNwYWNlOm5vd3JhcCBvZmZzZXRzIGZvciBsaW5lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSAgICBlbCAgICAgICAgIC0gdGhlIGVsZW1lbnQgdG8gYWN0IG9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlVGFnIC0gaW5jbHVkZSBsZW5ndGggb2YgdGFnIGl0c2VsZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZUNhbGNOb1dyYXBPZmZzZXRzRm9yTGluZShlbCwgaW5jbHVkZVRhZykge1xuICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT09IGVsLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgLy8gRm91bmQgYW4gZW1iZWRkZWQgdGFnXG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgICAgICAgIGlmIChzdHlsZS53aGl0ZVNwYWNlID09PSBcIm5vd3JhcFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gVGFnIHdpdGggd2hpdGUtc3BhY2U6bm93cmFwIC0gYWRkIG1hdGNoLCBza2lwIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuID0gZWwub3V0ZXJIVE1MLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3c253TWF0Y2hlcy5wdXNoKHsgc3RhcnQ6IHdzbndPZmZzZXQsIGVuZDogd3Nud09mZnNldCArIGxlbiB9KTtcbiAgICAgICAgICAgICAgICB3c253T2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGFnIHdpdGhvdXQgd2hpdGUtc3BhY2U6bm93cmFwIC0gcmVjdXJzaXZlbHkgY2hlY2sgY2hpbGRyZW4gb2YgdGFnXG4gICAgICAgICAgICAgICAgZm9yRWFjaChlbC5jaGlsZE5vZGVzLCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlQ2FsY05vV3JhcE9mZnNldHNGb3JMaW5lKGNoaWxkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZVRhZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBMZW5ndGggb2Ygb3BlbmluZyB0YWcsIGF0dHJpYnV0ZXMsIGFuZCBjbG9zaW5nIHRhZ1xuICAgICAgICAgICAgICAgICAgICB3c253T2Zmc2V0ICs9IChlbC5vdXRlckhUTUwubGVuZ3RoIC0gZWwuaW5uZXJIVE1MLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVsLm5vZGVUeXBlID09PSBlbC5DT01NRU5UX05PREUpIHtcbiAgICAgICAgICAgIHdzbndPZmZzZXQgKz0gZWwubGVuZ3RoICsgNzsgLy8gZGVsaW1pdGVyOiA8IS0tIC0tPlxuICAgICAgICB9IGVsc2UgaWYgKGVsLm5vZGVUeXBlID09PSBlbC5QUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREUpIHtcbiAgICAgICAgICAgIHdzbndPZmZzZXQgKz0gZWwubGVuZ3RoICsgMjsgLy8gZGVsaW1pdGVyOiA8ID5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRleHQgbm9kZTogYWRkIGxlbmd0aFxuICAgICAgICAgICAgd3Nud09mZnNldCArPSBlbC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgd2hpdGUtc3BhY2U6bm93cmFwIG9mZnNldHMgZm9yIGxpbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9ICAgIGVsICAgICAgICAgICAgIC0gdGhlIGVsZW1lbnQgdG8gYWN0IG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICBvbGRXUyAgICAgICAgICAtIFwib2xkXCIgd2hpdGVzcGFjZSBzZXR0aW5nIGZvciB0ZW1wb3JhcmlseSByZXNldHRpbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gIGxpbmVDaGFyT2Zmc2V0IC0gY2hhciBvZmZzZXQgb2YgY3VycmVudCBsaW5lIGZyb20gc3RhcnQgb2YgdGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbGNOb1dyYXBPZmZzZXRzRm9yTGluZShlbCwgb2xkV1MsIGxpbmVDaGFyT2Zmc2V0KSB7XG4gICAgICAgIC8vIEZvciBmaXJzdCBsaW5lIChsaW5lQ2hhck9mZnNldCA9PT0gMCksIGNhbGN1bGF0ZSBzdGFydCBhbmQgZW5kIG9mZnNldHMgZm9yIGVhY2hcbiAgICAgICAgLy8gd2hpdGUtc3BhY2U6bm93cmFwIGVsZW1lbnQgaW4gdGhlIGxpbmUuXG4gICAgICAgIGlmIChsaW5lQ2hhck9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gUmVzZXQgd2hpdGVTcGFjZSBzZXR0aW5nIHdoZW4gYnJlYWtNYXRjaGVzIGlzIGJlaW5nIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgIC8vIHNvIHdoaXRlLXNwYWNlOm5vd3JhcCBjYW4gYmUgZGV0ZWN0ZWQgaW4gdGV4dFxuICAgICAgICAgICAgZWwuc3R5bGUud2hpdGVTcGFjZSA9IG9sZFdTO1xuXG4gICAgICAgICAgICB3c253T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHdzbndNYXRjaGVzID0gW107XG4gICAgICAgICAgICByZWN1cnNpdmVDYWxjTm9XcmFwT2Zmc2V0c0ZvckxpbmUoZWwsIGZhbHNlKTtcblxuICAgICAgICAgICAgLy8gUmVzdG9yZSB0ZW1wb3Jhcnkgd2hpdGVzcGFjZSBzZXR0aW5nIHRvIHJlY2FsYyB3aWR0aFxuICAgICAgICAgICAgZWwuc3R5bGUud2hpdGVTcGFjZSA9IFwibm93cmFwXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgYWxsIG90aGVyIGxpbmVzLCB1cGRhdGUgdGhlIG9mZnNldHMgZm9yIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgLy8gMS4gSWdub3JlIG1hdGNoZXMgbGVzcyB0aGFuIG9mZnNldFxuICAgICAgICAgICAgLy8gMi4gU3VidHJhY3Qgb2Zmc2V0IGZyb20gcmVtYWluaW5nIG1hdGNoZXNcbiAgICAgICAgICAgIGNvbnN0IG5ld01hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIHdzbndNYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoLnN0YXJ0ID4gbGluZUNoYXJPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWF0Y2hlcy5wdXNoKHsgc3RhcnQ6IG1hdGNoLnN0YXJ0IC0gbGluZUNoYXJPZmZzZXQsIGVuZDogbWF0Y2guZW5kIC0gbGluZUNoYXJPZmZzZXQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3c253TWF0Y2hlcyA9IG5ld01hdGNoZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdHJpcCBiYWxhbmNlLXRleHQgdGFncyBmcm9tIGFuIGVsZW1lbnQgaW5zZXJ0ZWQgaW4gcHJldmlvdXMgcnVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsIC0gdGhlIGVsZW1lbnQgdG8gYWN0IG9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlVGFncyhlbCkge1xuICAgICAgICAvLyBSZW1vdmUgc29mdC1oeXBoZW4gYnJlYWtzXG4gICAgICAgIGxldCBicnMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCdicltkYXRhLW93bmVyPVwiYmFsYW5jZS10ZXh0LWh5cGhlblwiXScpO1xuICAgICAgICBmb3JFYWNoKGJycywgKGJyKSA9PiB7XG4gICAgICAgICAgICBici5vdXRlckhUTUwgPSBcIlwiO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZXBsYWNlIG90aGVyIGJyZWFrcyB3aXRoIHdoaXRlc3BhY2VcbiAgICAgICAgYnJzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnYnJbZGF0YS1vd25lcj1cImJhbGFuY2UtdGV4dFwiXScpO1xuICAgICAgICBmb3JFYWNoKGJycywgKGJyKSA9PiB7XG4gICAgICAgICAgICBici5vdXRlckhUTUwgPSBcIiBcIjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVzdG9yZSBoeXBoZW5zIGluc2VydGVkIGZvciBzb2Z0LWh5cGhlbnNcbiAgICAgICAgbGV0IHNwYW5zID0gZWwucXVlcnlTZWxlY3RvckFsbCgnc3BhbltkYXRhLW93bmVyPVwiYmFsYW5jZS10ZXh0LXNvZnRoeXBoZW5cIl0nKTtcbiAgICAgICAgaWYgKHNwYW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvckVhY2goc3BhbnMsIChzcGFuKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcdTAwYWRcIik7XG4gICAgICAgICAgICAgICAgc3Bhbi5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0ZXh0Tm9kZSwgc3Bhbik7XG4gICAgICAgICAgICAgICAgc3Bhbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNwYW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgc3BhbnMgaW5zZXJ0ZWQgZm9yIGp1c3RpZmllZCB0ZXh0XG4gICAgICAgIHNwYW5zID0gZWwucXVlcnlTZWxlY3RvckFsbCgnc3BhbltkYXRhLW93bmVyPVwiYmFsYW5jZS10ZXh0LWp1c3RpZnlcIl0nKTtcbiAgICAgICAgaWYgKHNwYW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCB0eHQgPSBcIlwiO1xuICAgICAgICAgICAgZm9yRWFjaChzcGFucywgKHNwYW4pID0+IHtcbiAgICAgICAgICAgICAgICB0eHQgKz0gc3Bhbi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICBzcGFuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3Bhbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IHR4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgd2Ugc2hvdWxkIGp1c3RpZnkgdGhlIGJhbGFuY2VkIHRleHQgd2l0aCB0aGVcbiAgICAgKiBlbGVtZW50IGJhc2VkIG9uIHRoZSB0ZXh0QWxpZ24gcHJvcGVydHkgaW4gdGhlIGNvbXB1dGVkIENTU1xuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBlbCAtIGVsZW1lbnQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGNvbnN0IGlzSnVzdGlmaWVkID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZWwuY3VycmVudFN0eWxlIHx8IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIChzdHlsZS50ZXh0QWxpZ24gPT09IFwianVzdGlmeVwiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIHdoaXRlc3BhY2UgYWZ0ZXIgd29yZHMgaW4gdGV4dCB0byBqdXN0aWZ5IHRoZSBzdHJpbmcgdG9cbiAgICAgKiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gICAgICogQHBhcmFtIHtOb2RlfSAgICBlbCAgICAgICAtIHRoZSBlbGVtZW50IHRvIGp1c3RpZnlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIHR4dCAgICAgIC0gdGV4dCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gIGNvbldpZHRoIC0gY29udGFpbmVyIHdpZHRoXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBKdXN0aWZpZWQgdGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGp1c3RpZnkoZWwsIHR4dCwgY29uV2lkdGgpIHtcbiAgICAgICAgdHh0ID0gdHh0LnRyaW0oKTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSB0eHQuc3BsaXQoXCIgXCIpLmxlbmd0aDtcbiAgICAgICAgdHh0ID0gYCR7dHh0fSBgO1xuXG4gICAgICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYXQgbGVhc3QgMiB3b3Jkcywgbm8gbmVlZCB0byBqdXN0aWZ5LlxuICAgICAgICBpZiAod29yZHMgPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHh0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCB3aWR0aCBvZiB0ZXh0IGluIHRoZSBET01cbiAgICAgICAgY29uc3QgdG1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHRtcC5pbm5lckhUTUwgPSB0eHQ7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKHRtcCk7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0bXAub2Zmc2V0V2lkdGg7XG4gICAgICAgIHRtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRtcCk7XG5cbiAgICAgICAgLy8gRmlndXJlIG91dCBvdXIgd29yZCBzcGFjaW5nIGFuZCByZXR1cm4gdGhlIGVsZW1lbnRcbiAgICAgICAgY29uc3Qgd29yZFNwYWNpbmcgPSBNYXRoLmZsb29yKChjb25XaWR0aCAtIHNpemUpIC8gKHdvcmRzIC0gMSkpO1xuICAgICAgICB0bXAuc3R5bGUud29yZFNwYWNpbmcgPSBgJHt3b3JkU3BhY2luZ31weGA7XG4gICAgICAgIHRtcC5zZXRBdHRyaWJ1dGUoXCJkYXRhLW93bmVyXCIsIFwiYmFsYW5jZS10ZXh0LWp1c3RpZnlcIik7XG5cbiAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKHRtcCk7XG4gICAgICAgIHJldHVybiBkaXYuaW5uZXJIVE1MO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZmYgY2hhciBhdCBpbmRleCBpcyBhIGJyZWFrIGNoYXIgb3V0c2lkZSBvZiBIVE1MIDwgPiB0YWdzLlxuICAgICAqIEJyZWFrIGNoYXIgY2FuIGJlOiB3aGl0ZXNwYWNlIChleGNlcHQgbm9uLWJyZWFraW5nLXNwYWNlOiB1MDBhMCksXG4gICAgICogaHlwZW4sIGVtZGFzaCAodTIwMTQpLCBlbmRhc2ggKHUyMDEzKSwgb3Igc29mdC1oeXBoZW4gKHUwMGFkKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eHQgICAtIHRoZSB0ZXh0IHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQnJlYWtDaGFyKHR4dCwgaW5kZXgpIHtcbiAgICAgICAgY29uc3QgcmUgPSAvKFteXFxTXFx1MDBhMF18LXxcXHUyMDE0fFxcdTIwMTN8XFx1MDBhZCkoPyFbXjxdKj4pL2c7XG4gICAgICAgIGxldCBtYXRjaDtcblxuICAgICAgICBpZiAoIWJyZWFrTWF0Y2hlcykge1xuICAgICAgICAgICAgLy8gT25seSBjYWxjIGJyZWFrIG1hdGNoZXMgb25jZSBwZXIgbGluZVxuICAgICAgICAgICAgYnJlYWtNYXRjaGVzID0gW107XG4gICAgICAgICAgICBtYXRjaCA9IHJlLmV4ZWModHh0KTtcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNXaGl0ZVNwYWNlTm9XcmFwKG1hdGNoLmluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBicmVha01hdGNoZXMucHVzaChtYXRjaC5pbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hdGNoID0gcmUuZXhlYyh0eHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJyZWFrTWF0Y2hlcy5pbmRleE9mKGluZGV4KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW4gdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24sIGFuIGluZGV4IGlzIGEgYnJlYWtcbiAgICAgKiBvcHBvcnR1bml0eSBpbiB0eHQgaWZmIGl0IGlzOlxuICAgICAqIC0gMCBvciB0eHQubGVuZ3RoXG4gICAgICogLSBpbmRleCBvZiBhIG5vbi13aGl0ZXNwYWNlIGNoYXIgaW1tZWRpYXRlbHkgcHJlY2VkZWQgYnkgYVxuICAgICAqICAgd2hpdGVzcGFjZSwgaHlwaGVuLCBzb2Z0LWh5cGhlbiwgZW0tZGFzaCwgb3IgZW4tZGFzaCBjaGFyLlxuICAgICAqXG4gICAgICogVGh1cywgaXQgZG9lc24ndCBob25vdXIgXCJ3aGl0ZS1zcGFjZVwiIG9yIGFueSBvdGhlciBVbmljb2RlXG4gICAgICogbGluZS1icmVha2luZyBjbGFzc2VzLilcbiAgICAgKlxuICAgICAqIEBwcmVjb25kaXRpb24gMCA8PSBpbmRleCAmJiBpbmRleCA8PSB0eHQubGVuZ3RoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHh0ICAgLSB0aGUgdGV4dCB0byBjaGVja1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSBpbmRleCB0byBjaGVja1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCcmVha09wcG9ydHVuaXR5KHR4dCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICgoaW5kZXggPT09IDApIHx8IChpbmRleCA9PT0gdHh0Lmxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgICAoaXNCcmVha0NoYXIodHh0LCBpbmRleCAtIDEpICYmICFpc0JyZWFrQ2hhcih0eHQsIGluZGV4KSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBmaXJzdCBicmVhayBvcHBvcnR1bml0eSAoQHNlZSBpc0JyZWFrT3Bwb3J0dW5pdHkpXG4gICAgICogaW4gdHh0IHRoYXQncyBib3RoIGFmdGVyLW9yLWVxdWFsLXRvIGluZGV4IGMgaW4gdGhlIGRpcmVjdGlvbiBkaXJcbiAgICAgKiBhbmQgcmVzdWx0aW5nIGluIGxpbmUgd2lkdGggZXF1YWwgdG8gb3IgcGFzdCBjbGFtcChkZXNXaWR0aCxcbiAgICAgKiAwLCBjb25XaWR0aCkgaW4gZGlyZWN0aW9uIGRpci4gIFNldHMgcmV0LmluZGV4IGFuZCByZXQud2lkdGhcbiAgICAgKiB0byB0aGUgY29ycmVzcG9uZGluZyBpbmRleCBhbmQgbGluZSB3aWR0aCAoZnJvbSB0aGUgc3RhcnQgb2ZcbiAgICAgKiB0eHQgdG8gcmV0LmluZGV4KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gICAgZWwgICAgICAgLSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICB0eHQgICAgICAtIHRleHQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICBjb25XaWR0aCAtIGNvbnRhaW5lciB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgZGVzV2lkdGggLSBkZXNpcmVkIHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICBkaXIgICAgICAtIGRpcmVjdGlvbiAoLTEgb3IgKzEpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICBjICAgICAgICAtIGNoYXIgaW5kZXggKDAgPD0gYyAmJiBjIDw9IHR4dC5sZW5ndGgpXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICByZXQgICAgICAtIHJldHVybiB7aW5kZXg6IHtudW1iZXJ9LCB3aWR0aDoge251bWJlcn19IG9mIHByZXZpb3VzL25leHQgYnJlYWtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kQnJlYWtPcHBvcnR1bml0eShlbCwgdHh0LCBjb25XaWR0aCwgZGVzV2lkdGgsIGRpciwgYywgcmV0KSB7XG4gICAgICAgIGxldCB3O1xuXG4gICAgICAgIGlmICh0eHQgJiYgdHlwZW9mIHR4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHdoaWxlICghaXNCcmVha09wcG9ydHVuaXR5KHR4dCwgYykpIHtcbiAgICAgICAgICAgICAgICAgICAgYyArPSBkaXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gdHh0LnN1YnN0cigwLCBjKTtcbiAgICAgICAgICAgICAgICB3ID0gZWwub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHcgPD0gZGVzV2lkdGgpIHx8ICh3IDw9IDApIHx8IChjID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChkZXNXaWR0aCA8PSB3KSB8fCAoY29uV2lkdGggPD0gdykgfHwgKGMgPT09IHR4dC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGMgKz0gZGlyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldC5pbmRleCA9IGM7XG4gICAgICAgIHJldC53aWR0aCA9IHc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0cyB0aGUgd2lkdGggb2YgYSBub24tYnJlYWtpbmcgc3BhY2UgY2hhcmFjdGVyLCBnaXZlbiB0aGUgaGVpZ2h0IG9mXG4gICAgICogdGhlIGVsZW1lbnQgd2l0aCBuby13cmFwIGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9ICAgZWwgLSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGggIC0gaGVpZ2h0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNwYWNlV2lkdGgoZWwsIGgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgICAgICBjb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuYm90dG9tID0gMDtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnJpZ2h0ID0gMDtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gMDtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IDA7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5tYXJnaW4gPSAwO1xuICAgICAgICBjb250YWluZXIuc3R5bGUucGFkZGluZyA9IDA7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblxuICAgICAgICBjb25zdCBzcGFjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG4gICAgICAgIHNwYWNlLnN0eWxlLmZvbnRTaXplID0gXCIyMDAwcHhcIjtcbiAgICAgICAgc3BhY2UuaW5uZXJIVE1MID0gXCImbmJzcDtcIjtcblxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc3BhY2UpO1xuXG4gICAgICAgIGVsLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgICAgY29uc3QgZGltcyA9IHNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuXG4gICAgICAgIGNvbnN0IHNwYWNlUmF0aW8gPSBkaW1zLmhlaWdodCAvIGRpbXMud2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIChoIC8gc3BhY2VSYXRpbyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgbGlzdCBvZiBlbGVtZW50cyByZWdhcmRsZXNzIG9mIGlucHV0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xOb2RlfEFycmF5LWxpa2V9IGVsZW1lbnRzIC0gVGhlIHNlbGVjdG9yIHRvIHF1ZXJ5LCBvbmUgb3IgbW9yZSBlbGVtZW50c1xuICAgICAqIEByZXR1cm4ge0FycmF5PHtOb2RlfT59XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudHNMaXN0KGVsZW1lbnRzKSB7XG4gICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlzIHNlbGVjdG9yXG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlzIHNpbmdsZSBlbGVtZW50XG4gICAgICAgIGlmIChlbGVtZW50cy50YWdOYW1lICYmIGVsZW1lbnRzLnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWxlbWVudHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBXaGVuIGEgYnJvd3NlciBoYXMgbmF0aXZlIHN1cHBvcnQgZm9yIHRoZSB0ZXh0LXdyYXAgcHJvcGVydHksXG4gICAgICogdGhlIHRleHQgYmFsYW5jZVRleHQgcGx1Z2luIHdpbGwgbGV0IHRoZSBicm93c2VyIGhhbmRsZSBpdCBuYXRpdmVseSxcbiAgICAgKiBvdGhlcndpc2UgaXQgd2lsbCBhcHBseSBpdHMgb3duIHRleHQgYmFsYW5jaW5nIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xOb2RlfEFycmF5LWxpa2V9IGVsZW1lbnRzIC0gdGhlIGxpc3Qgb2YgZWxlbWVudHMgdG8gYmFsYW5jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhbGFuY2VUZXh0KGVsZW1lbnRzKSB7XG4gICAgICAgIGZvckVhY2goZ2V0RWxlbWVudHNMaXN0KGVsZW1lbnRzKSwgKGVsKSA9PiB7XG4gICAgICAgICAgICAvLyBJbiBhIGxvd2VyIGxldmVsIGxhbmd1YWdlLCB0aGlzIGFsZ29yaXRobSB0YWtlcyB0aW1lXG4gICAgICAgICAgICAvLyBjb21wYXJhYmxlIHRvIG5vcm1hbCB0ZXh0IGxheW91dCBvdGhlciB0aGFuIHRoZSBmYWN0XG4gICAgICAgICAgICAvLyB0aGF0IHdlIGRvIHR3byBwYXNzZXMgaW5zdGVhZCBvZiBvbmUsIHNvIHdlIHNob3VsZFxuICAgICAgICAgICAgLy8gYmUgYWJsZSB0byBkbyB3aXRob3V0IHRoaXMgbGltaXQuXG4gICAgICAgICAgICBjb25zdCBtYXhUZXh0V2lkdGggPSA1MDAwO1xuXG4gICAgICAgICAgICAvLyBzdHJpcCBiYWxhbmNlLXRleHQgZ2VuZXJhdGVkIHRhZ3NcbiAgICAgICAgICAgIHJlbW92ZVRhZ3MoZWwpO1xuXG4gICAgICAgICAgICAvLyBzYXZlIHNldHRpbmdzXG4gICAgICAgICAgICBjb25zdCBvbGRXUyA9IGVsLnN0eWxlLndoaXRlU3BhY2U7XG4gICAgICAgICAgICBjb25zdCBvbGRGbG9hdCA9IGVsLnN0eWxlLmZsb2F0O1xuICAgICAgICAgICAgY29uc3Qgb2xkRGlzcGxheSA9IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICBjb25zdCBvbGRQb3NpdGlvbiA9IGVsLnN0eWxlLnBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3Qgb2xkTEggPSBlbC5zdHlsZS5saW5lSGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgbGluZSBoZWlnaHQgYmVmb3JlIG1lYXN1cmluZyBjb250YWluZXIgc2l6ZVxuICAgICAgICAgICAgZWwuc3R5bGUubGluZUhlaWdodCA9IFwibm9ybWFsXCI7XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lcldpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJIZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBzZXR0aW5nc1xuICAgICAgICAgICAgZWwuc3R5bGUud2hpdGVTcGFjZSA9IFwibm93cmFwXCI7XG4gICAgICAgICAgICBlbC5zdHlsZS5mbG9hdCA9IFwibm9uZVwiO1xuICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lXCI7XG4gICAgICAgICAgICBlbC5zdHlsZS5wb3NpdGlvbiA9IFwic3RhdGljXCI7XG5cbiAgICAgICAgICAgIGxldCBub3dyYXBXaWR0aCA9IGVsLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgY29uc3Qgbm93cmFwSGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBBbiBlc3RpbWF0ZSBvZiB0aGUgYXZlcmFnZSBsaW5lIHdpZHRoIHJlZHVjdGlvbiBkdWVcbiAgICAgICAgICAgIC8vIHRvIHRyaW1taW5nIHRyYWlsaW5nIHNwYWNlIHRoYXQgd2UgZXhwZWN0IG92ZXIgYWxsXG4gICAgICAgICAgICAvLyBsaW5lcyBvdGhlciB0aGFuIHRoZSBsYXN0LlxuICAgICAgICAgICAgY29uc3Qgc3BhY2VXaWR0aCA9ICgob2xkV1MgPT09IFwicHJlLXdyYXBcIikgPyAwIDogZ2V0U3BhY2VXaWR0aChlbCwgbm93cmFwSGVpZ2h0KSk7XG5cbiAgICAgICAgICAgIGlmIChjb250YWluZXJXaWR0aCA+IDAgJiYgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGRpdmlkZSBieSB6ZXJvXG4gICAgICAgICAgICAgICAgICAgIG5vd3JhcFdpZHRoID4gY29udGFpbmVyV2lkdGggJiYgLy8gdGV4dCBpcyBtb3JlIHRoYW4gMSBsaW5lXG4gICAgICAgICAgICAgICAgICAgIG5vd3JhcFdpZHRoIDwgbWF4VGV4dFdpZHRoKSB7ICAgLy8gdGV4dCBpcyBsZXNzIHRoYW4gYXJiaXRyYXJ5IGxpbWl0IChtYWtlIHRoaXMgYSBwYXJhbT8pXG4gICAgICAgICAgICAgICAgbGV0IHJlbWFpbmluZ1RleHQgPSBlbC5pbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1RleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lVGV4dCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkSnVzdGlmeSA9IGlzSnVzdGlmaWVkKGVsKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RMaW5lcyA9IE1hdGgucm91bmQoY29udGFpbmVySGVpZ2h0IC8gbm93cmFwSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBsZXQgcmVtTGluZXMgPSB0b3RMaW5lcztcbiAgICAgICAgICAgICAgICBsZXQgbGluZUNoYXJPZmZzZXQgPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gbG9vcCB2YXJzXG4gICAgICAgICAgICAgICAgbGV0IGRlc2lyZWRXaWR0aCwgZ3Vlc3NJbmRleCwgbGUsIGdlLCBzcGxpdEluZGV4LCBpc0h5cGhlbiwgaXNTb2Z0SHlwaGVuO1xuXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXJlIHRvIGJyZWFrOlxuICAgICAgICAgICAgICAgIHdoaWxlIChyZW1MaW5lcyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgd2hpdGVzcGFjZSBtYXRjaCBjYWNoZSBmb3IgZWFjaCBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrTWF0Y2hlcyA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTXVzdCBjYWxjIHdoaXRlLXNwYWNlOm5vd3JhcCBvZmZzZXRzIGJlZm9yZSBmaXJzdCBjYWxsIHRvIGZpbmRCcmVha09wcG9ydHVuaXR5KClcbiAgICAgICAgICAgICAgICAgICAgY2FsY05vV3JhcE9mZnNldHNGb3JMaW5lKGVsLCBvbGRXUywgbGluZUNoYXJPZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlc2lyZWRXaWR0aCA9IE1hdGgucm91bmQoKG5vd3JhcFdpZHRoICsgc3BhY2VXaWR0aCkgLyByZW1MaW5lcyAtIHNwYWNlV2lkdGgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEd1ZXNzZWQgY2hhciBpbmRleFxuICAgICAgICAgICAgICAgICAgICBndWVzc0luZGV4ID0gTWF0aC5yb3VuZCgocmVtYWluaW5nVGV4dC5sZW5ndGggKyAxKSAvIHJlbUxpbmVzKSAtIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgbGUgPSBuZXcgTmV4dFdTX3BhcmFtcygpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgYSBicmVha2luZyBzcGFjZSBzb21ld2hlcmUgYmVmb3JlIChvciBlcXVhbCB0bykgZGVzaXJlZCB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IG5lY2Vzc2FyaWx5IHRoZSBjbG9zZXN0IHRvIHRoZSBkZXNpcmVkIHdpZHRoLlxuICAgICAgICAgICAgICAgICAgICBmaW5kQnJlYWtPcHBvcnR1bml0eShlbCwgcmVtYWluaW5nVGV4dCwgY29udGFpbmVyV2lkdGgsIGRlc2lyZWRXaWR0aCwgLTEsIGd1ZXNzSW5kZXgsIGxlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIGZpcnN0IGJyZWFraW5nIGNoYXIgYWZ0ZXIgKG9yIGVxdWFsIHRvKSBkZXNpcmVkIHdpZHRoLlxuICAgICAgICAgICAgICAgICAgICBnZSA9IG5ldyBOZXh0V1NfcGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGd1ZXNzSW5kZXggPSBsZS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgZmluZEJyZWFrT3Bwb3J0dW5pdHkoZWwsIHJlbWFpbmluZ1RleHQsIGNvbnRhaW5lcldpZHRoLCBkZXNpcmVkV2lkdGgsICsxLCBndWVzc0luZGV4LCBnZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCBmaXJzdCBicmVha2luZyBjaGFyIGJlZm9yZSAob3IgZXF1YWwgdG8pIGRlc2lyZWQgd2lkdGguXG4gICAgICAgICAgICAgICAgICAgIGxlLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGd1ZXNzSW5kZXggPSBnZS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgZmluZEJyZWFrT3Bwb3J0dW5pdHkoZWwsIHJlbWFpbmluZ1RleHQsIGNvbnRhaW5lcldpZHRoLCBkZXNpcmVkV2lkdGgsIC0xLCBndWVzc0luZGV4LCBsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCBjbG9zZXN0IHN0cmluZyB0byBkZXNpcmVkIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICBpZiAobGUuaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0SW5kZXggPSBnZS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoY29udGFpbmVyV2lkdGggPCBnZS53aWR0aCkgfHwgKGxlLmluZGV4ID09PSBnZS5pbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0SW5kZXggPSBsZS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0SW5kZXggPSAoKE1hdGguYWJzKGRlc2lyZWRXaWR0aCAtIGxlLndpZHRoKSA8IE1hdGguYWJzKGdlLndpZHRoIC0gZGVzaXJlZFdpZHRoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGxlLmluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBnZS5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBCcmVhayBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgbGluZVRleHQgPSByZW1haW5pbmdUZXh0LnN1YnN0cigwLCBzcGxpdEluZGV4KS5yZXBsYWNlKC9cXHMkLywgXCJcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgaXNTb2Z0SHlwaGVuID0gQm9vbGVhbihsaW5lVGV4dC5tYXRjaCgvXFx1MDBhZCQvKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NvZnRIeXBoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2Ugc29mdC1oeXBoZW4gY2F1c2luZyBicmVhayB3aXRoIGV4cGxpY2l0IGh5cGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVRleHQgPSBsaW5lVGV4dC5yZXBsYWNlKC9cXHUwMGFkJC8sICc8c3BhbiBkYXRhLW93bmVyPVwiYmFsYW5jZS10ZXh0LXNvZnRoeXBoZW5cIj4tPC9zcGFuPicpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEp1c3RpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RleHQgKz0ganVzdGlmeShlbCwgbGluZVRleHQsIGNvbnRhaW5lcldpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RleHQgKz0gbGluZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0h5cGhlbiA9IGlzU29mdEh5cGhlbiB8fCBCb29sZWFuKGxpbmVUZXh0Lm1hdGNoKC8oLXxcXHUyMDE0fFxcdTIwMTMpJC8pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RleHQgKz0gaXNIeXBoZW4gPyAnPGJyIGRhdGEtb3duZXI9XCJiYWxhbmNlLXRleHQtaHlwaGVuXCIgLz4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnPGJyIGRhdGEtb3duZXI9XCJiYWxhbmNlLXRleHRcIiBhcmlhLWhpZGRlbj1cInRydWVcIiAvPic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nVGV4dCA9IHJlbWFpbmluZ1RleHQuc3Vic3RyKHNwbGl0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lQ2hhck9mZnNldCA9IHNwbGl0SW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNvdW50ZXJzXG4gICAgICAgICAgICAgICAgICAgIHJlbUxpbmVzLS07XG4gICAgICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IHJlbWFpbmluZ1RleHQ7XG4gICAgICAgICAgICAgICAgICAgIG5vd3JhcFdpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEp1c3RpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gbmV3VGV4dCArIGp1c3RpZnkoZWwsIHJlbWFpbmluZ1RleHQsIGNvbnRhaW5lcldpZHRoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBuZXdUZXh0ICsgcmVtYWluaW5nVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlc3RvcmUgc2V0dGluZ3NcbiAgICAgICAgICAgIGVsLnN0eWxlLndoaXRlU3BhY2UgPSBvbGRXUztcbiAgICAgICAgICAgIGVsLnN0eWxlLmZsb2F0ID0gb2xkRmxvYXQ7XG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb2xkRGlzcGxheTtcbiAgICAgICAgICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gb2xkUG9zaXRpb247XG4gICAgICAgICAgICBlbC5zdHlsZS5saW5lSGVpZ2h0ID0gb2xkTEg7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIGJhbGFuY2VUZXh0IHBsdWdpbiBvbiBlbGVtZW50cyB0aGF0IGl0J3Mgd2F0Y2hpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV2F0Y2hlZCgpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3JzID0gd2F0Y2hpbmcuc2VsLmpvaW4oXCIsXCIpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZEVsZW1lbnRzID0gZ2V0RWxlbWVudHNMaXN0KHNlbGVjdG9ycyk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseSh3YXRjaGluZy5lbCwgc2VsZWN0ZWRFbGVtZW50cyk7XG4gICAgICAgIGJhbGFuY2VUZXh0KGVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBldmVudHMgZm9yIHdoaWNoIHRvIHJlLWFwcGx5IEJhbGFuY2VUZXh0LiAgVGhleSBhcmU6XG4gICAgICogLSBEb2N1bWVudCByZWFkeVxuICAgICAqIC0gRG9jdW1lbnQgZnVsbCBsb2FkXG4gICAgICogLSBXaW5kb3cgcmVzaXplXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdEhhbmRsZXJzKCkge1xuICAgICAgICBpZiAoaGFuZGxlcnNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgb24gRE9NIHJlYWR5XG4gICAgICAgIHJlYWR5KHVwZGF0ZVdhdGNoZWQpO1xuXG4gICAgICAgIC8vIFJlYXBwbHkgb24gZnVsbCBsb2FkXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCB1cGRhdGVXYXRjaGVkKTtcblxuICAgICAgICAvLyBSZWFwcGx5IG9uIHJlc2l6ZVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBkZWJvdW5jZSh1cGRhdGVXYXRjaGVkKSk7XG5cbiAgICAgICAgaGFuZGxlcnNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEJhbGFuY2VUZXh0IHJvdXRpbmUgb24gdGhlIGRvY3VtZW50IGFuZCB3YXRjaCB0aGUgbGlzdFxuICAgICAqIG9mIGVsZW1lbnRzLiAgT24gd2luZG93IHJlc2l6ZSwgcmUtYXBwbHkgQmFsYW5jZVRleHQgdG8gdGhlIGdpdmVuIGVsZW1lbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xOb2RlfEFycmF5LWxpa2V9IGVsZW1lbnRzIC0gdGhlIGVsZW1lbnRzIHRvIHdhdGNoIGFmdGVyIGFwcGx5aW5nIEJhbGFuY2VUZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFsYW5jZVRleHRBbmRXYXRjaChlbGVtZW50cykge1xuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB3YXRjaGluZy5zZWwucHVzaChlbGVtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JFYWNoKGdldEVsZW1lbnRzTGlzdChlbGVtZW50cyksIChlbCkgPT4ge1xuICAgICAgICAgICAgICAgIHdhdGNoaW5nLmVsLnB1c2goZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0SGFuZGxlcnMoKTtcbiAgICAgICAgdXBkYXRlV2F0Y2hlZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3Agd2F0Y2hpbmcgZWxlbWVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE5vZGV8QXJyYXktbGlrZX0gZWxlbWVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bndhdGNoKGVsZW1lbnRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHdhdGNoaW5nLnNlbCA9IHdhdGNoaW5nLnNlbC5maWx0ZXIoZWwgPT4gZWwgIT09IGVsZW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnRzID0gZ2V0RWxlbWVudHNMaXN0KGVsZW1lbnRzKTtcbiAgICAgICAgICAgIHdhdGNoaW5nLmVsID0gd2F0Y2hpbmcuZWwuZmlsdGVyKGVsID0+IGVsZW1lbnRzLmluZGV4T2YoZWwpID09PSAtMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmVhdCB0aGlzIGFwcCBhcyBhIHBvbHlmaWxsLiAgV2F0Y2ggZm9yIGNoYW5nZXMgdG8gdGhlIC5iYWxhbmNlLXRleHQgc2VsZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgICAgICAgaWYgKHBvbHlmaWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhdGNoaW5nLnNlbC5wdXNoKFwiLmJhbGFuY2UtdGV4dFwiKTtcbiAgICAgICAgaW5pdEhhbmRsZXJzKCk7XG4gICAgICAgIHBvbHlmaWxsZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBpbnRlcmZhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE5vZGV8QXJyYXktbGlrZX0gZWxlbWVudHMgLSBlbGVtZW50cyB0byBiYWxhbmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgICBvcHRpb25zICAtIHByb2Nlc3Npbmcgb3B0aW9uc1xuICAgICAqICAtIHtib29sZWFufSB3YXRjaCAtIHdhdGNoIGVsZW1lbnRzIGZvciByZXNpemVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWJsaWNJbnRlcmZhY2UoZWxlbWVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50cykge1xuICAgICAgICAgICAgLy8gZW1wdHkgY2FsbCBtZWFucyBwb2x5ZmlsbCAod2F0Y2ggZm9yIGNoYW5nZXMpXG4gICAgICAgICAgICBwb2x5ZmlsbCgpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53YXRjaCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYmFsYW5jZVRleHRBbmRXYXRjaChlbGVtZW50cyk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndhdGNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdW53YXRjaChlbGVtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYWxhbmNlVGV4dChlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWNJbnRlcmZhY2UudXBkYXRlV2F0Y2hlZCA9IHVwZGF0ZVdhdGNoZWQ7XG5cbiAgICBpZiAoaGFzVGV4dFdyYXAoKSkge1xuICAgICAgICBub29wLnVwZGF0ZVdhdGNoZWQgPSBub29wO1xuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgcmV0dXJuIHB1YmxpY0ludGVyZmFjZTtcbn0pKTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFEQSxXQU1BO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQWZBO0FBaUJBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakJBO0FBbUJBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBYUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQWhCQTtBQUNBO0FBQ0E7QUFzQkE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVBBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFQQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFsQ0E7QUFDQTtBQUNBO0FBc0NBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUF6SEE7QUFDQTtBQUNBO0FBMkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqSUE7QUFtSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQXJyQkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/balance-text/balancetext.js\n");

/***/ }),

/***/ "../node_modules/react-balance-text/dist/index.js":
/*!********************************************************!*\
  !*** ../node_modules/react-balance-text/dist/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = __webpack_require__(/*! react */ \"../node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"../node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _balanceText2 = __webpack_require__(/*! balance-text */ \"../node_modules/balance-text/balancetext.js\");\n\nvar _balanceText3 = _interopRequireDefault(_balanceText2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar BalanceText = function (_React$Component) {\n  _inherits(BalanceText, _React$Component);\n\n  function BalanceText() {\n    _classCallCheck(this, BalanceText);\n\n    var _this = _possibleConstructorReturn(this, (BalanceText.__proto__ || Object.getPrototypeOf(BalanceText)).call(this));\n\n    _this._handleResize = _this._handleResize.bind(_this);\n    _this.state = {\n      visible: false\n    };\n    return _this;\n  }\n\n  _createClass(BalanceText, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      window.addEventListener('resize', this._handleResize);\n\n      this._makeVisible();\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this._balanceText();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      window.removeEventListener('resize', this._handleResize);\n    }\n  }, {\n    key: '_makeVisible',\n    value: function _makeVisible() {\n      var _this2 = this;\n\n      this.setState({\n        visible: true\n      });\n      setTimeout(function () {\n        return _this2._balanceText();\n      }, 0);\n    }\n  }, {\n    key: '_balanceText',\n    value: function _balanceText() {\n      var container = this.container;\n\n      if (!container) {\n        return;\n      }\n\n      (0, _balanceText3[\"default\"])(container);\n    }\n  }, {\n    key: '_handleResize',\n    value: function _handleResize() {\n      if (!this.props.resize) {\n        return;\n      }\n\n      this._balanceText();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this3 = this;\n\n      var _props = this.props,\n          children = _props.children,\n          style = _props.style,\n          className = _props.className;\n      var visible = this.state.visible;\n\n      var combinedStyle = _extends({}, style, {\n        visibility: visible ? 'visible' : 'hidden'\n      });\n\n      return _react2[\"default\"].createElement('div', {\n        style: combinedStyle,\n        className: className\n      }, _react2[\"default\"].createElement('span', {\n        ref: function ref(container) {\n          return _this3.container = container;\n        }\n      }, children));\n    }\n  }]);\n\n  return BalanceText;\n}(_react2[\"default\"].Component);\n\nBalanceText.defaultProps = {\n  children: '',\n  style: {},\n  resize: true\n};\nBalanceText.propTypes = {\n  children: _propTypes2[\"default\"].node,\n  className: _propTypes2[\"default\"].string,\n  style: _propTypes2[\"default\"].oneOfType([_propTypes2[\"default\"].arrayOf(_propTypes2[\"default\"].any), _propTypes2[\"default\"].any]),\n  resize: _propTypes2[\"default\"].bool\n};\nexports[\"default\"] = BalanceText;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWJhbGFuY2UtdGV4dC9kaXN0L2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1iYWxhbmNlLXRleHQvZGlzdC9pbmRleC5qcz9jZjJiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX2JhbGFuY2VUZXh0MiA9IHJlcXVpcmUoJ2JhbGFuY2UtdGV4dCcpO1xuXG52YXIgX2JhbGFuY2VUZXh0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JhbGFuY2VUZXh0Mik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEJhbGFuY2VUZXh0ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoQmFsYW5jZVRleHQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gQmFsYW5jZVRleHQoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYWxhbmNlVGV4dCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJhbGFuY2VUZXh0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmFsYW5jZVRleHQpKS5jYWxsKHRoaXMpKTtcblxuICAgICAgICBfdGhpcy5faGFuZGxlUmVzaXplID0gX3RoaXMuX2hhbmRsZVJlc2l6ZS5iaW5kKF90aGlzKTtcblxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQmFsYW5jZVRleHQsIFt7XG4gICAgICAgIGtleTogJ2NvbXBvbmVudERpZE1vdW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZVJlc2l6ZSk7XG4gICAgICAgICAgICB0aGlzLl9tYWtlVmlzaWJsZSgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICAgICAgdGhpcy5fYmFsYW5jZVRleHQoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29tcG9uZW50V2lsbFVubW91bnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5faGFuZGxlUmVzaXplKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX21ha2VWaXNpYmxlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlVmlzaWJsZSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgdmlzaWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIuX2JhbGFuY2VUZXh0KCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2JhbGFuY2VUZXh0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9iYWxhbmNlVGV4dCgpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcblxuICAgICAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICgwLCBfYmFsYW5jZVRleHQzLmRlZmF1bHQpKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19oYW5kbGVSZXNpemUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVJlc2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9wcy5yZXNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2JhbGFuY2VUZXh0KCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbmRlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBfcHJvcHMuc3R5bGUsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gX3Byb3BzLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIHZhciB2aXNpYmxlID0gdGhpcy5zdGF0ZS52aXNpYmxlO1xuXG5cbiAgICAgICAgICAgIHZhciBjb21iaW5lZFN0eWxlID0gX2V4dGVuZHMoe30sIHN0eWxlLCB7XG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogdmlzaWJsZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgIHsgc3R5bGU6IGNvbWJpbmVkU3R5bGUsIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sXG4gICAgICAgICAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgeyByZWY6IGZ1bmN0aW9uIHJlZihjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEJhbGFuY2VUZXh0O1xufShfcmVhY3QyLmRlZmF1bHQuQ29tcG9uZW50KTtcblxuQmFsYW5jZVRleHQuZGVmYXVsdFByb3BzID0ge1xuICAgIGNoaWxkcmVuOiAnJyxcbiAgICBzdHlsZToge30sXG4gICAgcmVzaXplOiB0cnVlXG59O1xuQmFsYW5jZVRleHQucHJvcFR5cGVzID0ge1xuICAgIGNoaWxkcmVuOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm5vZGUsXG4gICAgY2xhc3NOYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcbiAgICBzdHlsZTogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzMi5kZWZhdWx0LmFueSksIF9wcm9wVHlwZXMyLmRlZmF1bHQuYW55XSksXG4gICAgcmVzaXplOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2xcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBCYWxhbmNlVGV4dDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUVBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBTUE7QUEzQkE7QUFDQTtBQTZCQTtBQTVGQTtBQUNBO0FBOEZBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/react-balance-text/dist/index.js\n");

/***/ })

}]);