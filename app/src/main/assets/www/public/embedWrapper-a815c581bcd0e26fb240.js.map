{"version":3,"file":"embedWrapper-a815c581bcd0e26fb240.js","mappings":"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","sources":["webpack://odysee.com/../ui/page/embedWrapper/internal/embedClaimComponent/view.jsx","webpack://odysee.com/../ui/page/embedWrapper/internal/embedClaimComponent/index.js","webpack://odysee.com/../ui/page/embedWrapper/view.jsx","webpack://odysee.com/../ui/page/embedWrapper/index.js"],"sourcesContent":["// @flow\nimport React from 'react';\nimport classnames from 'classnames';\n\nimport * as RENDER_MODES from 'constants/file_render_modes';\n\nimport { useHistory } from 'react-router';\nimport { parseURI } from 'util/lbryURI';\nimport { lazyImport } from 'util/lazyImport';\nimport { formatLbryUrlForWeb } from 'util/url';\n\nimport withStreamClaimRender from 'hocs/withStreamClaimRender';\nimport Spinner from 'component/spinner';\nimport I18nMessage from 'component/i18nMessage';\nimport Button from 'component/button';\n\nconst LivestreamScheduledInfo = lazyImport(() =>\n  import('component/livestreamScheduledInfo' /* webpackChunkName: \"livestreamScheduledInfo\" */)\n);\nconst ClaimPreviewTile = lazyImport(() =>\n  import('component/claimPreviewTile' /* webpackChunkName: \"claimPreviewTile\" */)\n);\nconst ClaimPreview = lazyImport(() => import('component/claimPreview' /* webpackChunkName: \"claimPreview\" */));\nconst VideoRender = lazyImport(() => import('component/videoClaimRender' /* webpackChunkName: \"videoClaimRender\" */));\n\ntype Props = {\n  uri: string,\n  latestClaimUrl: ?string,\n  // -- redux --\n  renderMode: string,\n  isLivestreamClaim: ?boolean,\n  showScheduledInfo: ?boolean,\n};\n\nconst EmbedClaimComponent = (props: Props) => {\n  const {\n    uri,\n    latestClaimUrl,\n    // -- redux --\n    renderMode,\n    isLivestreamClaim,\n    showScheduledInfo,\n  } = props;\n\n  const {\n    location: { search },\n  } = useHistory();\n\n  const urlParams = new URLSearchParams(search);\n  const featureParam = urlParams.get('feature');\n\n  const { isChannel, channelName } = parseURI(uri);\n  const isVideo = RENDER_MODES.FLOATING_MODES.includes(renderMode);\n\n  const ClickHereButton = React.useMemo(\n    () => () => <Button button=\"link\" label={__('Click Here')} href={formatLbryUrlForWeb(uri)} />,\n    [uri]\n  );\n\n  if (isChannel) {\n    if (featureParam && latestClaimUrl !== null) {\n      // -- Still loading the latest/livenow claims for the channel\n      return (\n        <div className=\"main--empty\">\n          <Spinner />\n        </div>\n      );\n    }\n\n    return (\n      <React.Suspense\n        fallback={\n          <div className=\"main--empty\">\n            <Spinner text={__('Loading...')} />\n          </div>\n        }\n      >\n        <ClaimPreview uri={uri} />\n\n        {latestClaimUrl === null && (\n          <div className=\"help--notice\" style={{ marginTop: '20px' }}>\n            {__(\"%channelName% isn't live right now, check back later to watch the stream.\", { channelName })}\n          </div>\n        )}\n      </React.Suspense>\n    );\n  }\n\n  if (isVideo) {\n    return (\n      <>\n        <EmbeddedVideoClaim uri={uri} embedded>\n          {isLivestreamClaim && (\n            <>\n              {showScheduledInfo && <LivestreamScheduledInfo uri={uri} />}\n\n              <div\n                className={classnames('help--notice help--notice-embed-livestream', {\n                  'help--notice-short': showScheduledInfo,\n                })}\n              >\n                {showScheduledInfo ? (\n                  <I18nMessage tokens={{ click_here: <ClickHereButton /> }}>\n                    %click_here% if you want to join the chat for this stream.\n                  </I18nMessage>\n                ) : (\n                  <I18nMessage tokens={{ channel_name: channelName, click_here: <ClickHereButton /> }}>\n                    %channel_name% isn't live right now, but the chat is! Check back later to watch the stream, or\n                    %click_here% to start chatting.\n                  </I18nMessage>\n                )}\n              </div>\n            </>\n          )}\n        </EmbeddedVideoClaim>\n      </>\n    );\n  }\n\n  return <EmbeddedClaim uri={uri} />;\n};\n\nconst EmbeddedVideoClaimComponent = ({ uri, streamClaim }: { uri: string, streamClaim: () => void }) => (\n  <VideoRender uri={uri} embedded streamClaim={streamClaim} />\n);\nconst EmbeddedVideoClaim = withStreamClaimRender(EmbeddedVideoClaimComponent);\n\nconst EmbeddedClaimComponent = ({ uri }: { uri: string }) => <ClaimPreviewTile uri={uri} onlyThumb />;\n// -- this allows rendering the appropriate restricted overlays linking to join from the embed --\nconst EmbeddedClaim = withStreamClaimRender(EmbeddedClaimComponent);\n\nexport default EmbedClaimComponent;\n","import { connect } from 'react-redux';\n\nimport { selectIsStreamPlaceholderForUri } from 'redux/selectors/claims';\nimport { makeSelectFileRenderModeForUri } from 'redux/selectors/content';\nimport { selectShowScheduledLiveInfoForUri } from 'redux/selectors/livestream';\n\nimport withResolvedClaimRender from 'hocs/withResolvedClaimRender';\n\nimport EmbedClaimComponent from './view';\n\nconst select = (state, props) => {\n  const { uri } = props;\n\n  return {\n    renderMode: makeSelectFileRenderModeForUri(uri)(state),\n    isLivestreamClaim: selectIsStreamPlaceholderForUri(state, uri),\n    showScheduledInfo: selectShowScheduledLiveInfoForUri(state, uri),\n  };\n};\n\nexport default withResolvedClaimRender(connect(select)(EmbedClaimComponent));\n","// @flow\nimport * as PAGES from 'constants/pages';\nimport React from 'react';\nimport classnames from 'classnames';\nimport { formatLbryChannelName } from 'util/url';\nimport { useHistory } from 'react-router';\nimport { EmbedContext } from 'contexts/embed';\nimport { parseURI } from 'util/lbryURI';\nimport EmbedClaimComponent from './internal/embedClaimComponent';\n\ntype Props = {\n  uri: string,\n  claimId: string,\n  latestClaimId: ?string,\n  canonicalUrl: ?string,\n  channelUri: ?string,\n  channelClaimId: ?string,\n  isLivestreamClaim: boolean,\n  latestClaimUrl: ?string,\n  doFetchLatestClaimForChannel: (uri: string, isEmbed: boolean) => void,\n  doFetchChannelIsLiveForId: (string) => void,\n  doCommentSocketConnect: (string, string, string, ?string) => void,\n  doCommentSocketDisconnect: (string, string) => void,\n  contentUnlocked: boolean,\n};\n\nconst EmbedWrapperPage = (props: Props) => {\n  const {\n    uri,\n    claimId,\n    latestClaimId,\n    canonicalUrl,\n    channelUri,\n    channelClaimId,\n    isLivestreamClaim,\n    latestClaimUrl,\n    doFetchLatestClaimForChannel,\n    doFetchChannelIsLiveForId,\n    doCommentSocketConnect,\n    doCommentSocketDisconnect,\n    contentUnlocked,\n  } = props;\n\n  const fetchedLiveStatus = React.useRef();\n\n  const {\n    location: { search },\n  } = useHistory();\n\n  const { isChannel } = parseURI(uri);\n\n  const [videoEnded, setVideoEnded] = React.useState(false);\n\n  const channelUrl = channelUri && formatLbryChannelName(channelUri);\n  const urlParams = new URLSearchParams(search);\n  const featureParam = urlParams.get('feature');\n  const latestContentPath = featureParam === PAGES.LATEST;\n  const liveContentPath = featureParam === PAGES.LIVE_NOW;\n  const embedLightBackground = urlParams.get('embedBackgroundLight');\n  const socketClaimId = liveContentPath ? latestClaimId : claimId;\n\n  React.useEffect(() => {\n    if (!latestClaimUrl && liveContentPath && channelClaimId) {\n      doFetchChannelIsLiveForId(channelClaimId);\n      fetchedLiveStatus.current = true;\n    }\n  }, [channelClaimId, doFetchChannelIsLiveForId, latestClaimUrl, liveContentPath]);\n\n  React.useEffect(() => {\n    if (!latestClaimUrl && latestContentPath && canonicalUrl) {\n      doFetchLatestClaimForChannel(canonicalUrl, true);\n    }\n  }, [canonicalUrl, doFetchLatestClaimForChannel, latestClaimUrl, latestContentPath]);\n\n  // Establish web socket connection for viewer count.\n  React.useEffect(() => {\n    if (!isLivestreamClaim || !socketClaimId || !channelUrl || !canonicalUrl) {\n      return;\n    }\n\n    const channelName = formatLbryChannelName(channelUrl);\n\n    if (contentUnlocked) {\n      doCommentSocketConnect(canonicalUrl, channelName, socketClaimId, undefined);\n    }\n\n    return () => {\n      if (socketClaimId) {\n        doCommentSocketDisconnect(socketClaimId, channelName);\n      }\n    };\n  }, [\n    canonicalUrl,\n    channelUrl,\n    contentUnlocked,\n    doCommentSocketConnect,\n    doCommentSocketDisconnect,\n    isLivestreamClaim,\n    socketClaimId,\n  ]);\n\n  return (\n    <div\n      className={classnames('embed__wrapper', {\n        'embed__wrapper--light-background': embedLightBackground,\n        'embed__wrapper--channel': isChannel,\n        'embed__wrapper--channel-notice': isChannel && latestClaimUrl === null,\n      })}\n    >\n      <EmbedContext.Provider value={{ setVideoEnded, videoEnded, fetchedLiveStatus: fetchedLiveStatus.current }}>\n        <EmbedClaimComponent uri={uri} latestClaimUrl={latestClaimUrl} />\n      </EmbedContext.Provider>\n    </div>\n  );\n};\n\nexport default EmbedWrapperPage;\n","import { connect } from 'react-redux';\nimport EmbedWrapperPage from './view';\nimport * as PAGES from 'constants/pages';\nimport { selectClaimForUri, selectIsUriResolving, selectLatestClaimForUri } from 'redux/selectors/claims';\nimport { doFetchLatestClaimForChannel } from 'redux/actions/claims';\nimport { buildURI, normalizeURI } from 'util/lbryURI';\nimport { doCommentSocketConnect, doCommentSocketDisconnect } from 'redux/actions/websocket';\nimport { doFetchChannelIsLiveForId } from 'redux/actions/livestream';\nimport { selectLatestLiveClaimForChannel, selectLatestLiveUriForChannel } from 'redux/selectors/livestream';\nimport { isStreamPlaceholderClaim, getChannelFromClaim } from 'util/claim';\nimport { selectNoRestrictionOrUserIsMemberForContentClaimId } from 'redux/selectors/memberships';\n\nconst select = (state, props) => {\n  const { search, hash } = state.router.location;\n  const { match } = props || {};\n\n  const matchedPath = buildMatchWithHash(match, hash);\n  let uri = getUriFromMatch(matchedPath);\n\n  const urlParams = new URLSearchParams(search);\n  const featureParam = urlParams.get('feature');\n\n  const claim = selectClaimForUri(state, uri);\n  const { canonical_url: canonicalUrl } = claim || {};\n  const claimId = claim?.claim_id;\n\n  const channelClaim = getChannelFromClaim(claim);\n  const { claim_id: channelClaimId, canonical_url: channelUri } = channelClaim || {};\n\n  const latestContentClaim =\n    featureParam === PAGES.LIVE_NOW\n      ? selectLatestLiveClaimForChannel(state, channelClaimId)\n      : selectLatestClaimForUri(state, canonicalUrl);\n\n  const latestClaimUrl =\n    featureParam === PAGES.LIVE_NOW\n      ? selectLatestLiveUriForChannel(state, channelClaimId)\n      : latestContentClaim && latestContentClaim.canonical_url;\n  const latestClaimId = latestContentClaim && latestContentClaim.claim_id;\n\n  if (latestClaimUrl) uri = latestClaimUrl;\n\n  return {\n    uri,\n    claimId,\n    latestClaimId,\n    canonicalUrl,\n    channelUri,\n    channelClaimId,\n    latestClaimUrl,\n    isResolvingUri: uri && selectIsUriResolving(state, uri),\n    isLivestreamClaim: featureParam === PAGES.LIVE_NOW || isStreamPlaceholderClaim(claim),\n    contentUnlocked: claim && selectNoRestrictionOrUserIsMemberForContentClaimId(state, claim.claim_id),\n  };\n};\n\nconst perform = {\n  doFetchChannelIsLiveForId,\n  doCommentSocketConnect,\n  doCommentSocketDisconnect,\n  doFetchLatestClaimForChannel,\n};\n\nexport default connect(select, perform)(EmbedWrapperPage);\n\nfunction getUriFromMatch(match) {\n  if (match) {\n    const { claimName, claimId } = match.params;\n\n    // https://{DOMAIN}/claimName/claimId\n    const isOldPermanentUriFormat =\n      !claimName.startsWith('@') && !claimName.includes(':') && !claimName.includes('#') && claimId;\n\n    // https://{DOMAIN}/channelName/claimName/\n    // on match channelName = claimName / claimName = claimId\n    const isCanonicalUriFormat = !isOldPermanentUriFormat;\n\n    if (isOldPermanentUriFormat) {\n      try {\n        return buildURI({ claimName, claimId });\n      } catch (error) {}\n      try {\n        return buildURI({ claimName, claimId });\n      } catch (error) {}\n      // ^-------- why twice?\n    }\n\n    if (isCanonicalUriFormat) {\n      return normalizeURI(claimName + '/' + (claimId || ''));\n    }\n  }\n\n  return '';\n}\n\nfunction buildMatchWithHash(match, hash) {\n  const matchedPath = Object.assign({}, match);\n\n  // if a claim is using the hash canonical format (\"lbry://@chanelName#channelClaimId/streamName#streamClaimId\"\n  // instead of \"lbry://@chanelName:channelClaimId/streamName:streamClaimId\")\n  if (hash && hash.length > 0) {\n    // the hash is on the channel part of the uri\n    if (hash.includes('/')) {\n      const newClaimNameParam = matchedPath.params.claimName;\n      const claimIdPart = hash.substring(0, hash.indexOf('/'));\n\n      if (!newClaimNameParam.includes(claimIdPart)) {\n        matchedPath.params.claimName = newClaimNameParam + claimIdPart;\n        matchedPath.params.claimId = hash.substring(hash.indexOf('/') + 1);\n      }\n    } else {\n      // the hash is on the stream part of the uri, so it looks like\n      // \"lbry://@chanelName:channelClaimId/streamName#streamClaimId\" instead of\n      // \"lbry://@chanelName:channelClaimId/streamName:streamClaimId\"\n      matchedPath.params.claimId = matchedPath.params.claimId + hash;\n    }\n  }\n\n  return matchedPath;\n}\n"],"names":["LivestreamScheduledInfo","lazyImport","ClaimPreviewTile","ClaimPreview","VideoRender","EmbeddedVideoClaim","withStreamClaimRender","_ref","uri","streamClaim","React","embedded","EmbeddedClaim","_ref2","onlyThumb","props","latestClaimUrl","renderMode","isLivestreamClaim","showScheduledInfo","search","useHistory","location","featureParam","URLSearchParams","get","_parseURI","parseURI","isChannel","channelName","isVideo","RENDER_MODES","ClickHereButton","Button","button","label","__","href","formatLbryUrlForWeb","className","Spinner","fallback","text","style","marginTop","classnames","I18nMessage","tokens","click_here","channel_name","withResolvedClaimRender","connect","state","makeSelectFileRenderModeForUri","selectIsStreamPlaceholderForUri","selectShowScheduledLiveInfoForUri","EmbedClaimComponent","claimId","latestClaimId","canonicalUrl","channelUri","channelClaimId","doFetchLatestClaimForChannel","doFetchChannelIsLiveForId","doCommentSocketConnect","doCommentSocketDisconnect","contentUnlocked","fetchedLiveStatus","_React$useState2","_slicedToArray","videoEnded","setVideoEnded","channelUrl","formatLbryChannelName","urlParams","latestContentPath","PAGES","liveContentPath","embedLightBackground","socketClaimId","current","undefined","EmbedContext","value","perform","_state$router$locatio","router","hash","matchedPath","match","Object","assign","length","includes","newClaimNameParam","params","claimName","claimIdPart","substring","indexOf","buildMatchWithHash","_match$params","isOldPermanentUriFormat","startsWith","isCanonicalUriFormat","buildURI","error","normalizeURI","getUriFromMatch","claim","selectClaimForUri","canonical_url","claim_id","_ref3","getChannelFromClaim","latestContentClaim","selectLatestLiveClaimForChannel","selectLatestClaimForUri","selectLatestLiveUriForChannel","isResolvingUri","selectIsUriResolving","isStreamPlaceholderClaim","selectNoRestrictionOrUserIsMemberForContentClaimId","EmbedWrapperPage"],"sourceRoot":""}