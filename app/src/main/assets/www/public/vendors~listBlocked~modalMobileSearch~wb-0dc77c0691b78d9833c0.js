(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~listBlocked~modalMobileSearch~wb"],{

/***/ "../node_modules/@reach/combobox/dist/combobox.esm.js":
/*!************************************************************!*\
  !*** ../node_modules/@reach/combobox/dist/combobox.esm.js ***!
  \************************************************************/
/*! exports provided: Combobox, ComboboxButton, ComboboxInput, ComboboxList, ComboboxOption, ComboboxOptionText, ComboboxPopover, escapeRegexp, useComboboxContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Combobox\", function() { return Combobox; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComboboxButton\", function() { return ComboboxButton; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComboboxInput\", function() { return ComboboxInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComboboxList\", function() { return ComboboxList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComboboxOption\", function() { return ComboboxOption; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComboboxOptionText\", function() { return ComboboxOptionText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComboboxPopover\", function() { return ComboboxPopover; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"escapeRegexp\", function() { return escapeRegexp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useComboboxContext\", function() { return useComboboxContext; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"../node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _reach_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reach/utils */ \"../node_modules/@reach/utils/dist/utils.esm.js\");\n/* harmony import */ var _reach_descendants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @reach/descendants */ \"../node_modules/@reach/descendants/dist/descendants.esm.js\");\n/* harmony import */ var highlight_words_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! highlight-words-core */ \"../node_modules/highlight-words-core/dist/index.js\");\n/* harmony import */ var highlight_words_core__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(highlight_words_core__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _reach_auto_id__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @reach/auto-id */ \"../node_modules/@reach/combobox/node_modules/@reach/auto-id/dist/auto-id.esm.js\");\n/* harmony import */ var _reach_popover__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @reach/popover */ \"../node_modules/@reach/popover/dist/popover.esm.js\");\n\n\n\n\n\n\n\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar _on, _on2, _on3, _on4, _states; // States\n// Nothing going on, waiting for the user to type or use the arrow keys\n\n\nvar IDLE = \"IDLE\"; // The component is suggesting options as the user types\n\nvar SUGGESTING = \"SUGGESTING\"; // The user is using the keyboard to navigate the list, not typing\n\nvar NAVIGATING = \"NAVIGATING\"; // The user is interacting with arbitrary elements inside the popup that\n// are not ComboboxInputs\n\nvar INTERACTING = \"INTERACTING\"; ////////////////////////////////////////////////////////////////////////////////\n// Events\n// User cleared the value w/ backspace, but input still has focus\n\nvar CLEAR = \"CLEAR\"; // User is typing\n\nvar CHANGE = \"CHANGE\"; // Initial input value change handler for syncing user state with state machine\n// Prevents initial change from sending the user to the NAVIGATING state\n// https://github.com/reach/reach-ui/issues/464\n\nvar INITIAL_CHANGE = \"INITIAL_CHANGE\"; // User is navigating w/ the keyboard\n\nvar NAVIGATE = \"NAVIGATE\"; // User can be navigating with keyboard and then click instead, we want the\n// value from the click, not the current nav item\n\nvar SELECT_WITH_KEYBOARD = \"SELECT_WITH_KEYBOARD\";\nvar SELECT_WITH_CLICK = \"SELECT_WITH_CLICK\"; // Pretty self-explanatory, user can hit escape or blur to close the popover\n\nvar ESCAPE = \"ESCAPE\";\nvar BLUR = \"BLUR\"; // The user left the input to interact with arbitrary elements inside the popup\n\nvar INTERACT = \"INTERACT\";\nvar FOCUS = \"FOCUS\";\nvar OPEN_WITH_BUTTON = \"OPEN_WITH_BUTTON\";\nvar CLOSE_WITH_BUTTON = \"CLOSE_WITH_BUTTON\"; ////////////////////////////////////////////////////////////////////////////////\n\nvar stateChart = {\n  initial: IDLE,\n  states: (_states = {}, _states[IDLE] = {\n    on: (_on = {}, _on[BLUR] = IDLE, _on[CLEAR] = IDLE, _on[CHANGE] = SUGGESTING, _on[INITIAL_CHANGE] = IDLE, _on[FOCUS] = SUGGESTING, _on[NAVIGATE] = NAVIGATING, _on[OPEN_WITH_BUTTON] = SUGGESTING, _on)\n  }, _states[SUGGESTING] = {\n    on: (_on2 = {}, _on2[CHANGE] = SUGGESTING, _on2[FOCUS] = SUGGESTING, _on2[NAVIGATE] = NAVIGATING, _on2[CLEAR] = IDLE, _on2[ESCAPE] = IDLE, _on2[BLUR] = IDLE, _on2[SELECT_WITH_CLICK] = IDLE, _on2[INTERACT] = INTERACTING, _on2[CLOSE_WITH_BUTTON] = IDLE, _on2)\n  }, _states[NAVIGATING] = {\n    on: (_on3 = {}, _on3[CHANGE] = SUGGESTING, _on3[FOCUS] = SUGGESTING, _on3[CLEAR] = IDLE, _on3[BLUR] = IDLE, _on3[ESCAPE] = IDLE, _on3[NAVIGATE] = NAVIGATING, _on3[SELECT_WITH_CLICK] = IDLE, _on3[SELECT_WITH_KEYBOARD] = IDLE, _on3[CLOSE_WITH_BUTTON] = IDLE, _on3[INTERACT] = INTERACTING, _on3)\n  }, _states[INTERACTING] = {\n    on: (_on4 = {}, _on4[CLEAR] = IDLE, _on4[CHANGE] = SUGGESTING, _on4[FOCUS] = SUGGESTING, _on4[BLUR] = IDLE, _on4[ESCAPE] = IDLE, _on4[NAVIGATE] = NAVIGATING, _on4[CLOSE_WITH_BUTTON] = IDLE, _on4[SELECT_WITH_CLICK] = IDLE, _on4)\n  }, _states)\n};\n\nvar reducer = function reducer(data, event) {\n  var nextState = _extends({}, data, {\n    lastEventType: event.type\n  });\n\n  switch (event.type) {\n    case CHANGE:\n    case INITIAL_CHANGE:\n      return _extends({}, nextState, {\n        navigationValue: null,\n        value: event.value\n      });\n\n    case NAVIGATE:\n    case OPEN_WITH_BUTTON:\n      return _extends({}, nextState, {\n        navigationValue: findNavigationValue(nextState, event)\n      });\n\n    case CLEAR:\n      return _extends({}, nextState, {\n        value: \"\",\n        navigationValue: null\n      });\n\n    case BLUR:\n    case ESCAPE:\n      return _extends({}, nextState, {\n        navigationValue: null\n      });\n\n    case SELECT_WITH_CLICK:\n      return _extends({}, nextState, {\n        value: event.value,\n        navigationValue: null\n      });\n\n    case SELECT_WITH_KEYBOARD:\n      return _extends({}, nextState, {\n        value: data.navigationValue,\n        navigationValue: null\n      });\n\n    case CLOSE_WITH_BUTTON:\n      return _extends({}, nextState, {\n        navigationValue: null\n      });\n\n    case INTERACT:\n      return nextState;\n\n    case FOCUS:\n      return _extends({}, nextState, {\n        navigationValue: findNavigationValue(nextState, event)\n      });\n\n    default:\n      return nextState;\n  }\n};\n\nfunction popoverIsExpanded(state) {\n  return [SUGGESTING, NAVIGATING, INTERACTING].includes(state);\n}\n/**\r\n * When we open a list, set the navigation value to the value in the input, if\r\n * it's in the list, then it'll automatically be highlighted.\r\n *\r\n * @param stateData\r\n * @param event\r\n */\n\n\nfunction findNavigationValue(stateData, event) {\n  // @ts-ignore\n  if (event.value) {\n    // @ts-ignore\n    return event.value; // @ts-ignore\n  } else if (event.persistSelection) {\n    return stateData.value;\n  } else {\n    return null;\n  }\n}\n\nvar ComboboxDescendantContext = /*#__PURE__*/Object(_reach_descendants__WEBPACK_IMPORTED_MODULE_3__[\"createDescendantContext\"])(\"ComboboxDescendantContext\");\nvar ComboboxContext = /*#__PURE__*/Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"createNamedContext\"])(\"ComboboxContext\", {}); // Allows us to put the option's value on context so that ComboboxOptionText\n// can work it's highlight text magic no matter what else is rendered around\n// it.\n\nvar OptionContext = /*#__PURE__*/Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"createNamedContext\"])(\"OptionContext\", {}); ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * Combobox\r\n *\r\n * @see Docs https://reach.tech/combobox#combobox\r\n */\n\nvar Combobox = /*#__PURE__*/Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"forwardRefWithAs\"])(function Combobox(_ref, forwardedRef) {\n  var onSelect = _ref.onSelect,\n      _ref$openOnFocus = _ref.openOnFocus,\n      openOnFocus = _ref$openOnFocus === void 0 ? false : _ref$openOnFocus,\n      children = _ref.children,\n      _ref$as = _ref.as,\n      Comp = _ref$as === void 0 ? \"div\" : _ref$as,\n      ariaLabel = _ref[\"aria-label\"],\n      ariaLabelledby = _ref[\"aria-labelledby\"],\n      props = _objectWithoutPropertiesLoose(_ref, [\"onSelect\", \"openOnFocus\", \"children\", \"as\", \"aria-label\", \"aria-labelledby\"]);\n\n  var _useDescendantsInit = Object(_reach_descendants__WEBPACK_IMPORTED_MODULE_3__[\"useDescendantsInit\"])(),\n      options = _useDescendantsInit[0],\n      setOptions = _useDescendantsInit[1]; // Need this to focus it\n\n\n  var inputRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])();\n  var popoverRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])();\n  var buttonRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(); // When <ComboboxInput autocomplete={false} /> we don't want cycle back to\n  // the user's value while navigating (because it's always the user's value),\n  // but we need to know this in useKeyDown which is far away from the prop\n  // here, so we do something sneaky and write it to this ref on context so we\n  // can use it anywhere else üòõ. Another new trick for me and I'm excited\n  // about this one too!\n\n  var autocompletePropRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])();\n  var persistSelectionRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])();\n  var defaultData = {\n    // The value the user has typed. We derive this also when the developer is\n    // controlling the value of ComboboxInput.\n    value: \"\",\n    // the value the user has navigated to with the keyboard\n    navigationValue: null\n  };\n\n  var _useReducerMachine = useReducerMachine(stateChart, reducer, defaultData),\n      state = _useReducerMachine[0],\n      data = _useReducerMachine[1],\n      transition = _useReducerMachine[2];\n\n  useFocusManagement(data.lastEventType, inputRef);\n  var id = Object(_reach_auto_id__WEBPACK_IMPORTED_MODULE_5__[\"useId\"])(props.id);\n  var listboxId = id ? Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"makeId\"])(\"listbox\", id) : \"listbox\";\n  var context = {\n    ariaLabel: ariaLabel,\n    ariaLabelledby: ariaLabelledby,\n    autocompletePropRef: autocompletePropRef,\n    buttonRef: buttonRef,\n    comboboxId: id,\n    data: data,\n    inputRef: inputRef,\n    isExpanded: popoverIsExpanded(state),\n    listboxId: listboxId,\n    onSelect: onSelect || _reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"noop\"],\n    openOnFocus: openOnFocus,\n    persistSelectionRef: persistSelectionRef,\n    popoverRef: popoverRef,\n    state: state,\n    transition: transition\n  };\n  Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"useCheckStyles\"])(\"combobox\");\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_reach_descendants__WEBPACK_IMPORTED_MODULE_3__[\"DescendantProvider\"], {\n    context: ComboboxDescendantContext,\n    items: options,\n    set: setOptions\n  }, Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(ComboboxContext.Provider, {\n    value: context\n  }, Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(Comp, Object.assign({}, props, {\n    \"data-reach-combobox\": \"\",\n    ref: forwardedRef\n  }), Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"isFunction\"])(children) ? children({\n    id: id,\n    isExpanded: popoverIsExpanded(state)\n  }) : children)));\n});\n\nif (true) {\n  Combobox.displayName = \"Combobox\";\n  Combobox.propTypes = {\n    as: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.any,\n    onSelect: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n    openOnFocus: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * ComboboxInput\r\n *\r\n * Wraps an `<input/>` with a couple extra props that work with the combobox.\r\n *\r\n * @see Docs https://reach.tech/combobox#comboboxinput\r\n */\n\n\nvar ComboboxInput = /*#__PURE__*/Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"forwardRefWithAs\"])(function ComboboxInput(_ref2, forwardedRef) {\n  var _ref2$as = _ref2.as,\n      Comp = _ref2$as === void 0 ? \"input\" : _ref2$as,\n      _ref2$selectOnClick = _ref2.selectOnClick,\n      selectOnClick = _ref2$selectOnClick === void 0 ? false : _ref2$selectOnClick,\n      _ref2$autocomplete = _ref2.autocomplete,\n      autocomplete = _ref2$autocomplete === void 0 ? true : _ref2$autocomplete,\n      onClick = _ref2.onClick,\n      onChange = _ref2.onChange,\n      onKeyDown = _ref2.onKeyDown,\n      onBlur = _ref2.onBlur,\n      onFocus = _ref2.onFocus,\n      controlledValue = _ref2.value,\n      props = _objectWithoutPropertiesLoose(_ref2, [\"as\", \"selectOnClick\", \"autocomplete\", \"onClick\", \"onChange\", \"onKeyDown\", \"onBlur\", \"onFocus\", \"value\"]); // https://github.com/reach/reach-ui/issues/464\n\n\n  var _React$useRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(controlledValue),\n      initialControlledValue = _React$useRef.current;\n\n  var controlledValueChangedRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\n  Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"useUpdateEffect\"])(function () {\n    controlledValueChangedRef.current = true;\n  }, [controlledValue]);\n\n  var _React$useContext = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(ComboboxContext),\n      _React$useContext$dat = _React$useContext.data,\n      navigationValue = _React$useContext$dat.navigationValue,\n      value = _React$useContext$dat.value,\n      lastEventType = _React$useContext$dat.lastEventType,\n      inputRef = _React$useContext.inputRef,\n      state = _React$useContext.state,\n      transition = _React$useContext.transition,\n      listboxId = _React$useContext.listboxId,\n      autocompletePropRef = _React$useContext.autocompletePropRef,\n      openOnFocus = _React$useContext.openOnFocus,\n      isExpanded = _React$useContext.isExpanded,\n      ariaLabel = _React$useContext.ariaLabel,\n      ariaLabelledby = _React$useContext.ariaLabelledby;\n\n  var ref = Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"useForkedRef\"])(inputRef, forwardedRef); // Because we close the List on blur, we need to track if the blur is\n  // caused by clicking inside the list, and if so, don't close the List.\n\n  var selectOnClickRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\n  var handleKeyDown = useKeyDown();\n  var handleBlur = useBlur();\n  var isControlled = controlledValue != null; // Layout effect should be SSR-safe here because we don't actually do\n  // anything with this ref that involves rendering until after we've\n  // let the client hydrate in nested components.\n\n  Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"useIsomorphicLayoutEffect\"])(function () {\n    autocompletePropRef.current = autocomplete;\n  }, [autocomplete, autocompletePropRef]);\n  var handleValueChange = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(function (value) {\n    if (value.trim() === \"\") {\n      transition(CLEAR);\n    } else if (value === initialControlledValue && !controlledValueChangedRef.current) {\n      transition(INITIAL_CHANGE, {\n        value: value\n      });\n    } else {\n      transition(CHANGE, {\n        value: value\n      });\n    }\n  }, [initialControlledValue, transition]);\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n    // If they are controlling the value we still need to do our transitions,\n    // so  we have this derived state to emulate onChange of the input as we\n    // receive new `value`s ...[*]\n    if (isControlled && controlledValue !== value && ( // https://github.com/reach/reach-ui/issues/481\n    controlledValue.trim() === \"\" ? (value || \"\").trim() !== \"\" : true)) {\n      handleValueChange(controlledValue);\n    }\n  }, [controlledValue, handleValueChange, isControlled, value]); // [*]... and when controlled, we don't trigger handleValueChange as the\n  // user types, instead the developer controls it with the normal input\n  // onChange prop\n\n  function handleChange(event) {\n    var value = event.target.value;\n\n    if (!isControlled) {\n      handleValueChange(value);\n    }\n  }\n\n  function handleFocus() {\n    if (selectOnClick) {\n      selectOnClickRef.current = true;\n    } // If we select an option with click, useFocusManagement will focus the\n    // input, in those cases we don't want to cause the menu to open back up,\n    // so we guard behind these states.\n\n\n    if (openOnFocus && lastEventType !== SELECT_WITH_CLICK) {\n      transition(FOCUS);\n    }\n  }\n\n  function handleClick() {\n    if (selectOnClickRef.current) {\n      selectOnClickRef.current = false;\n      inputRef.current.select();\n    }\n  }\n\n  var inputValue = autocomplete && (state === NAVIGATING || state === INTERACTING) ? // When idle, we don't have a navigationValue on ArrowUp/Down\n  navigationValue || controlledValue || value : controlledValue || value;\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(Comp, Object.assign({\n    \"aria-activedescendant\": navigationValue ? String(makeHash(navigationValue)) : undefined,\n    \"aria-autocomplete\": \"both\",\n    \"aria-controls\": listboxId,\n    \"aria-expanded\": isExpanded,\n    \"aria-haspopup\": \"listbox\",\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledby,\n    role: \"combobox\"\n  }, props, {\n    \"data-reach-combobox-input\": \"\",\n    ref: ref,\n    onBlur: Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"wrapEvent\"])(onBlur, handleBlur),\n    onChange: Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"wrapEvent\"])(onChange, handleChange),\n    onClick: Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"wrapEvent\"])(onClick, handleClick),\n    onFocus: Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"wrapEvent\"])(onFocus, handleFocus),\n    onKeyDown: Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"wrapEvent\"])(onKeyDown, handleKeyDown),\n    value: inputValue || \"\"\n  }));\n});\n\nif (true) {\n  ComboboxInput.displayName = \"ComboboxInput\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * ComboboxPopover\r\n *\r\n * Contains the popup that renders the list. Because some UI needs to render\r\n * more than the list in the popup, you need to render one of these around the\r\n * list. For example, maybe you want to render the number of results suggested.\r\n *\r\n * @see Docs https://reach.tech/combobox#comboboxpopover\r\n */\n\n\nvar ComboboxPopover = /*#__PURE__*/Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"forwardRefWithAs\"])(function ComboboxPopover(_ref3, forwardedRef) {\n  var _ref3$as = _ref3.as,\n      Comp = _ref3$as === void 0 ? \"div\" : _ref3$as,\n      children = _ref3.children,\n      _ref3$portal = _ref3.portal,\n      portal = _ref3$portal === void 0 ? true : _ref3$portal,\n      onKeyDown = _ref3.onKeyDown,\n      onBlur = _ref3.onBlur,\n      _ref3$position = _ref3.position,\n      position = _ref3$position === void 0 ? _reach_popover__WEBPACK_IMPORTED_MODULE_6__[\"positionMatchWidth\"] : _ref3$position,\n      props = _objectWithoutPropertiesLoose(_ref3, [\"as\", \"children\", \"portal\", \"onKeyDown\", \"onBlur\", \"position\"]);\n\n  var _React$useContext2 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(ComboboxContext),\n      popoverRef = _React$useContext2.popoverRef,\n      inputRef = _React$useContext2.inputRef,\n      isExpanded = _React$useContext2.isExpanded;\n\n  var ref = Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"useForkedRef\"])(popoverRef, forwardedRef);\n  var handleKeyDown = useKeyDown();\n  var handleBlur = useBlur();\n  var sharedProps = {\n    \"data-reach-combobox-popover\": \"\",\n    onKeyDown: Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"wrapEvent\"])(onKeyDown, handleKeyDown),\n    onBlur: Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"wrapEvent\"])(onBlur, handleBlur),\n    // Instead of conditionally rendering the popover we use the `hidden` prop\n    // because we don't want to unmount on close (from escape or onSelect).\n    // However, the developer can conditionally render the ComboboxPopover if\n    // they do want to cause mount/unmount based on the app's own data (like\n    // results.length or whatever).\n    hidden: !isExpanded,\n    tabIndex: -1,\n    children: children\n  };\n  return portal ? Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_reach_popover__WEBPACK_IMPORTED_MODULE_6__[\"Popover\"], Object.assign({\n    as: Comp\n  }, props, {\n    ref: ref,\n    position: position,\n    targetRef: inputRef\n  }, sharedProps)) : Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(Comp, Object.assign({\n    ref: ref\n  }, props, sharedProps));\n});\n\nif (true) {\n  ComboboxPopover.displayName = \"ComboboxPopover\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * ComboboxList\r\n *\r\n * Contains the `ComboboxOption` elements and sets up the proper aria attributes\r\n * for the list.\r\n *\r\n * @see Docs https://reach.tech/combobox#comboboxlist\r\n */\n\n\nvar ComboboxList = /*#__PURE__*/Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"forwardRefWithAs\"])(function ComboboxList(_ref4, forwardedRef) {\n  var _ref4$persistSelectio = _ref4.persistSelection,\n      persistSelection = _ref4$persistSelectio === void 0 ? false : _ref4$persistSelectio,\n      _ref4$as = _ref4.as,\n      Comp = _ref4$as === void 0 ? \"ul\" : _ref4$as,\n      props = _objectWithoutPropertiesLoose(_ref4, [\"persistSelection\", \"as\"]);\n\n  var _React$useContext3 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(ComboboxContext),\n      persistSelectionRef = _React$useContext3.persistSelectionRef,\n      listboxId = _React$useContext3.listboxId;\n\n  if (persistSelection) {\n    persistSelectionRef.current = true;\n  }\n\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(Comp, Object.assign({\n    role: \"listbox\"\n  }, props, {\n    ref: forwardedRef,\n    \"data-reach-combobox-list\": \"\",\n    id: listboxId\n  }));\n});\n\nif (true) {\n  ComboboxList.displayName = \"ComboboxList\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * ComboboxOption\r\n *\r\n * An option that is suggested to the user as they interact with the combobox.\r\n *\r\n * @see Docs https://reach.tech/combobox#comboboxoption\r\n */\n\n\nvar ComboboxOption = /*#__PURE__*/Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"forwardRefWithAs\"])(function ComboboxOption(_ref5, forwardedRef) {\n  var _ref5$as = _ref5.as,\n      Comp = _ref5$as === void 0 ? \"li\" : _ref5$as,\n      children = _ref5.children,\n      value = _ref5.value,\n      onClick = _ref5.onClick,\n      props = _objectWithoutPropertiesLoose(_ref5, [\"as\", \"children\", \"value\", \"onClick\"]);\n\n  var _React$useContext4 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(ComboboxContext),\n      onSelect = _React$useContext4.onSelect,\n      navigationValue = _React$useContext4.data.navigationValue,\n      transition = _React$useContext4.transition;\n\n  var ownRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(null);\n  var ref = Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"useForkedRef\"])(forwardedRef, ownRef);\n  var index = Object(_reach_descendants__WEBPACK_IMPORTED_MODULE_3__[\"useDescendant\"])({\n    element: ownRef.current,\n    value: value\n  }, ComboboxDescendantContext);\n  var isActive = navigationValue === value;\n\n  var handleClick = function handleClick() {\n    onSelect && onSelect(value);\n    transition(SELECT_WITH_CLICK, {\n      value: value\n    });\n  };\n\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(OptionContext.Provider, {\n    value: {\n      value: value,\n      index: index\n    }\n  }, Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(Comp, Object.assign({\n    \"aria-selected\": isActive,\n    role: \"option\"\n  }, props, {\n    \"data-reach-combobox-option\": \"\",\n    ref: ref,\n    id: String(makeHash(value)),\n    \"data-highlighted\": isActive ? \"\" : undefined,\n    // Without this the menu will close from `onBlur`, but with it the\n    // element can be `document.activeElement` and then our focus checks in\n    // onBlur will work as intended\n    tabIndex: -1,\n    onClick: Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"wrapEvent\"])(onClick, handleClick),\n    children: children || Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(ComboboxOptionText, null)\n  })));\n});\n\nif (true) {\n  ComboboxOption.displayName = \"ComboboxOption\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * ComboboxOptionText\r\n *\r\n * Renders the value of a `ComboboxOption` as text but with spans wrapping the\r\n * matching and non-matching segments of text.\r\n *\r\n * We don't forwardRef or spread props because we render multiple spans or null,\r\n * should be fine ü§ô\r\n *\r\n * @example\r\n *   <ComboboxOption value=\"Seattle\">\r\n *     üåß <ComboboxOptionText />\r\n *   </ComboboxOption>\r\n *\r\n * @see Docs https://reach.tech/combobox#comboboxoptiontext\r\n */\n\n\nfunction ComboboxOptionText() {\n  var _React$useContext5 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(OptionContext),\n      value = _React$useContext5.value;\n\n  var _React$useContext6 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(ComboboxContext),\n      contextValue = _React$useContext6.data.value;\n\n  var results = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useMemo\"])(function () {\n    return Object(highlight_words_core__WEBPACK_IMPORTED_MODULE_4__[\"findAll\"])({\n      searchWords: escapeRegexp(contextValue || \"\").split(/\\s+/),\n      textToHighlight: value\n    });\n  }, [contextValue, value]);\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(react__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], null, results.length ? results.map(function (result, index) {\n    var str = value.slice(result.start, result.end);\n    return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"span\", {\n      key: index,\n      \"data-user-value\": result.highlight ? true : undefined,\n      \"data-suggested-value\": result.highlight ? undefined : true\n    }, str);\n  }) : value);\n}\n\nif (true) {\n  ComboboxOptionText.displayName = \"ComboboxOptionText\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * ComboboxButton\r\n */\n\n\nvar ComboboxButton = /*#__PURE__*/Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"forwardRefWithAs\"])(function ComboboxButton(_ref6, forwardedRef) {\n  var _ref6$as = _ref6.as,\n      Comp = _ref6$as === void 0 ? \"button\" : _ref6$as,\n      onClick = _ref6.onClick,\n      onKeyDown = _ref6.onKeyDown,\n      props = _objectWithoutPropertiesLoose(_ref6, [\"as\", \"onClick\", \"onKeyDown\"]);\n\n  var _React$useContext7 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(ComboboxContext),\n      transition = _React$useContext7.transition,\n      state = _React$useContext7.state,\n      buttonRef = _React$useContext7.buttonRef,\n      listboxId = _React$useContext7.listboxId,\n      isExpanded = _React$useContext7.isExpanded;\n\n  var ref = Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"useForkedRef\"])(buttonRef, forwardedRef);\n  var handleKeyDown = useKeyDown();\n\n  var handleClick = function handleClick() {\n    if (state === IDLE) {\n      transition(OPEN_WITH_BUTTON);\n    } else {\n      transition(CLOSE_WITH_BUTTON);\n    }\n  };\n\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(Comp, Object.assign({\n    \"aria-controls\": listboxId,\n    \"aria-haspopup\": \"listbox\",\n    \"aria-expanded\": isExpanded\n  }, props, {\n    \"data-reach-combobox-button\": \"\",\n    ref: ref,\n    onClick: Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"wrapEvent\"])(onClick, handleClick),\n    onKeyDown: Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"wrapEvent\"])(onKeyDown, handleKeyDown)\n  }));\n});\n\nif (true) {\n  ComboboxButton.displayName = \"ComboboxButton\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * Move focus back to the input if we start navigating w/ the\r\n * keyboard after focus has moved to any focusable content in\r\n * the popup.\r\n *\r\n * @param lastEventType\r\n * @param inputRef\r\n */\n\n\nfunction useFocusManagement(lastEventType, inputRef) {\n  // useLayoutEffect so that the cursor goes to the end of the input instead\n  // of awkwardly at the beginning, unclear to me why ü§∑‚Äç‚ôÇÔ∏è\n  //\n  // Should be safe to use here since we're just focusing an input.\n  Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"useIsomorphicLayoutEffect\"])(function () {\n    if (lastEventType === NAVIGATE || lastEventType === ESCAPE || lastEventType === SELECT_WITH_CLICK || lastEventType === OPEN_WITH_BUTTON) {\n      inputRef.current.focus();\n    }\n  }, [inputRef, lastEventType]);\n}\n/**\r\n * We want the same events when the input or the popup have focus (HOW COOL ARE\r\n * HOOKS BTW?) This is probably the hairiest piece but it's not bad.\r\n */\n\n\nfunction useKeyDown() {\n  var _React$useContext8 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(ComboboxContext),\n      navigationValue = _React$useContext8.data.navigationValue,\n      onSelect = _React$useContext8.onSelect,\n      state = _React$useContext8.state,\n      transition = _React$useContext8.transition,\n      autocompletePropRef = _React$useContext8.autocompletePropRef,\n      persistSelectionRef = _React$useContext8.persistSelectionRef;\n\n  var options = Object(_reach_descendants__WEBPACK_IMPORTED_MODULE_3__[\"useDescendants\"])(ComboboxDescendantContext);\n  return function handleKeyDown(event) {\n    var index = options.findIndex(function (_ref7) {\n      var value = _ref7.value;\n      return value === navigationValue;\n    });\n\n    function getNextOption() {\n      var atBottom = index === options.length - 1;\n\n      if (atBottom) {\n        if (autocompletePropRef.current) {\n          // Go back to the value the user has typed because we are\n          // autocompleting and they need to be able to get back to what\n          // they had typed w/o having to backspace out.\n          return null;\n        } else {\n          // cycle through\n          return getFirstOption();\n        }\n      } else {\n        // Go to the next item in the list\n        return options[(index + 1) % options.length];\n      }\n    }\n\n    function getPreviousOption() {\n      var atTop = index === 0;\n\n      if (atTop) {\n        if (autocompletePropRef.current) {\n          // Go back to the value the user has typed because we are\n          // autocompleting and they need to be able to get back to what\n          // they had typed w/o having to backspace out.\n          return null;\n        } else {\n          // cycle through\n          return getLastOption();\n        }\n      } else if (index === -1) {\n        // displaying the user's value, so go select the last one\n        return getLastOption();\n      } else {\n        // normal case, select previous\n        return options[(index - 1 + options.length) % options.length];\n      }\n    }\n\n    function getFirstOption() {\n      return options[0];\n    }\n\n    function getLastOption() {\n      return options[options.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        // Don't scroll the page\n        event.preventDefault();\n\n        if (!options || !options.length) {\n          return;\n        }\n\n        if (state === IDLE) {\n          // Opening a closed list\n          transition(NAVIGATE, {\n            persistSelection: persistSelectionRef.current\n          });\n        } else {\n          var next = getNextOption();\n          transition(NAVIGATE, {\n            value: next ? next.value : null\n          });\n        }\n\n        break;\n      // A lot of duplicate code with ArrowDown up next, I'm already over it.\n\n      case \"ArrowUp\":\n        // Don't scroll the page\n        event.preventDefault();\n\n        if (!options || options.length === 0) {\n          return;\n        }\n\n        if (state === IDLE) {\n          transition(NAVIGATE);\n        } else {\n          var prev = getPreviousOption();\n          transition(NAVIGATE, {\n            value: prev ? prev.value : null\n          });\n        }\n\n        break;\n\n      case \"Home\":\n      case \"PageUp\":\n        // Don't scroll the page\n        event.preventDefault();\n\n        if (!options || options.length === 0) {\n          return;\n        }\n\n        if (state === IDLE) {\n          transition(NAVIGATE);\n        } else {\n          transition(NAVIGATE, {\n            value: getFirstOption().value\n          });\n        }\n\n        break;\n\n      case \"End\":\n      case \"PageDown\":\n        // Don't scroll the page\n        event.preventDefault();\n\n        if (!options || options.length === 0) {\n          return;\n        }\n\n        if (state === IDLE) {\n          transition(NAVIGATE);\n        } else {\n          transition(NAVIGATE, {\n            value: getLastOption().value\n          });\n        }\n\n        break;\n\n      case \"Escape\":\n        if (state !== IDLE) {\n          transition(ESCAPE);\n        }\n\n        break;\n\n      case \"Enter\":\n        if (state === NAVIGATING && navigationValue !== null) {\n          // don't want to submit forms\n          event.preventDefault();\n          onSelect && onSelect(navigationValue);\n          transition(SELECT_WITH_KEYBOARD);\n        }\n\n        break;\n    }\n  };\n}\n\nfunction useBlur() {\n  var _React$useContext9 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(ComboboxContext),\n      state = _React$useContext9.state,\n      transition = _React$useContext9.transition,\n      popoverRef = _React$useContext9.popoverRef,\n      inputRef = _React$useContext9.inputRef,\n      buttonRef = _React$useContext9.buttonRef;\n\n  var rafIds = Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"useLazyRef\"])(function () {\n    return new Set();\n  });\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n    return function () {\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      rafIds.current.forEach(function (id) {\n        return cancelAnimationFrame(id);\n      });\n    };\n  }, [rafIds]);\n  return function handleBlur() {\n    var ownerDocument = Object(_reach_utils__WEBPACK_IMPORTED_MODULE_2__[\"getOwnerDocument\"])(popoverRef.current);\n\n    if (!ownerDocument) {\n      return;\n    }\n\n    var rafId = requestAnimationFrame(function () {\n      // we on want to close only if focus propss outside the combobox\n      if (ownerDocument.activeElement !== inputRef.current && ownerDocument.activeElement !== buttonRef.current && popoverRef.current) {\n        if (popoverRef.current.contains(ownerDocument.activeElement)) {\n          // focus landed inside the combobox, keep it open\n          if (state !== INTERACTING) {\n            transition(INTERACT);\n          }\n        } else {\n          // focus landed outside the combobox, close it.\n          transition(BLUR);\n        }\n      }\n    });\n    rafIds.current.add(rafId);\n  };\n}\n/**\r\n * This manages transitions between states with a built in reducer to manage\r\n * the data that goes with those transitions.\r\n *\r\n * @param chart\r\n * @param reducer\r\n * @param initialData\r\n */\n\n\nfunction useReducerMachine(chart, reducer, initialData) {\n  var _React$useState = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(chart.initial),\n      state = _React$useState[0],\n      setState = _React$useState[1];\n\n  var _React$useReducer = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useReducer\"])(reducer, initialData),\n      data = _React$useReducer[0],\n      dispatch = _React$useReducer[1];\n\n  var transition = function transition(event, payload) {\n    if (payload === void 0) {\n      payload = {};\n    }\n\n    var currentState = chart.states[state];\n    var nextState = currentState && currentState.on[event];\n\n    if (nextState) {\n      dispatch(_extends({\n        type: event,\n        state: state,\n        nextState: state\n      }, payload));\n      setState(nextState);\n      return;\n    }\n  };\n\n  return [state, data, transition];\n}\n/**\r\n * We don't want to track the active descendant with indexes because nothing is\r\n * more annoying in a combobox than having it change values RIGHT AS YOU HIT\r\n * ENTER. That only happens if you use the index as your data, rather than\r\n * *your data as your data*. We use this to generate a unique ID based on the\r\n * value of each item.  This function is short, sweet, and good enough‚Ñ¢ (I also\r\n * don't know how it works, tbqh)\r\n *\r\n * @see https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript\r\n * @param str\r\n */\n\n\nvar makeHash = function makeHash(str) {\n  var hash = 0;\n\n  if (str.length === 0) {\n    return hash;\n  }\n\n  for (var i = 0; i < str.length; i++) {\n    var _char = str.charCodeAt(i);\n\n    hash = (hash << 5) - hash + _char;\n    hash = hash & hash;\n  }\n\n  return hash;\n};\n/**\r\n * Escape regexp special characters in `str`\r\n *\r\n * @see https://github.com/component/escape-regexp/blob/5ce923c1510c9802b3da972c90b6861dd2829b6b/index.js\r\n * @param str\r\n */\n\n\nfunction escapeRegexp(str) {\n  return String(str).replace(/([.*+?=^!:${}()|[\\]/\\\\])/g, \"\\\\$1\");\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * A hook that exposes data for a given `Combobox` component to its descendants.\r\n *\r\n * @see Docs https://reach.tech/combobox#usecomboboxcontext\r\n */\n\n\nfunction useComboboxContext() {\n  var _React$useContext10 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(ComboboxContext),\n      isExpanded = _React$useContext10.isExpanded,\n      comboboxId = _React$useContext10.comboboxId;\n\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useMemo\"])(function () {\n    return {\n      id: comboboxId,\n      isExpanded: isExpanded\n    };\n  }, [comboboxId, isExpanded]);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0ByZWFjaC9jb21ib2JveC9kaXN0L2NvbWJvYm94LmVzbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zcmMvaW5kZXgudHN4P2RlYjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBXZWxjb21lIHRvIEByZWFjaC9jb21ib2JveCFcbiAqXG4gKiBBY2Nlc3NpYmxlIGNvbWJvYm94IChhdXRvY29tcGxldGUgb3IgYXV0b3N1Z2dlc3QpIGNvbXBvbmVudCBmb3IgUmVhY3QuXG4gKlxuICogQSBjb21ib2JveCBpcyB0aGUgY29tYmluYXRpb24gb2YgYW4gYDxpbnB1dCB0eXBlPVwidGV4dFwiLz5gIGFuZCBhIGxpc3QuIFRoZVxuICogbGlzdCBpcyBkZXNpZ25lZCB0byBoZWxwIHRoZSB1c2VyIGFycml2ZSBhdCBhIHZhbHVlLCBidXQgdGhlIHZhbHVlIGRvZXMgbm90XG4gKiBuZWNlc3NhcmlseSBoYXZlIHRvIGNvbWUgZnJvbSB0aGF0IGxpc3QuIERvbid0IHRoaW5rIG9mIGl0IGxpa2UgYVxuICogYDxzZWxlY3QvPmAsIGJ1dCBtb3JlIG9mIGFuIGA8aW5wdXQgdHlwZT1cInRleHRcIi8+YCB3aXRoIHNvbWUgc3VnZ2VzdGlvbnMuIFlvdVxuICogY2FuLCBob3dldmVyLCB2YWxpZGF0ZSB0aGF0IHRoZSB2YWx1ZSBjb21lcyBmcm9tIHRoZSBsaXN0LCB0aGF0J3MgdXAgdG8geW91clxuICogYXBwLlxuICpcbiAqID8/PzogbmF2aWdhdGUgdy8gYXJyb3dzLCB0aGVuIGhpdCBiYWNrc3BhY2U6IHNob3VsZCBpdCBkZWxldGUgdGhlXG4gKiAgICAgIGF1dG9jb21wbGV0ZWQgdGV4dCBvciB0aGUgb2xkIHZhbHVlIHRoZSB1c2VyIGhhZCB0eXBlZD8hXG4gKlxuICogQHNlZSBEb2NzICAgICBodHRwczovL3JlYWNoLnRlY2gvY29tYm9ib3hcbiAqIEBzZWUgU291cmNlICAgaHR0cHM6Ly9naXRodWIuY29tL3JlYWNoL3JlYWNoLXVpL3RyZWUvbWFpbi9wYWNrYWdlcy9jb21ib2JveFxuICogQHNlZSBXQUktQVJJQSBodHRwczovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEtcHJhY3RpY2VzLTEuMi8jY29tYm9ib3hcbiAqL1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZU5hbWVkQ29udGV4dCxcbiAgZm9yd2FyZFJlZldpdGhBcyxcbiAgZ2V0T3duZXJEb2N1bWVudCxcbiAgaXNGdW5jdGlvbixcbiAgbWFrZUlkLFxuICBub29wLFxuICB1c2VDaGVja1N0eWxlcyxcbiAgdXNlRm9ya2VkUmVmLFxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LFxuICB1c2VMYXp5UmVmLFxuICB1c2VVcGRhdGVFZmZlY3QsXG4gIHdyYXBFdmVudCxcbn0gZnJvbSBcIkByZWFjaC91dGlsc1wiO1xuaW1wb3J0IHtcbiAgY3JlYXRlRGVzY2VuZGFudENvbnRleHQsXG4gIERlc2NlbmRhbnRQcm92aWRlcixcbiAgdXNlRGVzY2VuZGFudCxcbiAgdXNlRGVzY2VuZGFudHMsXG4gIHVzZURlc2NlbmRhbnRzSW5pdCxcbn0gZnJvbSBcIkByZWFjaC9kZXNjZW5kYW50c1wiO1xuaW1wb3J0IHsgZmluZEFsbCB9IGZyb20gXCJoaWdobGlnaHQtd29yZHMtY29yZVwiO1xuaW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiQHJlYWNoL2F1dG8taWRcIjtcbmltcG9ydCB7IFBvcG92ZXIsIHBvc2l0aW9uTWF0Y2hXaWR0aCB9IGZyb20gXCJAcmVhY2gvcG9wb3ZlclwiO1xuXG5pbXBvcnQgdHlwZSB7IFBvcG92ZXJQcm9wcyB9IGZyb20gXCJAcmVhY2gvcG9wb3ZlclwiO1xuaW1wb3J0IHR5cGUgeyBEZXNjZW5kYW50IH0gZnJvbSBcIkByZWFjaC9kZXNjZW5kYW50c1wiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU3RhdGVzXG5cbi8vIE5vdGhpbmcgZ29pbmcgb24sIHdhaXRpbmcgZm9yIHRoZSB1c2VyIHRvIHR5cGUgb3IgdXNlIHRoZSBhcnJvdyBrZXlzXG5jb25zdCBJRExFID0gXCJJRExFXCI7XG5cbi8vIFRoZSBjb21wb25lbnQgaXMgc3VnZ2VzdGluZyBvcHRpb25zIGFzIHRoZSB1c2VyIHR5cGVzXG5jb25zdCBTVUdHRVNUSU5HID0gXCJTVUdHRVNUSU5HXCI7XG5cbi8vIFRoZSB1c2VyIGlzIHVzaW5nIHRoZSBrZXlib2FyZCB0byBuYXZpZ2F0ZSB0aGUgbGlzdCwgbm90IHR5cGluZ1xuY29uc3QgTkFWSUdBVElORyA9IFwiTkFWSUdBVElOR1wiO1xuXG4vLyBUaGUgdXNlciBpcyBpbnRlcmFjdGluZyB3aXRoIGFyYml0cmFyeSBlbGVtZW50cyBpbnNpZGUgdGhlIHBvcHVwIHRoYXRcbi8vIGFyZSBub3QgQ29tYm9ib3hJbnB1dHNcbmNvbnN0IElOVEVSQUNUSU5HID0gXCJJTlRFUkFDVElOR1wiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRXZlbnRzXG5cbi8vIFVzZXIgY2xlYXJlZCB0aGUgdmFsdWUgdy8gYmFja3NwYWNlLCBidXQgaW5wdXQgc3RpbGwgaGFzIGZvY3VzXG5jb25zdCBDTEVBUiA9IFwiQ0xFQVJcIjtcblxuLy8gVXNlciBpcyB0eXBpbmdcbmNvbnN0IENIQU5HRSA9IFwiQ0hBTkdFXCI7XG5cbi8vIEluaXRpYWwgaW5wdXQgdmFsdWUgY2hhbmdlIGhhbmRsZXIgZm9yIHN5bmNpbmcgdXNlciBzdGF0ZSB3aXRoIHN0YXRlIG1hY2hpbmVcbi8vIFByZXZlbnRzIGluaXRpYWwgY2hhbmdlIGZyb20gc2VuZGluZyB0aGUgdXNlciB0byB0aGUgTkFWSUdBVElORyBzdGF0ZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWNoL3JlYWNoLXVpL2lzc3Vlcy80NjRcbmNvbnN0IElOSVRJQUxfQ0hBTkdFID0gXCJJTklUSUFMX0NIQU5HRVwiO1xuXG4vLyBVc2VyIGlzIG5hdmlnYXRpbmcgdy8gdGhlIGtleWJvYXJkXG5jb25zdCBOQVZJR0FURSA9IFwiTkFWSUdBVEVcIjtcblxuLy8gVXNlciBjYW4gYmUgbmF2aWdhdGluZyB3aXRoIGtleWJvYXJkIGFuZCB0aGVuIGNsaWNrIGluc3RlYWQsIHdlIHdhbnQgdGhlXG4vLyB2YWx1ZSBmcm9tIHRoZSBjbGljaywgbm90IHRoZSBjdXJyZW50IG5hdiBpdGVtXG5jb25zdCBTRUxFQ1RfV0lUSF9LRVlCT0FSRCA9IFwiU0VMRUNUX1dJVEhfS0VZQk9BUkRcIjtcbmNvbnN0IFNFTEVDVF9XSVRIX0NMSUNLID0gXCJTRUxFQ1RfV0lUSF9DTElDS1wiO1xuXG4vLyBQcmV0dHkgc2VsZi1leHBsYW5hdG9yeSwgdXNlciBjYW4gaGl0IGVzY2FwZSBvciBibHVyIHRvIGNsb3NlIHRoZSBwb3BvdmVyXG5jb25zdCBFU0NBUEUgPSBcIkVTQ0FQRVwiO1xuY29uc3QgQkxVUiA9IFwiQkxVUlwiO1xuXG4vLyBUaGUgdXNlciBsZWZ0IHRoZSBpbnB1dCB0byBpbnRlcmFjdCB3aXRoIGFyYml0cmFyeSBlbGVtZW50cyBpbnNpZGUgdGhlIHBvcHVwXG5jb25zdCBJTlRFUkFDVCA9IFwiSU5URVJBQ1RcIjtcblxuY29uc3QgRk9DVVMgPSBcIkZPQ1VTXCI7XG5cbmNvbnN0IE9QRU5fV0lUSF9CVVRUT04gPSBcIk9QRU5fV0lUSF9CVVRUT05cIjtcblxuY29uc3QgQ0xPU0VfV0lUSF9CVVRUT04gPSBcIkNMT1NFX1dJVEhfQlVUVE9OXCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBzdGF0ZUNoYXJ0OiBTdGF0ZUNoYXJ0ID0ge1xuICBpbml0aWFsOiBJRExFLFxuICBzdGF0ZXM6IHtcbiAgICBbSURMRV06IHtcbiAgICAgIG9uOiB7XG4gICAgICAgIFtCTFVSXTogSURMRSxcbiAgICAgICAgW0NMRUFSXTogSURMRSxcbiAgICAgICAgW0NIQU5HRV06IFNVR0dFU1RJTkcsXG4gICAgICAgIFtJTklUSUFMX0NIQU5HRV06IElETEUsXG4gICAgICAgIFtGT0NVU106IFNVR0dFU1RJTkcsXG4gICAgICAgIFtOQVZJR0FURV06IE5BVklHQVRJTkcsXG4gICAgICAgIFtPUEVOX1dJVEhfQlVUVE9OXTogU1VHR0VTVElORyxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBbU1VHR0VTVElOR106IHtcbiAgICAgIG9uOiB7XG4gICAgICAgIFtDSEFOR0VdOiBTVUdHRVNUSU5HLFxuICAgICAgICBbRk9DVVNdOiBTVUdHRVNUSU5HLFxuICAgICAgICBbTkFWSUdBVEVdOiBOQVZJR0FUSU5HLFxuICAgICAgICBbQ0xFQVJdOiBJRExFLFxuICAgICAgICBbRVNDQVBFXTogSURMRSxcbiAgICAgICAgW0JMVVJdOiBJRExFLFxuICAgICAgICBbU0VMRUNUX1dJVEhfQ0xJQ0tdOiBJRExFLFxuICAgICAgICBbSU5URVJBQ1RdOiBJTlRFUkFDVElORyxcbiAgICAgICAgW0NMT1NFX1dJVEhfQlVUVE9OXTogSURMRSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBbTkFWSUdBVElOR106IHtcbiAgICAgIG9uOiB7XG4gICAgICAgIFtDSEFOR0VdOiBTVUdHRVNUSU5HLFxuICAgICAgICBbRk9DVVNdOiBTVUdHRVNUSU5HLFxuICAgICAgICBbQ0xFQVJdOiBJRExFLFxuICAgICAgICBbQkxVUl06IElETEUsXG4gICAgICAgIFtFU0NBUEVdOiBJRExFLFxuICAgICAgICBbTkFWSUdBVEVdOiBOQVZJR0FUSU5HLFxuICAgICAgICBbU0VMRUNUX1dJVEhfQ0xJQ0tdOiBJRExFLFxuICAgICAgICBbU0VMRUNUX1dJVEhfS0VZQk9BUkRdOiBJRExFLFxuICAgICAgICBbQ0xPU0VfV0lUSF9CVVRUT05dOiBJRExFLFxuICAgICAgICBbSU5URVJBQ1RdOiBJTlRFUkFDVElORyxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBbSU5URVJBQ1RJTkddOiB7XG4gICAgICBvbjoge1xuICAgICAgICBbQ0xFQVJdOiBJRExFLFxuICAgICAgICBbQ0hBTkdFXTogU1VHR0VTVElORyxcbiAgICAgICAgW0ZPQ1VTXTogU1VHR0VTVElORyxcbiAgICAgICAgW0JMVVJdOiBJRExFLFxuICAgICAgICBbRVNDQVBFXTogSURMRSxcbiAgICAgICAgW05BVklHQVRFXTogTkFWSUdBVElORyxcbiAgICAgICAgW0NMT1NFX1dJVEhfQlVUVE9OXTogSURMRSxcbiAgICAgICAgW1NFTEVDVF9XSVRIX0NMSUNLXTogSURMRSxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IHJlZHVjZXI6IFJlZHVjZXIgPSAoZGF0YTogU3RhdGVEYXRhLCBldmVudDogTWFjaGluZUV2ZW50KSA9PiB7XG4gIGNvbnN0IG5leHRTdGF0ZSA9IHsgLi4uZGF0YSwgbGFzdEV2ZW50VHlwZTogZXZlbnQudHlwZSB9O1xuICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICBjYXNlIENIQU5HRTpcbiAgICBjYXNlIElOSVRJQUxfQ0hBTkdFOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubmV4dFN0YXRlLFxuICAgICAgICBuYXZpZ2F0aW9uVmFsdWU6IG51bGwsXG4gICAgICAgIHZhbHVlOiBldmVudC52YWx1ZSxcbiAgICAgIH07XG4gICAgY2FzZSBOQVZJR0FURTpcbiAgICBjYXNlIE9QRU5fV0lUSF9CVVRUT046XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5uZXh0U3RhdGUsXG4gICAgICAgIG5hdmlnYXRpb25WYWx1ZTogZmluZE5hdmlnYXRpb25WYWx1ZShuZXh0U3RhdGUsIGV2ZW50KSxcbiAgICAgIH07XG4gICAgY2FzZSBDTEVBUjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm5leHRTdGF0ZSxcbiAgICAgICAgdmFsdWU6IFwiXCIsXG4gICAgICAgIG5hdmlnYXRpb25WYWx1ZTogbnVsbCxcbiAgICAgIH07XG4gICAgY2FzZSBCTFVSOlxuICAgIGNhc2UgRVNDQVBFOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubmV4dFN0YXRlLFxuICAgICAgICBuYXZpZ2F0aW9uVmFsdWU6IG51bGwsXG4gICAgICB9O1xuICAgIGNhc2UgU0VMRUNUX1dJVEhfQ0xJQ0s6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5uZXh0U3RhdGUsXG4gICAgICAgIHZhbHVlOiBldmVudC52YWx1ZSxcbiAgICAgICAgbmF2aWdhdGlvblZhbHVlOiBudWxsLFxuICAgICAgfTtcbiAgICBjYXNlIFNFTEVDVF9XSVRIX0tFWUJPQVJEOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubmV4dFN0YXRlLFxuICAgICAgICB2YWx1ZTogZGF0YS5uYXZpZ2F0aW9uVmFsdWUsXG4gICAgICAgIG5hdmlnYXRpb25WYWx1ZTogbnVsbCxcbiAgICAgIH07XG4gICAgY2FzZSBDTE9TRV9XSVRIX0JVVFRPTjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm5leHRTdGF0ZSxcbiAgICAgICAgbmF2aWdhdGlvblZhbHVlOiBudWxsLFxuICAgICAgfTtcbiAgICBjYXNlIElOVEVSQUNUOlxuICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICBjYXNlIEZPQ1VTOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubmV4dFN0YXRlLFxuICAgICAgICBuYXZpZ2F0aW9uVmFsdWU6IGZpbmROYXZpZ2F0aW9uVmFsdWUobmV4dFN0YXRlLCBldmVudCksXG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBvcG92ZXJJc0V4cGFuZGVkKHN0YXRlOiBTdGF0ZSkge1xuICByZXR1cm4gW1NVR0dFU1RJTkcsIE5BVklHQVRJTkcsIElOVEVSQUNUSU5HXS5pbmNsdWRlcyhzdGF0ZSk7XG59XG5cbi8qKlxuICogV2hlbiB3ZSBvcGVuIGEgbGlzdCwgc2V0IHRoZSBuYXZpZ2F0aW9uIHZhbHVlIHRvIHRoZSB2YWx1ZSBpbiB0aGUgaW5wdXQsIGlmXG4gKiBpdCdzIGluIHRoZSBsaXN0LCB0aGVuIGl0J2xsIGF1dG9tYXRpY2FsbHkgYmUgaGlnaGxpZ2h0ZWQuXG4gKlxuICogQHBhcmFtIHN0YXRlRGF0YVxuICogQHBhcmFtIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmROYXZpZ2F0aW9uVmFsdWUoc3RhdGVEYXRhOiBTdGF0ZURhdGEsIGV2ZW50OiBNYWNoaW5lRXZlbnQpIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAoZXZlbnQudmFsdWUpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGV2ZW50LnZhbHVlO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgfSBlbHNlIGlmIChldmVudC5wZXJzaXN0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHN0YXRlRGF0YS52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5jb25zdCBDb21ib2JveERlc2NlbmRhbnRDb250ZXh0ID0gY3JlYXRlRGVzY2VuZGFudENvbnRleHQ8Q29tYm9ib3hEZXNjZW5kYW50PihcbiAgXCJDb21ib2JveERlc2NlbmRhbnRDb250ZXh0XCJcbik7XG5jb25zdCBDb21ib2JveENvbnRleHQgPSBjcmVhdGVOYW1lZENvbnRleHQoXG4gIFwiQ29tYm9ib3hDb250ZXh0XCIsXG4gIHt9IGFzIEludGVybmFsQ29tYm9ib3hDb250ZXh0VmFsdWVcbik7XG5cbi8vIEFsbG93cyB1cyB0byBwdXQgdGhlIG9wdGlvbidzIHZhbHVlIG9uIGNvbnRleHQgc28gdGhhdCBDb21ib2JveE9wdGlvblRleHRcbi8vIGNhbiB3b3JrIGl0J3MgaGlnaGxpZ2h0IHRleHQgbWFnaWMgbm8gbWF0dGVyIHdoYXQgZWxzZSBpcyByZW5kZXJlZCBhcm91bmRcbi8vIGl0LlxuY29uc3QgT3B0aW9uQ29udGV4dCA9IGNyZWF0ZU5hbWVkQ29udGV4dChcbiAgXCJPcHRpb25Db250ZXh0XCIsXG4gIHt9IGFzIENvbWJvYm94T3B0aW9uQ29udGV4dFZhbHVlXG4pO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENvbWJvYm94XG4gKlxuICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveFxuICovXG5leHBvcnQgY29uc3QgQ29tYm9ib3ggPSBmb3J3YXJkUmVmV2l0aEFzPENvbWJvYm94UHJvcHMsIFwiZGl2XCI+KFxuICBmdW5jdGlvbiBDb21ib2JveChcbiAgICB7XG4gICAgICBvblNlbGVjdCxcbiAgICAgIG9wZW5PbkZvY3VzID0gZmFsc2UsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGFzOiBDb21wID0gXCJkaXZcIixcbiAgICAgIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsXG4gICAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBhcmlhTGFiZWxsZWRieSxcbiAgICAgIC4uLnByb3BzXG4gICAgfSxcbiAgICBmb3J3YXJkZWRSZWZcbiAgKSB7XG4gICAgbGV0IFtvcHRpb25zLCBzZXRPcHRpb25zXSA9IHVzZURlc2NlbmRhbnRzSW5pdDxDb21ib2JveERlc2NlbmRhbnQ+KCk7XG5cbiAgICAvLyBOZWVkIHRoaXMgdG8gZm9jdXMgaXRcbiAgICBjb25zdCBpbnB1dFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuXG4gICAgY29uc3QgcG9wb3ZlclJlZiA9IFJlYWN0LnVzZVJlZigpO1xuXG4gICAgY29uc3QgYnV0dG9uUmVmID0gUmVhY3QudXNlUmVmKCk7XG5cbiAgICAvLyBXaGVuIDxDb21ib2JveElucHV0IGF1dG9jb21wbGV0ZT17ZmFsc2V9IC8+IHdlIGRvbid0IHdhbnQgY3ljbGUgYmFjayB0b1xuICAgIC8vIHRoZSB1c2VyJ3MgdmFsdWUgd2hpbGUgbmF2aWdhdGluZyAoYmVjYXVzZSBpdCdzIGFsd2F5cyB0aGUgdXNlcidzIHZhbHVlKSxcbiAgICAvLyBidXQgd2UgbmVlZCB0byBrbm93IHRoaXMgaW4gdXNlS2V5RG93biB3aGljaCBpcyBmYXIgYXdheSBmcm9tIHRoZSBwcm9wXG4gICAgLy8gaGVyZSwgc28gd2UgZG8gc29tZXRoaW5nIHNuZWFreSBhbmQgd3JpdGUgaXQgdG8gdGhpcyByZWYgb24gY29udGV4dCBzbyB3ZVxuICAgIC8vIGNhbiB1c2UgaXQgYW55d2hlcmUgZWxzZSDwn5ibLiBBbm90aGVyIG5ldyB0cmljayBmb3IgbWUgYW5kIEknbSBleGNpdGVkXG4gICAgLy8gYWJvdXQgdGhpcyBvbmUgdG9vIVxuICAgIGNvbnN0IGF1dG9jb21wbGV0ZVByb3BSZWYgPSBSZWFjdC51c2VSZWYoKTtcblxuICAgIGNvbnN0IHBlcnNpc3RTZWxlY3Rpb25SZWYgPSBSZWFjdC51c2VSZWYoKTtcblxuICAgIGNvbnN0IGRlZmF1bHREYXRhOiBTdGF0ZURhdGEgPSB7XG4gICAgICAvLyBUaGUgdmFsdWUgdGhlIHVzZXIgaGFzIHR5cGVkLiBXZSBkZXJpdmUgdGhpcyBhbHNvIHdoZW4gdGhlIGRldmVsb3BlciBpc1xuICAgICAgLy8gY29udHJvbGxpbmcgdGhlIHZhbHVlIG9mIENvbWJvYm94SW5wdXQuXG4gICAgICB2YWx1ZTogXCJcIixcbiAgICAgIC8vIHRoZSB2YWx1ZSB0aGUgdXNlciBoYXMgbmF2aWdhdGVkIHRvIHdpdGggdGhlIGtleWJvYXJkXG4gICAgICBuYXZpZ2F0aW9uVmFsdWU6IG51bGwsXG4gICAgfTtcblxuICAgIGNvbnN0IFtzdGF0ZSwgZGF0YSwgdHJhbnNpdGlvbl0gPSB1c2VSZWR1Y2VyTWFjaGluZShcbiAgICAgIHN0YXRlQ2hhcnQsXG4gICAgICByZWR1Y2VyLFxuICAgICAgZGVmYXVsdERhdGFcbiAgICApO1xuXG4gICAgdXNlRm9jdXNNYW5hZ2VtZW50KGRhdGEubGFzdEV2ZW50VHlwZSwgaW5wdXRSZWYpO1xuXG4gICAgY29uc3QgaWQgPSB1c2VJZChwcm9wcy5pZCk7XG4gICAgY29uc3QgbGlzdGJveElkID0gaWQgPyBtYWtlSWQoXCJsaXN0Ym94XCIsIGlkKSA6IFwibGlzdGJveFwiO1xuXG4gICAgY29uc3QgY29udGV4dDogSW50ZXJuYWxDb21ib2JveENvbnRleHRWYWx1ZSA9IHtcbiAgICAgIGFyaWFMYWJlbCxcbiAgICAgIGFyaWFMYWJlbGxlZGJ5LFxuICAgICAgYXV0b2NvbXBsZXRlUHJvcFJlZixcbiAgICAgIGJ1dHRvblJlZixcbiAgICAgIGNvbWJvYm94SWQ6IGlkLFxuICAgICAgZGF0YSxcbiAgICAgIGlucHV0UmVmLFxuICAgICAgaXNFeHBhbmRlZDogcG9wb3ZlcklzRXhwYW5kZWQoc3RhdGUpLFxuICAgICAgbGlzdGJveElkLFxuICAgICAgb25TZWxlY3Q6IG9uU2VsZWN0IHx8IG5vb3AsXG4gICAgICBvcGVuT25Gb2N1cyxcbiAgICAgIHBlcnNpc3RTZWxlY3Rpb25SZWYsXG4gICAgICBwb3BvdmVyUmVmLFxuICAgICAgc3RhdGUsXG4gICAgICB0cmFuc2l0aW9uLFxuICAgIH07XG5cbiAgICB1c2VDaGVja1N0eWxlcyhcImNvbWJvYm94XCIpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxEZXNjZW5kYW50UHJvdmlkZXJcbiAgICAgICAgY29udGV4dD17Q29tYm9ib3hEZXNjZW5kYW50Q29udGV4dH1cbiAgICAgICAgaXRlbXM9e29wdGlvbnN9XG4gICAgICAgIHNldD17c2V0T3B0aW9uc31cbiAgICAgID5cbiAgICAgICAgPENvbWJvYm94Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dH0+XG4gICAgICAgICAgPENvbXAgey4uLnByb3BzfSBkYXRhLXJlYWNoLWNvbWJvYm94PVwiXCIgcmVmPXtmb3J3YXJkZWRSZWZ9PlxuICAgICAgICAgICAge2lzRnVuY3Rpb24oY2hpbGRyZW4pXG4gICAgICAgICAgICAgID8gY2hpbGRyZW4oeyBpZCwgaXNFeHBhbmRlZDogcG9wb3ZlcklzRXhwYW5kZWQoc3RhdGUpIH0pXG4gICAgICAgICAgICAgIDogY2hpbGRyZW59XG4gICAgICAgICAgPC9Db21wPlxuICAgICAgICA8L0NvbWJvYm94Q29udGV4dC5Qcm92aWRlcj5cbiAgICAgIDwvRGVzY2VuZGFudFByb3ZpZGVyPlxuICAgICk7XG4gIH1cbik7XG5cbi8qKlxuICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveC1wcm9wc1xuICovXG5leHBvcnQgdHlwZSBDb21ib2JveFByb3BzID0ge1xuICAvKipcbiAgICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveC1jaGlsZHJlblxuICAgKi9cbiAgY2hpbGRyZW46XG4gICAgfCBSZWFjdC5SZWFjdE5vZGVcbiAgICB8ICgocHJvcHM6IENvbWJvYm94Q29udGV4dFZhbHVlKSA9PiBSZWFjdC5SZWFjdE5vZGUpO1xuICAvKipcbiAgICogQ2FsbGVkIHdpdGggdGhlIHNlbGVjdGlvbiB2YWx1ZSB3aGVuIHRoZSB1c2VyIG1ha2VzIGEgc2VsZWN0aW9uIGZyb20gdGhlXG4gICAqIGxpc3QuXG4gICAqXG4gICAqIEBzZWUgRG9jcyBodHRwczovL3JlYWNoLnRlY2gvY29tYm9ib3gjY29tYm9ib3gtb25zZWxlY3RcbiAgICovXG4gIG9uU2VsZWN0Pyh2YWx1ZTogQ29tYm9ib3hWYWx1ZSk6IHZvaWQ7XG4gIC8qKlxuICAgKiBJZiB0cnVlLCB0aGUgcG9wb3ZlciBvcGVucyB3aGVuIGZvY3VzIGlzIG9uIHRoZSB0ZXh0IGJveC5cbiAgICpcbiAgICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveC1vcGVub25mb2N1c1xuICAgKi9cbiAgb3Blbk9uRm9jdXM/OiBib29sZWFuO1xuICAvKipcbiAgICogRGVmaW5lcyBhIHN0cmluZyB2YWx1ZSB0aGF0IGxhYmVscyB0aGUgY3VycmVudCBlbGVtZW50LlxuICAgKiBAc2VlIERvY3MgaHR0cHM6Ly9yZWFjaC50ZWNoL2NvbWJvYm94I2FjY2Vzc2liaWxpdHlcbiAgICovXG4gIFwiYXJpYS1sYWJlbFwiPzogc3RyaW5nO1xuICAvKipcbiAgICogSWRlbnRpZmllcyB0aGUgZWxlbWVudCAob3IgZWxlbWVudHMpIHRoYXQgbGFiZWxzIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gICAqIEBzZWUgRG9jcyBodHRwczovL3JlYWNoLnRlY2gvY29tYm9ib3gjYWNjZXNzaWJpbGl0eVxuICAgKi9cbiAgXCJhcmlhLWxhYmVsbGVkYnlcIj86IHN0cmluZztcbn07XG5cbmlmIChfX0RFVl9fKSB7XG4gIENvbWJvYm94LmRpc3BsYXlOYW1lID0gXCJDb21ib2JveFwiO1xuICBDb21ib2JveC5wcm9wVHlwZXMgPSB7XG4gICAgYXM6IFByb3BUeXBlcy5hbnksXG4gICAgb25TZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9wZW5PbkZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcbiAgfTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDb21ib2JveElucHV0XG4gKlxuICogV3JhcHMgYW4gYDxpbnB1dC8+YCB3aXRoIGEgY291cGxlIGV4dHJhIHByb3BzIHRoYXQgd29yayB3aXRoIHRoZSBjb21ib2JveC5cbiAqXG4gKiBAc2VlIERvY3MgaHR0cHM6Ly9yZWFjaC50ZWNoL2NvbWJvYm94I2NvbWJvYm94aW5wdXRcbiAqL1xuZXhwb3J0IGNvbnN0IENvbWJvYm94SW5wdXQgPSBmb3J3YXJkUmVmV2l0aEFzPENvbWJvYm94SW5wdXRQcm9wcywgXCJpbnB1dFwiPihcbiAgZnVuY3Rpb24gQ29tYm9ib3hJbnB1dChcbiAgICB7XG4gICAgICBhczogQ29tcCA9IFwiaW5wdXRcIixcbiAgICAgIHNlbGVjdE9uQ2xpY2sgPSBmYWxzZSxcbiAgICAgIGF1dG9jb21wbGV0ZSA9IHRydWUsXG4gICAgICBvbkNsaWNrLFxuICAgICAgb25DaGFuZ2UsXG4gICAgICBvbktleURvd24sXG4gICAgICBvbkJsdXIsXG4gICAgICBvbkZvY3VzLFxuICAgICAgdmFsdWU6IGNvbnRyb2xsZWRWYWx1ZSxcbiAgICAgIC4uLnByb3BzXG4gICAgfSxcbiAgICBmb3J3YXJkZWRSZWZcbiAgKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWNoL3JlYWNoLXVpL2lzc3Vlcy80NjRcbiAgICBsZXQgeyBjdXJyZW50OiBpbml0aWFsQ29udHJvbGxlZFZhbHVlIH0gPSBSZWFjdC51c2VSZWYoY29udHJvbGxlZFZhbHVlKTtcbiAgICBsZXQgY29udHJvbGxlZFZhbHVlQ2hhbmdlZFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgdXNlVXBkYXRlRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnRyb2xsZWRWYWx1ZUNoYW5nZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfSwgW2NvbnRyb2xsZWRWYWx1ZV0pO1xuXG4gICAgbGV0IHtcbiAgICAgIGRhdGE6IHsgbmF2aWdhdGlvblZhbHVlLCB2YWx1ZSwgbGFzdEV2ZW50VHlwZSB9LFxuICAgICAgaW5wdXRSZWYsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBsaXN0Ym94SWQsXG4gICAgICBhdXRvY29tcGxldGVQcm9wUmVmLFxuICAgICAgb3Blbk9uRm9jdXMsXG4gICAgICBpc0V4cGFuZGVkLFxuICAgICAgYXJpYUxhYmVsLFxuICAgICAgYXJpYUxhYmVsbGVkYnksXG4gICAgfSA9IFJlYWN0LnVzZUNvbnRleHQoQ29tYm9ib3hDb250ZXh0KTtcblxuICAgIGxldCByZWYgPSB1c2VGb3JrZWRSZWYoaW5wdXRSZWYsIGZvcndhcmRlZFJlZik7XG5cbiAgICAvLyBCZWNhdXNlIHdlIGNsb3NlIHRoZSBMaXN0IG9uIGJsdXIsIHdlIG5lZWQgdG8gdHJhY2sgaWYgdGhlIGJsdXIgaXNcbiAgICAvLyBjYXVzZWQgYnkgY2xpY2tpbmcgaW5zaWRlIHRoZSBsaXN0LCBhbmQgaWYgc28sIGRvbid0IGNsb3NlIHRoZSBMaXN0LlxuICAgIGxldCBzZWxlY3RPbkNsaWNrUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcblxuICAgIGxldCBoYW5kbGVLZXlEb3duID0gdXNlS2V5RG93bigpO1xuXG4gICAgbGV0IGhhbmRsZUJsdXIgPSB1c2VCbHVyKCk7XG5cbiAgICBsZXQgaXNDb250cm9sbGVkID0gY29udHJvbGxlZFZhbHVlICE9IG51bGw7XG5cbiAgICAvLyBMYXlvdXQgZWZmZWN0IHNob3VsZCBiZSBTU1Itc2FmZSBoZXJlIGJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgZG9cbiAgICAvLyBhbnl0aGluZyB3aXRoIHRoaXMgcmVmIHRoYXQgaW52b2x2ZXMgcmVuZGVyaW5nIHVudGlsIGFmdGVyIHdlJ3ZlXG4gICAgLy8gbGV0IHRoZSBjbGllbnQgaHlkcmF0ZSBpbiBuZXN0ZWQgY29tcG9uZW50cy5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGF1dG9jb21wbGV0ZVByb3BSZWYuY3VycmVudCA9IGF1dG9jb21wbGV0ZTtcbiAgICB9LCBbYXV0b2NvbXBsZXRlLCBhdXRvY29tcGxldGVQcm9wUmVmXSk7XG5cbiAgICBjb25zdCBoYW5kbGVWYWx1ZUNoYW5nZSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgKHZhbHVlOiBDb21ib2JveFZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uKENMRUFSKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB2YWx1ZSA9PT0gaW5pdGlhbENvbnRyb2xsZWRWYWx1ZSAmJlxuICAgICAgICAgICFjb250cm9sbGVkVmFsdWVDaGFuZ2VkUmVmLmN1cnJlbnRcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbihJTklUSUFMX0NIQU5HRSwgeyB2YWx1ZSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFuc2l0aW9uKENIQU5HRSwgeyB2YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtpbml0aWFsQ29udHJvbGxlZFZhbHVlLCB0cmFuc2l0aW9uXVxuICAgICk7XG5cbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgLy8gSWYgdGhleSBhcmUgY29udHJvbGxpbmcgdGhlIHZhbHVlIHdlIHN0aWxsIG5lZWQgdG8gZG8gb3VyIHRyYW5zaXRpb25zLFxuICAgICAgLy8gc28gIHdlIGhhdmUgdGhpcyBkZXJpdmVkIHN0YXRlIHRvIGVtdWxhdGUgb25DaGFuZ2Ugb2YgdGhlIGlucHV0IGFzIHdlXG4gICAgICAvLyByZWNlaXZlIG5ldyBgdmFsdWVgcyAuLi5bKl1cbiAgICAgIGlmIChcbiAgICAgICAgaXNDb250cm9sbGVkICYmXG4gICAgICAgIGNvbnRyb2xsZWRWYWx1ZSAhPT0gdmFsdWUgJiZcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWNoL3JlYWNoLXVpL2lzc3Vlcy80ODFcbiAgICAgICAgKGNvbnRyb2xsZWRWYWx1ZSEudHJpbSgpID09PSBcIlwiID8gKHZhbHVlIHx8IFwiXCIpLnRyaW0oKSAhPT0gXCJcIiA6IHRydWUpXG4gICAgICApIHtcbiAgICAgICAgaGFuZGxlVmFsdWVDaGFuZ2UoY29udHJvbGxlZFZhbHVlISk7XG4gICAgICB9XG4gICAgfSwgW2NvbnRyb2xsZWRWYWx1ZSwgaGFuZGxlVmFsdWVDaGFuZ2UsIGlzQ29udHJvbGxlZCwgdmFsdWVdKTtcblxuICAgIC8vIFsqXS4uLiBhbmQgd2hlbiBjb250cm9sbGVkLCB3ZSBkb24ndCB0cmlnZ2VyIGhhbmRsZVZhbHVlQ2hhbmdlIGFzIHRoZVxuICAgIC8vIHVzZXIgdHlwZXMsIGluc3RlYWQgdGhlIGRldmVsb3BlciBjb250cm9scyBpdCB3aXRoIHRoZSBub3JtYWwgaW5wdXRcbiAgICAvLyBvbkNoYW5nZSBwcm9wXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50Pikge1xuICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgaWYgKCFpc0NvbnRyb2xsZWQpIHtcbiAgICAgICAgaGFuZGxlVmFsdWVDaGFuZ2UodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUZvY3VzKCkge1xuICAgICAgaWYgKHNlbGVjdE9uQ2xpY2spIHtcbiAgICAgICAgc2VsZWN0T25DbGlja1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2Ugc2VsZWN0IGFuIG9wdGlvbiB3aXRoIGNsaWNrLCB1c2VGb2N1c01hbmFnZW1lbnQgd2lsbCBmb2N1cyB0aGVcbiAgICAgIC8vIGlucHV0LCBpbiB0aG9zZSBjYXNlcyB3ZSBkb24ndCB3YW50IHRvIGNhdXNlIHRoZSBtZW51IHRvIG9wZW4gYmFjayB1cCxcbiAgICAgIC8vIHNvIHdlIGd1YXJkIGJlaGluZCB0aGVzZSBzdGF0ZXMuXG4gICAgICBpZiAob3Blbk9uRm9jdXMgJiYgbGFzdEV2ZW50VHlwZSAhPT0gU0VMRUNUX1dJVEhfQ0xJQ0spIHtcbiAgICAgICAgdHJhbnNpdGlvbihGT0NVUyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soKSB7XG4gICAgICBpZiAoc2VsZWN0T25DbGlja1JlZi5jdXJyZW50KSB7XG4gICAgICAgIHNlbGVjdE9uQ2xpY2tSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBpbnB1dFJlZi5jdXJyZW50LnNlbGVjdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlucHV0VmFsdWUgPVxuICAgICAgYXV0b2NvbXBsZXRlICYmIChzdGF0ZSA9PT0gTkFWSUdBVElORyB8fCBzdGF0ZSA9PT0gSU5URVJBQ1RJTkcpXG4gICAgICAgID8gLy8gV2hlbiBpZGxlLCB3ZSBkb24ndCBoYXZlIGEgbmF2aWdhdGlvblZhbHVlIG9uIEFycm93VXAvRG93blxuICAgICAgICAgIG5hdmlnYXRpb25WYWx1ZSB8fCBjb250cm9sbGVkVmFsdWUgfHwgdmFsdWVcbiAgICAgICAgOiBjb250cm9sbGVkVmFsdWUgfHwgdmFsdWU7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPENvbXBcbiAgICAgICAgYXJpYS1hY3RpdmVkZXNjZW5kYW50PXtcbiAgICAgICAgICBuYXZpZ2F0aW9uVmFsdWUgPyBTdHJpbmcobWFrZUhhc2gobmF2aWdhdGlvblZhbHVlKSkgOiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgICBhcmlhLWF1dG9jb21wbGV0ZT1cImJvdGhcIlxuICAgICAgICBhcmlhLWNvbnRyb2xzPXtsaXN0Ym94SWR9XG4gICAgICAgIGFyaWEtZXhwYW5kZWQ9e2lzRXhwYW5kZWR9XG4gICAgICAgIGFyaWEtaGFzcG9wdXA9XCJsaXN0Ym94XCJcbiAgICAgICAgYXJpYS1sYWJlbD17YXJpYUxhYmVsfVxuICAgICAgICBhcmlhLWxhYmVsbGVkYnk9e2FyaWFMYWJlbCA/IHVuZGVmaW5lZCA6IGFyaWFMYWJlbGxlZGJ5fVxuICAgICAgICByb2xlPVwiY29tYm9ib3hcIlxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgIGRhdGEtcmVhY2gtY29tYm9ib3gtaW5wdXQ9XCJcIlxuICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgb25CbHVyPXt3cmFwRXZlbnQob25CbHVyLCBoYW5kbGVCbHVyKX1cbiAgICAgICAgb25DaGFuZ2U9e3dyYXBFdmVudChvbkNoYW5nZSwgaGFuZGxlQ2hhbmdlKX1cbiAgICAgICAgb25DbGljaz17d3JhcEV2ZW50KG9uQ2xpY2ssIGhhbmRsZUNsaWNrKX1cbiAgICAgICAgb25Gb2N1cz17d3JhcEV2ZW50KG9uRm9jdXMsIGhhbmRsZUZvY3VzKX1cbiAgICAgICAgb25LZXlEb3duPXt3cmFwRXZlbnQob25LZXlEb3duLCBoYW5kbGVLZXlEb3duKX1cbiAgICAgICAgdmFsdWU9e2lucHV0VmFsdWUgfHwgXCJcIn1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuKTtcblxuLyoqXG4gKiBAc2VlIERvY3MgaHR0cHM6Ly9yZWFjaC50ZWNoL2NvbWJvYm94I2NvbWJvYm94aW5wdXQtcHJvcHNcbiAqL1xuZXhwb3J0IHR5cGUgQ29tYm9ib3hJbnB1dFByb3BzID0ge1xuICAvKipcbiAgICogSWYgdHJ1ZSwgd2hlbiB0aGUgdXNlciBjbGlja3MgaW5zaWRlIHRoZSB0ZXh0IGJveCB0aGUgY3VycmVudCB2YWx1ZSB3aWxsXG4gICAqIGJlIHNlbGVjdGVkLiBVc2UgdGhpcyBpZiB0aGUgdXNlciBpcyBsaWtlbHkgdG8gZGVsZXRlIGFsbCB0aGUgdGV4dCBhbnl3YXlcbiAgICogKGxpa2UgdGhlIFVSTCBiYXIgaW4gYnJvd3NlcnMpLlxuICAgKlxuICAgKiBIb3dldmVyLCBpZiB0aGUgdXNlciBpcyBsaWtlbHkgdG8gd2FudCB0byB0d2VhayB0aGUgdmFsdWUsIGxlYXZlIHRoaXNcbiAgICogZmFsc2UsIGxpa2UgYSBnb29nbGUgc2VhcmNoLS10aGUgdXNlciBpcyBsaWtlbHkgd2FudGluZyB0byBlZGl0IHRoZWlyXG4gICAqIHNlYXJjaCwgbm90IHJlcGxhY2UgaXQgY29tcGxldGVseS5cbiAgICpcbiAgICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveGlucHV0LXNlbGVjdG9uY2xpY2tcbiAgICovXG4gIHNlbGVjdE9uQ2xpY2s/OiBib29sZWFuO1xuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgdmFsdWUgaW4gdGhlIGlucHV0IGNoYW5nZXMgb3Igbm90IGFzIHRoZSB1c2VyIG5hdmlnYXRlc1xuICAgKiB3aXRoIHRoZSBrZXlib2FyZC4gSWYgdHJ1ZSwgdGhlIHZhbHVlIGNoYW5nZXMsIGlmIGZhbHNlIHRoZSB2YWx1ZSBkb2Vzbid0XG4gICAqIGNoYW5nZS5cbiAgICpcbiAgICogU2V0IHRoaXMgdG8gZmFsc2Ugd2hlbiB5b3UgZG9uJ3QgcmVhbGx5IG5lZWQgdGhlIHZhbHVlIGZyb20gdGhlIGlucHV0IGJ1dFxuICAgKiB3YW50IHRvIHBvcHVsYXRlIHNvbWUgb3RoZXIgc3RhdGUgKGxpa2UgdGhlIHJlY2lwaWVudCBzZWxlY3RvciBpbiBHbWFpbCkuXG4gICAqIEJ1dCBpZiB5b3VyIGlucHV0IGlzIG1vcmUgbGlrZSBhIG5vcm1hbCBgPGlucHV0IHR5cGU9XCJ0ZXh0XCIvPmAsIHRoZW4gbGVhdmVcbiAgICogdGhlIGB0cnVlYCBkZWZhdWx0LlxuICAgKlxuICAgKiBAc2VlIERvY3MgaHR0cHM6Ly9yZWFjaC50ZWNoL2NvbWJvYm94I2NvbWJvYm94aW5wdXQtYXV0b2NvbXBsZXRlXG4gICAqL1xuICBhdXRvY29tcGxldGU/OiBib29sZWFuO1xuICAvKipcbiAgICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveGlucHV0LXZhbHVlXG4gICAqL1xuICB2YWx1ZT86IENvbWJvYm94VmFsdWU7XG59O1xuXG5pZiAoX19ERVZfXykge1xuICBDb21ib2JveElucHV0LmRpc3BsYXlOYW1lID0gXCJDb21ib2JveElucHV0XCI7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ29tYm9ib3hQb3BvdmVyXG4gKlxuICogQ29udGFpbnMgdGhlIHBvcHVwIHRoYXQgcmVuZGVycyB0aGUgbGlzdC4gQmVjYXVzZSBzb21lIFVJIG5lZWRzIHRvIHJlbmRlclxuICogbW9yZSB0aGFuIHRoZSBsaXN0IGluIHRoZSBwb3B1cCwgeW91IG5lZWQgdG8gcmVuZGVyIG9uZSBvZiB0aGVzZSBhcm91bmQgdGhlXG4gKiBsaXN0LiBGb3IgZXhhbXBsZSwgbWF5YmUgeW91IHdhbnQgdG8gcmVuZGVyIHRoZSBudW1iZXIgb2YgcmVzdWx0cyBzdWdnZXN0ZWQuXG4gKlxuICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveHBvcG92ZXJcbiAqL1xuZXhwb3J0IGNvbnN0IENvbWJvYm94UG9wb3ZlciA9IGZvcndhcmRSZWZXaXRoQXM8XG4gIENvbWJvYm94UG9wb3ZlclByb3BzICYgUGFydGlhbDxQb3BvdmVyUHJvcHM+LFxuICBcImRpdlwiXG4+KGZ1bmN0aW9uIENvbWJvYm94UG9wb3ZlcihcbiAge1xuICAgIGFzOiBDb21wID0gXCJkaXZcIixcbiAgICBjaGlsZHJlbixcbiAgICBwb3J0YWwgPSB0cnVlLFxuICAgIG9uS2V5RG93bixcbiAgICBvbkJsdXIsXG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbk1hdGNoV2lkdGgsXG4gICAgLi4ucHJvcHNcbiAgfSxcbiAgZm9yd2FyZGVkUmVmOiBSZWFjdC5SZWY8YW55PlxuKSB7XG4gIGNvbnN0IHsgcG9wb3ZlclJlZiwgaW5wdXRSZWYsIGlzRXhwYW5kZWQgfSA9IFJlYWN0LnVzZUNvbnRleHQoXG4gICAgQ29tYm9ib3hDb250ZXh0XG4gICk7XG4gIGNvbnN0IHJlZiA9IHVzZUZvcmtlZFJlZihwb3BvdmVyUmVmLCBmb3J3YXJkZWRSZWYpO1xuICBjb25zdCBoYW5kbGVLZXlEb3duID0gdXNlS2V5RG93bigpO1xuICBjb25zdCBoYW5kbGVCbHVyID0gdXNlQmx1cigpO1xuXG4gIGNvbnN0IHNoYXJlZFByb3BzID0ge1xuICAgIFwiZGF0YS1yZWFjaC1jb21ib2JveC1wb3BvdmVyXCI6IFwiXCIsXG4gICAgb25LZXlEb3duOiB3cmFwRXZlbnQ8YW55PihvbktleURvd24sIGhhbmRsZUtleURvd24pLFxuICAgIG9uQmx1cjogd3JhcEV2ZW50PGFueT4ob25CbHVyLCBoYW5kbGVCbHVyKSxcbiAgICAvLyBJbnN0ZWFkIG9mIGNvbmRpdGlvbmFsbHkgcmVuZGVyaW5nIHRoZSBwb3BvdmVyIHdlIHVzZSB0aGUgYGhpZGRlbmAgcHJvcFxuICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byB1bm1vdW50IG9uIGNsb3NlIChmcm9tIGVzY2FwZSBvciBvblNlbGVjdCkuXG4gICAgLy8gSG93ZXZlciwgdGhlIGRldmVsb3BlciBjYW4gY29uZGl0aW9uYWxseSByZW5kZXIgdGhlIENvbWJvYm94UG9wb3ZlciBpZlxuICAgIC8vIHRoZXkgZG8gd2FudCB0byBjYXVzZSBtb3VudC91bm1vdW50IGJhc2VkIG9uIHRoZSBhcHAncyBvd24gZGF0YSAobGlrZVxuICAgIC8vIHJlc3VsdHMubGVuZ3RoIG9yIHdoYXRldmVyKS5cbiAgICBoaWRkZW46ICFpc0V4cGFuZGVkLFxuICAgIHRhYkluZGV4OiAtMSxcbiAgICBjaGlsZHJlbixcbiAgfTtcblxuICByZXR1cm4gcG9ydGFsID8gKFxuICAgIDxQb3BvdmVyXG4gICAgICBhcz17Q29tcH1cbiAgICAgIHsuLi5wcm9wc31cbiAgICAgIHJlZj17cmVmfVxuICAgICAgcG9zaXRpb249e3Bvc2l0aW9ufVxuICAgICAgdGFyZ2V0UmVmPXtpbnB1dFJlZn1cbiAgICAgIHsuLi5zaGFyZWRQcm9wc31cbiAgICAvPlxuICApIDogKFxuICAgIDxDb21wIHJlZj17cmVmfSB7Li4ucHJvcHN9IHsuLi5zaGFyZWRQcm9wc30gLz5cbiAgKTtcbn0pO1xuXG5pZiAoX19ERVZfXykge1xuICBDb21ib2JveFBvcG92ZXIuZGlzcGxheU5hbWUgPSBcIkNvbWJvYm94UG9wb3ZlclwiO1xufVxuXG4vKipcbiAqIEBzZWUgRG9jcyBodHRwczovL3JlYWNoLnRlY2gvY29tYm9ib3gjY29tYm9ib3hwb3BvdmVyLXByb3BzXG4gKi9cbmV4cG9ydCB0eXBlIENvbWJvYm94UG9wb3ZlclByb3BzID0ge1xuICAvKipcbiAgICogSWYgeW91IHBhc3MgYDxDb21ib2JveFBvcG92ZXIgcG9ydGFsPXtmYWxzZX0gLz5gIHRoZSBwb3BvdmVyIHdpbGwgbm90XG4gICAqIHJlbmRlciBpbnNpZGUgb2YgYSBwb3J0YWwsIGJ1dCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgUmVhY3QgdHJlZS4gVGhpc1xuICAgKiBpcyBtb3N0bHkgdXNlZnVsIGZvciBzdHlsaW5nIHRoZSBlbnRpcmUgY29tcG9uZW50IHRvZ2V0aGVyLCBsaWtlIHRoZSBwaW5rXG4gICAqIGZvY3VzIG91dGxpbmUgaW4gdGhlIGV4YW1wbGUgZWFybGllciBpbiB0aGlzIHBhZ2UuXG4gICAqXG4gICAqIEBzZWUgRG9jcyBodHRwczovL3JlYWNoLnRlY2gvY29tYm9ib3gjY29tYm9ib3hwb3BvdmVyLXBvcnRhbFxuICAgKi9cbiAgcG9ydGFsPzogYm9vbGVhbjtcbn07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ29tYm9ib3hMaXN0XG4gKlxuICogQ29udGFpbnMgdGhlIGBDb21ib2JveE9wdGlvbmAgZWxlbWVudHMgYW5kIHNldHMgdXAgdGhlIHByb3BlciBhcmlhIGF0dHJpYnV0ZXNcbiAqIGZvciB0aGUgbGlzdC5cbiAqXG4gKiBAc2VlIERvY3MgaHR0cHM6Ly9yZWFjaC50ZWNoL2NvbWJvYm94I2NvbWJvYm94bGlzdFxuICovXG5leHBvcnQgY29uc3QgQ29tYm9ib3hMaXN0ID0gZm9yd2FyZFJlZldpdGhBczxDb21ib2JveExpc3RQcm9wcywgXCJ1bFwiPihcbiAgZnVuY3Rpb24gQ29tYm9ib3hMaXN0KFxuICAgIHtcbiAgICAgIC8vIHdoZW4gdHJ1ZSwgYW5kIHRoZSBsaXN0IG9wZW5zIGFnYWluLCB0aGUgb3B0aW9uIHdpdGggYSBtYXRjaGluZyB2YWx1ZVxuICAgICAgLy8gd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGhpZ2hsaWdodGVkLlxuICAgICAgcGVyc2lzdFNlbGVjdGlvbiA9IGZhbHNlLFxuICAgICAgYXM6IENvbXAgPSBcInVsXCIsXG4gICAgICAuLi5wcm9wc1xuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkge1xuICAgIGNvbnN0IHsgcGVyc2lzdFNlbGVjdGlvblJlZiwgbGlzdGJveElkIH0gPSBSZWFjdC51c2VDb250ZXh0KFxuICAgICAgQ29tYm9ib3hDb250ZXh0XG4gICAgKTtcblxuICAgIGlmIChwZXJzaXN0U2VsZWN0aW9uKSB7XG4gICAgICBwZXJzaXN0U2VsZWN0aW9uUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8Q29tcFxuICAgICAgICByb2xlPVwibGlzdGJveFwiXG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgcmVmPXtmb3J3YXJkZWRSZWZ9XG4gICAgICAgIGRhdGEtcmVhY2gtY29tYm9ib3gtbGlzdD1cIlwiXG4gICAgICAgIGlkPXtsaXN0Ym94SWR9XG4gICAgICAvPlxuICAgICk7XG4gIH1cbik7XG5cbi8qKlxuICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveGxpc3QtcHJvcHNcbiAqL1xuZXhwb3J0IHR5cGUgQ29tYm9ib3hMaXN0UHJvcHMgPSB7XG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBmYWxzZS4gV2hlbiB0cnVlIGFuZCB0aGUgbGlzdCBpcyBvcGVuZWQsIGlmIGFuIG9wdGlvbidzIHZhbHVlXG4gICAqIG1hdGNoZXMgdGhlIHZhbHVlIGluIHRoZSBpbnB1dCwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGhpZ2hsaWdodGVkIGFuZFxuICAgKiBiZSB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIGFueSBrZXlib2FyZCBuYXZpZ2F0aW9uIG9mIHRoZSBsaXN0LlxuICAgKlxuICAgKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJlYXQgYSBDb21ib2JveCBtb3JlIGxpa2UgYSBgPHNlbGVjdD5gIHRoYW4gYW5cbiAgICogYDxpbnB1dC8+YCwgYnV0IGJlIG1pbmRmdWwgdGhhdCB0aGUgdXNlciBpcyBzdGlsbCBhYmxlIHRvIHB1dCBhbnlcbiAgICogYXJiaXRyYXJ5IHZhbHVlIGludG8gdGhlIGlucHV0LCBzbyBpZiB0aGUgb25seSB2YWxpZCB2YWx1ZXMgZm9yIHRoZSBpbnB1dFxuICAgKiBhcmUgZnJvbSB0aGUgbGlzdCwgeW91ciBhcHAgd2lsbCBuZWVkIHRvIGRvIHRoYXQgdmFsaWRhdGlvbiBvbiBibHVyIG9yXG4gICAqIHN1Ym1pdCBvZiB0aGUgZm9ybS5cbiAgICpcbiAgICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveGxpc3QtcGVyc2lzdHNlbGVjdGlvblxuICAgKi9cbiAgcGVyc2lzdFNlbGVjdGlvbj86IGJvb2xlYW47XG59O1xuXG5pZiAoX19ERVZfXykge1xuICBDb21ib2JveExpc3QuZGlzcGxheU5hbWUgPSBcIkNvbWJvYm94TGlzdFwiO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENvbWJvYm94T3B0aW9uXG4gKlxuICogQW4gb3B0aW9uIHRoYXQgaXMgc3VnZ2VzdGVkIHRvIHRoZSB1c2VyIGFzIHRoZXkgaW50ZXJhY3Qgd2l0aCB0aGUgY29tYm9ib3guXG4gKlxuICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveG9wdGlvblxuICovXG5leHBvcnQgY29uc3QgQ29tYm9ib3hPcHRpb24gPSBmb3J3YXJkUmVmV2l0aEFzPENvbWJvYm94T3B0aW9uUHJvcHMsIFwibGlcIj4oXG4gIGZ1bmN0aW9uIENvbWJvYm94T3B0aW9uKFxuICAgIHsgYXM6IENvbXAgPSBcImxpXCIsIGNoaWxkcmVuLCB2YWx1ZSwgb25DbGljaywgLi4ucHJvcHMgfSxcbiAgICBmb3J3YXJkZWRSZWY6IFJlYWN0LlJlZjxhbnk+XG4gICkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uU2VsZWN0LFxuICAgICAgZGF0YTogeyBuYXZpZ2F0aW9uVmFsdWUgfSxcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgfSA9IFJlYWN0LnVzZUNvbnRleHQoQ29tYm9ib3hDb250ZXh0KTtcblxuICAgIGxldCBvd25SZWYgPSBSZWFjdC51c2VSZWY8SFRNTEVsZW1lbnQgfCBudWxsPihudWxsKTtcbiAgICBsZXQgcmVmID0gdXNlRm9ya2VkUmVmKGZvcndhcmRlZFJlZiwgb3duUmVmKTtcblxuICAgIGxldCBpbmRleCA9IHVzZURlc2NlbmRhbnQoXG4gICAgICB7XG4gICAgICAgIGVsZW1lbnQ6IG93blJlZi5jdXJyZW50ISxcbiAgICAgICAgdmFsdWUsXG4gICAgICB9LFxuICAgICAgQ29tYm9ib3hEZXNjZW5kYW50Q29udGV4dFxuICAgICk7XG5cbiAgICBjb25zdCBpc0FjdGl2ZSA9IG5hdmlnYXRpb25WYWx1ZSA9PT0gdmFsdWU7XG5cbiAgICBjb25zdCBoYW5kbGVDbGljayA9ICgpID0+IHtcbiAgICAgIG9uU2VsZWN0ICYmIG9uU2VsZWN0KHZhbHVlKTtcbiAgICAgIHRyYW5zaXRpb24oU0VMRUNUX1dJVEhfQ0xJQ0ssIHsgdmFsdWUgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICA8T3B0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17eyB2YWx1ZSwgaW5kZXggfX0+XG4gICAgICAgIDxDb21wXG4gICAgICAgICAgYXJpYS1zZWxlY3RlZD17aXNBY3RpdmV9XG4gICAgICAgICAgcm9sZT1cIm9wdGlvblwiXG4gICAgICAgICAgey4uLnByb3BzfVxuICAgICAgICAgIGRhdGEtcmVhY2gtY29tYm9ib3gtb3B0aW9uPVwiXCJcbiAgICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgICBpZD17U3RyaW5nKG1ha2VIYXNoKHZhbHVlKSl9XG4gICAgICAgICAgZGF0YS1oaWdobGlnaHRlZD17aXNBY3RpdmUgPyBcIlwiIDogdW5kZWZpbmVkfVxuICAgICAgICAgIC8vIFdpdGhvdXQgdGhpcyB0aGUgbWVudSB3aWxsIGNsb3NlIGZyb20gYG9uQmx1cmAsIGJ1dCB3aXRoIGl0IHRoZVxuICAgICAgICAgIC8vIGVsZW1lbnQgY2FuIGJlIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBhbmQgdGhlbiBvdXIgZm9jdXMgY2hlY2tzIGluXG4gICAgICAgICAgLy8gb25CbHVyIHdpbGwgd29yayBhcyBpbnRlbmRlZFxuICAgICAgICAgIHRhYkluZGV4PXstMX1cbiAgICAgICAgICBvbkNsaWNrPXt3cmFwRXZlbnQob25DbGljaywgaGFuZGxlQ2xpY2spfVxuICAgICAgICAgIGNoaWxkcmVuPXtjaGlsZHJlbiB8fCA8Q29tYm9ib3hPcHRpb25UZXh0IC8+fVxuICAgICAgICAvPlxuICAgICAgPC9PcHRpb25Db250ZXh0LlByb3ZpZGVyPlxuICAgICk7XG4gIH1cbik7XG5cbi8qKlxuICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveG9wdGlvbi1wcm9wc1xuICovXG5leHBvcnQgdHlwZSBDb21ib2JveE9wdGlvblByb3BzID0ge1xuICAvKipcbiAgICogT3B0aW9uYWwuIElmIG9taXR0ZWQsIHRoZSBgdmFsdWVgIHdpbGwgYmUgdXNlZCBhcyB0aGUgY2hpbGRyZW4gbGlrZSBhczpcbiAgICogYDxDb21ib2JveE9wdGlvbiB2YWx1ZT1cIlNlYXR0bGUsIFRhY29tYSwgV2FzaGluZ3RvblwiIC8+YC4gQnV0IGlmIHlvdSBuZWVkXG4gICAqIHRvIGNvbnRyb2wgYSBiaXQgbW9yZSwgeW91IGNhbiBwdXQgd2hhdGV2ZXIgY2hpbGRyZW4geW91IHdhbnQsIGJ1dCBtYWtlXG4gICAqIHN1cmUgdG8gcmVuZGVyIGEgYENvbWJvYm94T3B0aW9uVGV4dGAgYXMgd2VsbCwgc28gdGhlIHZhbHVlIGlzIHN0aWxsXG4gICAqIGRpc3BsYXllZCB3aXRoIHRoZSB0ZXh0IGhpZ2hsaWdodGluZyBvbiB0aGUgbWF0Y2hlZCBwb3J0aW9ucy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICA8Q29tYm9ib3hPcHRpb24gdmFsdWU9XCJBcHBsZVwiIC8+XG4gICAqICAgICDwn42OIDxDb21ib2JveE9wdGlvblRleHQgLz5cbiAgICogICA8L0NvbWJvYm94T3B0aW9uPlxuICAgKlxuICAgKiBAc2VlIERvY3MgaHR0cHM6Ly9yZWFjaC50ZWNoL2NvbWJvYm94I2NvbWJvYm94b3B0aW9uLWNoaWxkcmVuXG4gICAqL1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSB0byBtYXRjaCBhZ2FpbnN0IHdoZW4gc3VnZ2VzdGluZy5cbiAgICpcbiAgICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9jb21ib2JveCNjb21ib2JveG9wdGlvbi12YWx1ZVxuICAgKi9cbiAgdmFsdWU6IHN0cmluZztcbn07XG5cbmlmIChfX0RFVl9fKSB7XG4gIENvbWJvYm94T3B0aW9uLmRpc3BsYXlOYW1lID0gXCJDb21ib2JveE9wdGlvblwiO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENvbWJvYm94T3B0aW9uVGV4dFxuICpcbiAqIFJlbmRlcnMgdGhlIHZhbHVlIG9mIGEgYENvbWJvYm94T3B0aW9uYCBhcyB0ZXh0IGJ1dCB3aXRoIHNwYW5zIHdyYXBwaW5nIHRoZVxuICogbWF0Y2hpbmcgYW5kIG5vbi1tYXRjaGluZyBzZWdtZW50cyBvZiB0ZXh0LlxuICpcbiAqIFdlIGRvbid0IGZvcndhcmRSZWYgb3Igc3ByZWFkIHByb3BzIGJlY2F1c2Ugd2UgcmVuZGVyIG11bHRpcGxlIHNwYW5zIG9yIG51bGwsXG4gKiBzaG91bGQgYmUgZmluZSDwn6SZXG4gKlxuICogQGV4YW1wbGVcbiAqICAgPENvbWJvYm94T3B0aW9uIHZhbHVlPVwiU2VhdHRsZVwiPlxuICogICAgIPCfjKcgPENvbWJvYm94T3B0aW9uVGV4dCAvPlxuICogICA8L0NvbWJvYm94T3B0aW9uPlxuICpcbiAqIEBzZWUgRG9jcyBodHRwczovL3JlYWNoLnRlY2gvY29tYm9ib3gjY29tYm9ib3hvcHRpb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBDb21ib2JveE9wdGlvblRleHQoKSB7XG4gIGNvbnN0IHsgdmFsdWUgfSA9IFJlYWN0LnVzZUNvbnRleHQoT3B0aW9uQ29udGV4dCk7XG4gIGNvbnN0IHtcbiAgICBkYXRhOiB7IHZhbHVlOiBjb250ZXh0VmFsdWUgfSxcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoQ29tYm9ib3hDb250ZXh0KTtcblxuICBjb25zdCByZXN1bHRzID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PlxuICAgICAgZmluZEFsbCh7XG4gICAgICAgIHNlYXJjaFdvcmRzOiBlc2NhcGVSZWdleHAoY29udGV4dFZhbHVlIHx8IFwiXCIpLnNwbGl0KC9cXHMrLyksXG4gICAgICAgIHRleHRUb0hpZ2hsaWdodDogdmFsdWUsXG4gICAgICB9KSxcbiAgICBbY29udGV4dFZhbHVlLCB2YWx1ZV1cbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICB7cmVzdWx0cy5sZW5ndGhcbiAgICAgICAgPyByZXN1bHRzLm1hcCgocmVzdWx0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RyID0gdmFsdWUuc2xpY2UocmVzdWx0LnN0YXJ0LCByZXN1bHQuZW5kKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgICBkYXRhLXVzZXItdmFsdWU9e3Jlc3VsdC5oaWdobGlnaHQgPyB0cnVlIDogdW5kZWZpbmVkfVxuICAgICAgICAgICAgICAgIGRhdGEtc3VnZ2VzdGVkLXZhbHVlPXtyZXN1bHQuaGlnaGxpZ2h0ID8gdW5kZWZpbmVkIDogdHJ1ZX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHtzdHJ9XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSlcbiAgICAgICAgOiB2YWx1ZX1cbiAgICA8Lz5cbiAgKTtcbn1cblxuaWYgKF9fREVWX18pIHtcbiAgQ29tYm9ib3hPcHRpb25UZXh0LmRpc3BsYXlOYW1lID0gXCJDb21ib2JveE9wdGlvblRleHRcIjtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDb21ib2JveEJ1dHRvblxuICovXG5leHBvcnQgY29uc3QgQ29tYm9ib3hCdXR0b24gPSBmb3J3YXJkUmVmV2l0aEFzPENvbWJvYm94QnV0dG9uUHJvcHMsIFwiYnV0dG9uXCI+KFxuICBmdW5jdGlvbiBDb21ib2JveEJ1dHRvbihcbiAgICB7IGFzOiBDb21wID0gXCJidXR0b25cIiwgb25DbGljaywgb25LZXlEb3duLCAuLi5wcm9wcyB9LFxuICAgIGZvcndhcmRlZFJlZlxuICApIHtcbiAgICBjb25zdCB7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgc3RhdGUsXG4gICAgICBidXR0b25SZWYsXG4gICAgICBsaXN0Ym94SWQsXG4gICAgICBpc0V4cGFuZGVkLFxuICAgIH0gPSBSZWFjdC51c2VDb250ZXh0KENvbWJvYm94Q29udGV4dCk7XG4gICAgY29uc3QgcmVmID0gdXNlRm9ya2VkUmVmKGJ1dHRvblJlZiwgZm9yd2FyZGVkUmVmKTtcblxuICAgIGNvbnN0IGhhbmRsZUtleURvd24gPSB1c2VLZXlEb3duKCk7XG5cbiAgICBjb25zdCBoYW5kbGVDbGljayA9ICgpID0+IHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gSURMRSkge1xuICAgICAgICB0cmFuc2l0aW9uKE9QRU5fV0lUSF9CVVRUT04pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNpdGlvbihDTE9TRV9XSVRIX0JVVFRPTik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICA8Q29tcFxuICAgICAgICBhcmlhLWNvbnRyb2xzPXtsaXN0Ym94SWR9XG4gICAgICAgIGFyaWEtaGFzcG9wdXA9XCJsaXN0Ym94XCJcbiAgICAgICAgYXJpYS1leHBhbmRlZD17aXNFeHBhbmRlZH1cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgICBkYXRhLXJlYWNoLWNvbWJvYm94LWJ1dHRvbj1cIlwiXG4gICAgICAgIHJlZj17cmVmfVxuICAgICAgICBvbkNsaWNrPXt3cmFwRXZlbnQob25DbGljaywgaGFuZGxlQ2xpY2spfVxuICAgICAgICBvbktleURvd249e3dyYXBFdmVudChvbktleURvd24sIGhhbmRsZUtleURvd24pfVxuICAgICAgLz5cbiAgICApO1xuICB9XG4pO1xuXG5leHBvcnQgdHlwZSBDb21ib2JveEJ1dHRvblByb3BzID0ge307XG5cbmlmIChfX0RFVl9fKSB7XG4gIENvbWJvYm94QnV0dG9uLmRpc3BsYXlOYW1lID0gXCJDb21ib2JveEJ1dHRvblwiO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIE1vdmUgZm9jdXMgYmFjayB0byB0aGUgaW5wdXQgaWYgd2Ugc3RhcnQgbmF2aWdhdGluZyB3LyB0aGVcbiAqIGtleWJvYXJkIGFmdGVyIGZvY3VzIGhhcyBtb3ZlZCB0byBhbnkgZm9jdXNhYmxlIGNvbnRlbnQgaW5cbiAqIHRoZSBwb3B1cC5cbiAqXG4gKiBAcGFyYW0gbGFzdEV2ZW50VHlwZVxuICogQHBhcmFtIGlucHV0UmVmXG4gKi9cbmZ1bmN0aW9uIHVzZUZvY3VzTWFuYWdlbWVudChcbiAgbGFzdEV2ZW50VHlwZTogTWFjaGluZUV2ZW50VHlwZSB8IHVuZGVmaW5lZCxcbiAgaW5wdXRSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8YW55PlxuKSB7XG4gIC8vIHVzZUxheW91dEVmZmVjdCBzbyB0aGF0IHRoZSBjdXJzb3IgZ29lcyB0byB0aGUgZW5kIG9mIHRoZSBpbnB1dCBpbnN0ZWFkXG4gIC8vIG9mIGF3a3dhcmRseSBhdCB0aGUgYmVnaW5uaW5nLCB1bmNsZWFyIHRvIG1lIHdoeSDwn6S34oCN4pmC77iPXG4gIC8vXG4gIC8vIFNob3VsZCBiZSBzYWZlIHRvIHVzZSBoZXJlIHNpbmNlIHdlJ3JlIGp1c3QgZm9jdXNpbmcgYW4gaW5wdXQuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChcbiAgICAgIGxhc3RFdmVudFR5cGUgPT09IE5BVklHQVRFIHx8XG4gICAgICBsYXN0RXZlbnRUeXBlID09PSBFU0NBUEUgfHxcbiAgICAgIGxhc3RFdmVudFR5cGUgPT09IFNFTEVDVF9XSVRIX0NMSUNLIHx8XG4gICAgICBsYXN0RXZlbnRUeXBlID09PSBPUEVOX1dJVEhfQlVUVE9OXG4gICAgKSB7XG4gICAgICBpbnB1dFJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgfVxuICB9LCBbaW5wdXRSZWYsIGxhc3RFdmVudFR5cGVdKTtcbn1cblxuLyoqXG4gKiBXZSB3YW50IHRoZSBzYW1lIGV2ZW50cyB3aGVuIHRoZSBpbnB1dCBvciB0aGUgcG9wdXAgaGF2ZSBmb2N1cyAoSE9XIENPT0wgQVJFXG4gKiBIT09LUyBCVFc/KSBUaGlzIGlzIHByb2JhYmx5IHRoZSBoYWlyaWVzdCBwaWVjZSBidXQgaXQncyBub3QgYmFkLlxuICovXG5mdW5jdGlvbiB1c2VLZXlEb3duKCkge1xuICBjb25zdCB7XG4gICAgZGF0YTogeyBuYXZpZ2F0aW9uVmFsdWUgfSxcbiAgICBvblNlbGVjdCxcbiAgICBzdGF0ZSxcbiAgICB0cmFuc2l0aW9uLFxuICAgIGF1dG9jb21wbGV0ZVByb3BSZWYsXG4gICAgcGVyc2lzdFNlbGVjdGlvblJlZixcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoQ29tYm9ib3hDb250ZXh0KTtcblxuICBjb25zdCBvcHRpb25zID0gdXNlRGVzY2VuZGFudHMoQ29tYm9ib3hEZXNjZW5kYW50Q29udGV4dCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQ6IFJlYWN0LktleWJvYXJkRXZlbnQpIHtcbiAgICBsZXQgaW5kZXggPSBvcHRpb25zLmZpbmRJbmRleCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSA9PT0gbmF2aWdhdGlvblZhbHVlKTtcblxuICAgIGZ1bmN0aW9uIGdldE5leHRPcHRpb24oKSB7XG4gICAgICBsZXQgYXRCb3R0b20gPSBpbmRleCA9PT0gb3B0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgaWYgKGF0Qm90dG9tKSB7XG4gICAgICAgIGlmIChhdXRvY29tcGxldGVQcm9wUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBHbyBiYWNrIHRvIHRoZSB2YWx1ZSB0aGUgdXNlciBoYXMgdHlwZWQgYmVjYXVzZSB3ZSBhcmVcbiAgICAgICAgICAvLyBhdXRvY29tcGxldGluZyBhbmQgdGhleSBuZWVkIHRvIGJlIGFibGUgdG8gZ2V0IGJhY2sgdG8gd2hhdFxuICAgICAgICAgIC8vIHRoZXkgaGFkIHR5cGVkIHcvbyBoYXZpbmcgdG8gYmFja3NwYWNlIG91dC5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjeWNsZSB0aHJvdWdoXG4gICAgICAgICAgcmV0dXJuIGdldEZpcnN0T3B0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEdvIHRvIHRoZSBuZXh0IGl0ZW0gaW4gdGhlIGxpc3RcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNbKGluZGV4ICsgMSkgJSBvcHRpb25zLmxlbmd0aF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJldmlvdXNPcHRpb24oKSB7XG4gICAgICBsZXQgYXRUb3AgPSBpbmRleCA9PT0gMDtcbiAgICAgIGlmIChhdFRvcCkge1xuICAgICAgICBpZiAoYXV0b2NvbXBsZXRlUHJvcFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgLy8gR28gYmFjayB0byB0aGUgdmFsdWUgdGhlIHVzZXIgaGFzIHR5cGVkIGJlY2F1c2Ugd2UgYXJlXG4gICAgICAgICAgLy8gYXV0b2NvbXBsZXRpbmcgYW5kIHRoZXkgbmVlZCB0byBiZSBhYmxlIHRvIGdldCBiYWNrIHRvIHdoYXRcbiAgICAgICAgICAvLyB0aGV5IGhhZCB0eXBlZCB3L28gaGF2aW5nIHRvIGJhY2tzcGFjZSBvdXQuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3ljbGUgdGhyb3VnaFxuICAgICAgICAgIHJldHVybiBnZXRMYXN0T3B0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIC8vIGRpc3BsYXlpbmcgdGhlIHVzZXIncyB2YWx1ZSwgc28gZ28gc2VsZWN0IHRoZSBsYXN0IG9uZVxuICAgICAgICByZXR1cm4gZ2V0TGFzdE9wdGlvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm9ybWFsIGNhc2UsIHNlbGVjdCBwcmV2aW91c1xuICAgICAgICByZXR1cm4gb3B0aW9uc1soaW5kZXggLSAxICsgb3B0aW9ucy5sZW5ndGgpICUgb3B0aW9ucy5sZW5ndGhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEZpcnN0T3B0aW9uKCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnNbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TGFzdE9wdGlvbigpIHtcbiAgICAgIHJldHVybiBvcHRpb25zW29wdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgLy8gRG9uJ3Qgc2Nyb2xsIHRoZSBwYWdlXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUgPT09IElETEUpIHtcbiAgICAgICAgICAvLyBPcGVuaW5nIGEgY2xvc2VkIGxpc3RcbiAgICAgICAgICB0cmFuc2l0aW9uKE5BVklHQVRFLCB7XG4gICAgICAgICAgICBwZXJzaXN0U2VsZWN0aW9uOiBwZXJzaXN0U2VsZWN0aW9uUmVmLmN1cnJlbnQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IG5leHQgPSBnZXROZXh0T3B0aW9uKCk7XG4gICAgICAgICAgdHJhbnNpdGlvbihOQVZJR0FURSwgeyB2YWx1ZTogbmV4dCA/IG5leHQudmFsdWUgOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBBIGxvdCBvZiBkdXBsaWNhdGUgY29kZSB3aXRoIEFycm93RG93biB1cCBuZXh0LCBJJ20gYWxyZWFkeSBvdmVyIGl0LlxuICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgLy8gRG9uJ3Qgc2Nyb2xsIHRoZSBwYWdlXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gSURMRSkge1xuICAgICAgICAgIHRyYW5zaXRpb24oTkFWSUdBVEUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBwcmV2ID0gZ2V0UHJldmlvdXNPcHRpb24oKTtcbiAgICAgICAgICB0cmFuc2l0aW9uKE5BVklHQVRFLCB7IHZhbHVlOiBwcmV2ID8gcHJldi52YWx1ZSA6IG51bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJIb21lXCI6XG4gICAgICBjYXNlIFwiUGFnZVVwXCI6XG4gICAgICAgIC8vIERvbid0IHNjcm9sbCB0aGUgcGFnZVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUgPT09IElETEUpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uKE5BVklHQVRFKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFuc2l0aW9uKE5BVklHQVRFLCB7IHZhbHVlOiBnZXRGaXJzdE9wdGlvbigpLnZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICBjYXNlIFwiUGFnZURvd25cIjpcbiAgICAgICAgLy8gRG9uJ3Qgc2Nyb2xsIHRoZSBwYWdlXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gSURMRSkge1xuICAgICAgICAgIHRyYW5zaXRpb24oTkFWSUdBVEUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYW5zaXRpb24oTkFWSUdBVEUsIHsgdmFsdWU6IGdldExhc3RPcHRpb24oKS52YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIkVzY2FwZVwiOlxuICAgICAgICBpZiAoc3RhdGUgIT09IElETEUpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uKEVTQ0FQRSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgaWYgKHN0YXRlID09PSBOQVZJR0FUSU5HICYmIG5hdmlnYXRpb25WYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIGRvbid0IHdhbnQgdG8gc3VibWl0IGZvcm1zXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBvblNlbGVjdCAmJiBvblNlbGVjdChuYXZpZ2F0aW9uVmFsdWUpO1xuICAgICAgICAgIHRyYW5zaXRpb24oU0VMRUNUX1dJVEhfS0VZQk9BUkQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlQmx1cigpIHtcbiAgY29uc3Qge1xuICAgIHN0YXRlLFxuICAgIHRyYW5zaXRpb24sXG4gICAgcG9wb3ZlclJlZixcbiAgICBpbnB1dFJlZixcbiAgICBidXR0b25SZWYsXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KENvbWJvYm94Q29udGV4dCk7XG4gIGNvbnN0IHJhZklkcyA9IHVzZUxhenlSZWYoKCkgPT4gbmV3IFNldDxudW1iZXI+KCkpO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgIHJhZklkcy5jdXJyZW50LmZvckVhY2goKGlkKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShpZCkpO1xuICAgIH07XG4gIH0sIFtyYWZJZHNdKTtcblxuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlQmx1cigpIHtcbiAgICBjb25zdCBvd25lckRvY3VtZW50ID0gZ2V0T3duZXJEb2N1bWVudChwb3BvdmVyUmVmLmN1cnJlbnQpO1xuICAgIGlmICghb3duZXJEb2N1bWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAvLyB3ZSBvbiB3YW50IHRvIGNsb3NlIG9ubHkgaWYgZm9jdXMgcHJvcHNzIG91dHNpZGUgdGhlIGNvbWJvYm94XG4gICAgICBpZiAoXG4gICAgICAgIG93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gaW5wdXRSZWYuY3VycmVudCAmJlxuICAgICAgICBvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGJ1dHRvblJlZi5jdXJyZW50ICYmXG4gICAgICAgIHBvcG92ZXJSZWYuY3VycmVudFxuICAgICAgKSB7XG4gICAgICAgIGlmIChwb3BvdmVyUmVmLmN1cnJlbnQuY29udGFpbnMob3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgIC8vIGZvY3VzIGxhbmRlZCBpbnNpZGUgdGhlIGNvbWJvYm94LCBrZWVwIGl0IG9wZW5cbiAgICAgICAgICBpZiAoc3RhdGUgIT09IElOVEVSQUNUSU5HKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uKElOVEVSQUNUKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZm9jdXMgbGFuZGVkIG91dHNpZGUgdGhlIGNvbWJvYm94LCBjbG9zZSBpdC5cbiAgICAgICAgICB0cmFuc2l0aW9uKEJMVVIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmFmSWRzLmN1cnJlbnQuYWRkKHJhZklkKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1hbmFnZXMgdHJhbnNpdGlvbnMgYmV0d2VlbiBzdGF0ZXMgd2l0aCBhIGJ1aWx0IGluIHJlZHVjZXIgdG8gbWFuYWdlXG4gKiB0aGUgZGF0YSB0aGF0IGdvZXMgd2l0aCB0aG9zZSB0cmFuc2l0aW9ucy5cbiAqXG4gKiBAcGFyYW0gY2hhcnRcbiAqIEBwYXJhbSByZWR1Y2VyXG4gKiBAcGFyYW0gaW5pdGlhbERhdGFcbiAqL1xuZnVuY3Rpb24gdXNlUmVkdWNlck1hY2hpbmUoXG4gIGNoYXJ0OiBTdGF0ZUNoYXJ0LFxuICByZWR1Y2VyOiBSZWR1Y2VyLFxuICBpbml0aWFsRGF0YTogUGFydGlhbDxTdGF0ZURhdGE+XG4pOiBbU3RhdGUsIFN0YXRlRGF0YSwgVHJhbnNpdGlvbl0ge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKGNoYXJ0LmluaXRpYWwpO1xuICBjb25zdCBbZGF0YSwgZGlzcGF0Y2hdID0gUmVhY3QudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsRGF0YSk7XG5cbiAgY29uc3QgdHJhbnNpdGlvbjogVHJhbnNpdGlvbiA9IChldmVudCwgcGF5bG9hZCA9IHt9KSA9PiB7XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gY2hhcnQuc3RhdGVzW3N0YXRlXTtcbiAgICBjb25zdCBuZXh0U3RhdGUgPSBjdXJyZW50U3RhdGUgJiYgY3VycmVudFN0YXRlLm9uW2V2ZW50XTtcbiAgICBpZiAobmV4dFN0YXRlKSB7XG4gICAgICBkaXNwYXRjaCh7IHR5cGU6IGV2ZW50LCBzdGF0ZSwgbmV4dFN0YXRlOiBzdGF0ZSwgLi4ucGF5bG9hZCB9KTtcbiAgICAgIHNldFN0YXRlKG5leHRTdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBbc3RhdGUsIGRhdGEsIHRyYW5zaXRpb25dO1xufVxuXG4vKipcbiAqIFdlIGRvbid0IHdhbnQgdG8gdHJhY2sgdGhlIGFjdGl2ZSBkZXNjZW5kYW50IHdpdGggaW5kZXhlcyBiZWNhdXNlIG5vdGhpbmcgaXNcbiAqIG1vcmUgYW5ub3lpbmcgaW4gYSBjb21ib2JveCB0aGFuIGhhdmluZyBpdCBjaGFuZ2UgdmFsdWVzIFJJR0hUIEFTIFlPVSBISVRcbiAqIEVOVEVSLiBUaGF0IG9ubHkgaGFwcGVucyBpZiB5b3UgdXNlIHRoZSBpbmRleCBhcyB5b3VyIGRhdGEsIHJhdGhlciB0aGFuXG4gKiAqeW91ciBkYXRhIGFzIHlvdXIgZGF0YSouIFdlIHVzZSB0aGlzIHRvIGdlbmVyYXRlIGEgdW5pcXVlIElEIGJhc2VkIG9uIHRoZVxuICogdmFsdWUgb2YgZWFjaCBpdGVtLiAgVGhpcyBmdW5jdGlvbiBpcyBzaG9ydCwgc3dlZXQsIGFuZCBnb29kIGVub3VnaOKEoiAoSSBhbHNvXG4gKiBkb24ndCBrbm93IGhvdyBpdCB3b3JrcywgdGJxaClcbiAqXG4gKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYxMjI1NzEvc2ltcGxlLW5vbi1zZWN1cmUtaGFzaC1mdW5jdGlvbi1mb3ItamF2YXNjcmlwdFxuICogQHBhcmFtIHN0clxuICovXG5jb25zdCBtYWtlSGFzaCA9IChzdHI6IHN0cmluZykgPT4ge1xuICBsZXQgaGFzaCA9IDA7XG4gIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hhciA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBjaGFyO1xuICAgIGhhc2ggPSBoYXNoICYgaGFzaDtcbiAgfVxuICByZXR1cm4gaGFzaDtcbn07XG5cbi8qKlxuICogRXNjYXBlIHJlZ2V4cCBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gYHN0cmBcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jb21wb25lbnQvZXNjYXBlLXJlZ2V4cC9ibG9iLzVjZTkyM2MxNTEwYzk4MDJiM2RhOTcyYzkwYjY4NjFkZDI4MjliNmIvaW5kZXguanNcbiAqIEBwYXJhbSBzdHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlUmVnZXhwKHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC8oWy4qKz89XiE6JHt9KCl8W1xcXS9cXFxcXSkvZywgXCJcXFxcJDFcIik7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSBob29rIHRoYXQgZXhwb3NlcyBkYXRhIGZvciBhIGdpdmVuIGBDb21ib2JveGAgY29tcG9uZW50IHRvIGl0cyBkZXNjZW5kYW50cy5cbiAqXG4gKiBAc2VlIERvY3MgaHR0cHM6Ly9yZWFjaC50ZWNoL2NvbWJvYm94I3VzZWNvbWJvYm94Y29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29tYm9ib3hDb250ZXh0KCk6IENvbWJvYm94Q29udGV4dFZhbHVlIHtcbiAgbGV0IHsgaXNFeHBhbmRlZCwgY29tYm9ib3hJZCB9ID0gUmVhY3QudXNlQ29udGV4dChDb21ib2JveENvbnRleHQpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgaWQ6IGNvbWJvYm94SWQsXG4gICAgICBpc0V4cGFuZGVkLFxuICAgIH0pLFxuICAgIFtjb21ib2JveElkLCBpc0V4cGFuZGVkXVxuICApO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBXZWxsIGFscmlnaHQsIHlvdSBtYWRlIGl0IGFsbCB0aGUgd2F5IGhlcmUgdG8gbGlrZSAxMTAwIGxpbmVzIG9mIGNvZGUgKGdlZXosXG4vLyB3aGF0IHRoZSBoZWNrPykuIEhhdmUgYSBncmVhdCBkYXkgOkRcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFR5cGVzXG5cbmV4cG9ydCB0eXBlIENvbWJvYm94Q29udGV4dFZhbHVlID0ge1xuICBpZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBpc0V4cGFuZGVkOiBib29sZWFuO1xufTtcblxudHlwZSBDb21ib2JveERlc2NlbmRhbnQgPSBEZXNjZW5kYW50PEhUTUxFbGVtZW50PiAmIHtcbiAgdmFsdWU6IENvbWJvYm94VmFsdWU7XG59O1xuXG5pbnRlcmZhY2UgQ29tYm9ib3hPcHRpb25Db250ZXh0VmFsdWUge1xuICB2YWx1ZTogQ29tYm9ib3hWYWx1ZTtcbiAgaW5kZXg6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEludGVybmFsQ29tYm9ib3hDb250ZXh0VmFsdWUge1xuICBhcmlhTGFiZWw/OiBzdHJpbmc7XG4gIGFyaWFMYWJlbGxlZGJ5Pzogc3RyaW5nO1xuICBhdXRvY29tcGxldGVQcm9wUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PGFueT47XG4gIGJ1dHRvblJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxhbnk+O1xuICBjb21ib2JveElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGRhdGE6IFN0YXRlRGF0YTtcbiAgaW5wdXRSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8YW55PjtcbiAgaXNFeHBhbmRlZDogYm9vbGVhbjtcbiAgbGlzdGJveElkOiBzdHJpbmc7XG4gIG9uU2VsZWN0KHZhbHVlPzogQ29tYm9ib3hWYWx1ZSk6IGFueTtcbiAgb3Blbk9uRm9jdXM6IGJvb2xlYW47XG4gIHBlcnNpc3RTZWxlY3Rpb25SZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8YW55PjtcbiAgcG9wb3ZlclJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxhbnk+O1xuICBzdGF0ZTogU3RhdGU7XG4gIHRyYW5zaXRpb246IFRyYW5zaXRpb247XG59XG5cbnR5cGUgVHJhbnNpdGlvbiA9IChldmVudDogTWFjaGluZUV2ZW50VHlwZSwgcGF5bG9hZD86IGFueSkgPT4gYW55O1xuXG50eXBlIENvbWJvYm94VmFsdWUgPSBzdHJpbmc7XG5cbnR5cGUgU3RhdGUgPSBcIklETEVcIiB8IFwiU1VHR0VTVElOR1wiIHwgXCJOQVZJR0FUSU5HXCIgfCBcIklOVEVSQUNUSU5HXCI7XG5cbnR5cGUgTWFjaGluZUV2ZW50VHlwZSA9XG4gIHwgXCJDTEVBUlwiXG4gIHwgXCJDSEFOR0VcIlxuICB8IFwiSU5JVElBTF9DSEFOR0VcIlxuICB8IFwiTkFWSUdBVEVcIlxuICB8IFwiU0VMRUNUX1dJVEhfS0VZQk9BUkRcIlxuICB8IFwiU0VMRUNUX1dJVEhfQ0xJQ0tcIlxuICB8IFwiRVNDQVBFXCJcbiAgfCBcIkJMVVJcIlxuICB8IFwiSU5URVJBQ1RcIlxuICB8IFwiRk9DVVNcIlxuICB8IFwiT1BFTl9XSVRIX0JVVFRPTlwiXG4gIHwgXCJDTE9TRV9XSVRIX0JVVFRPTlwiO1xuXG5pbnRlcmZhY2UgU3RhdGVDaGFydCB7XG4gIGluaXRpYWw6IFN0YXRlO1xuICBzdGF0ZXM6IHtcbiAgICBba2V5IGluIFN0YXRlXT86IHtcbiAgICAgIG9uOiB7XG4gICAgICAgIFtrZXkgaW4gTWFjaGluZUV2ZW50VHlwZV0/OiBTdGF0ZTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn1cblxudHlwZSBTdGF0ZURhdGEgPSB7XG4gIGxhc3RFdmVudFR5cGU/OiBNYWNoaW5lRXZlbnRUeXBlO1xuICBuYXZpZ2F0aW9uVmFsdWU/OiBDb21ib2JveFZhbHVlIHwgbnVsbDtcbiAgdmFsdWU/OiBDb21ib2JveFZhbHVlIHwgbnVsbDtcbn07XG5cbnR5cGUgTWFjaGluZUV2ZW50ID1cbiAgfCB7IHR5cGU6IFwiQkxVUlwiIH1cbiAgfCB7IHR5cGU6IFwiQ0hBTkdFXCI7IHZhbHVlOiBDb21ib2JveFZhbHVlIH1cbiAgfCB7IHR5cGU6IFwiSU5JVElBTF9DSEFOR0VcIjsgdmFsdWU6IENvbWJvYm94VmFsdWUgfVxuICB8IHsgdHlwZTogXCJDTEVBUlwiIH1cbiAgfCB7IHR5cGU6IFwiQ0xPU0VfV0lUSF9CVVRUT05cIiB9XG4gIHwgeyB0eXBlOiBcIkVTQ0FQRVwiIH1cbiAgfCB7IHR5cGU6IFwiRk9DVVNcIiB9XG4gIHwgeyB0eXBlOiBcIklOVEVSQUNUXCIgfVxuICB8IHtcbiAgICAgIHR5cGU6IFwiTkFWSUdBVEVcIjtcbiAgICAgIHBlcnNpc3RTZWxlY3Rpb24/OiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PGFueT47XG4gICAgICB2YWx1ZTogQ29tYm9ib3hWYWx1ZTtcbiAgICB9XG4gIHwgeyB0eXBlOiBcIk9QRU5fV0lUSF9CVVRUT05cIiB9XG4gIHwge1xuICAgICAgdHlwZTogXCJTRUxFQ1RfV0lUSF9DTElDS1wiO1xuICAgICAgdmFsdWU6IENvbWJvYm94VmFsdWU7XG4gICAgfVxuICB8IHtcbiAgICAgIHR5cGU6IFwiU0VMRUNUX1dJVEhfS0VZQk9BUkRcIjtcbiAgICB9O1xuXG50eXBlIFJlZHVjZXIgPSAoZGF0YTogU3RhdGVEYXRhLCBldmVudDogTWFjaGluZUV2ZW50KSA9PiBTdGF0ZURhdGE7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtREE7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQURBO0FBWUE7QUFEQTtBQWNBO0FBREE7QUFlQTtBQURBO0FBekNBO0FBQ0E7QUF1REE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUhBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUhBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUhBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUhBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFGQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFwREE7QUFGQTtBQUNBO0FBeURBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU1BOzs7Ozs7QUFLQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFrQkE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQWhGQTtBQUNBO0FBMkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUdBOzs7Ozs7Ozs7QUFPQTtBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFjQTtBQVZBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBRUE7QUFDQTtBQURBO0FBTUE7QUFBQTtBQUFBO0FBSkE7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQVhBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFYQTtBQWVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBR0E7QUFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU0E7QUFDQTtBQVZBO0FBV0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBcklBO0FBQ0E7QUFxTEE7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7Ozs7Ozs7QUFTQTtBQUtBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFjQTtBQUVBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFIQTtBQU9BO0FBQUE7QUE5Q0E7QUFDQTtBQWlEQTtBQUNBO0FBQ0E7QUFDQTtBQWtCQTs7Ozs7Ozs7OztBQVFBO0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUhBO0FBdEJBO0FBQ0E7QUFrREE7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7Ozs7O0FBT0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBSEE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRkE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBbENBO0FBQ0E7QUE2RUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFEQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUZBO0FBU0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFKQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7QUFHQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVFBO0FBTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFBQTtBQUdBO0FBSEE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUpBO0FBN0JBO0FBQ0E7QUF3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7Ozs7OztBQVFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQVJBO0FBVUE7QUFFQTs7Ozs7O0FBSUE7QUFRQTtBQU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBN0VBO0FBbERBO0FBa0lBO0FBQ0E7QUFDQTtBQU9BO0FBTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFrQkE7QUF4QkE7QUEwQkE7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVZBO0FBYUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7OztBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFPQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@reach/combobox/dist/combobox.esm.js\n");

/***/ }),

/***/ "../node_modules/@reach/combobox/node_modules/@reach/auto-id/dist/auto-id.esm.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@reach/combobox/node_modules/@reach/auto-id/dist/auto-id.esm.js ***!
  \***************************************************************************************/
/*! exports provided: useId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useId\", function() { return useId; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _reach_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reach/utils */ \"../node_modules/@reach/utils/dist/utils.esm.js\");\n\n\n/*\r\n * Welcome to @reach/auto-id!\r\n\n * Let's see if we can make sense of why this hook exists and its\r\n * implementation.\r\n *\r\n * Some background:\r\n *   1. Accessibiliy APIs rely heavily on element IDs\r\n *   2. Requiring developers to put IDs on every element in Reach UI is both\r\n *      cumbersome and error-prone\r\n *   3. With a component model, we can generate IDs for them!\r\n *\r\n * Solution 1: Generate random IDs.\r\n *\r\n * This works great as long as you don't server render your app. When React (in\r\n * the client) tries to reuse the markup from the server, the IDs won't match\r\n * and React will then recreate the entire DOM tree.\r\n *\r\n * Solution 2: Increment an integer\r\n *\r\n * This sounds great. Since we're rendering the exact same tree on the server\r\n * and client, we can increment a counter and get a deterministic result between\r\n * client and server. Also, JS integers can go up to nine-quadrillion. I'm\r\n * pretty sure the tab will be closed before an app never needs\r\n * 10 quadrillion IDs!\r\n *\r\n * Problem solved, right?\r\n *\r\n * Ah, but there's a catch! React's concurrent rendering makes this approach\r\n * non-deterministic. While the client and server will end up with the same\r\n * elements in the end, depending on suspense boundaries (and possibly some user\r\n * input during the initial render) the incrementing integers won't always match\r\n * up.\r\n *\r\n * Solution 3: Don't use IDs at all on the server; patch after first render.\r\n *\r\n * What we've done here is solution 2 with some tricks. With this approach, the\r\n * ID returned is an empty string on the first render. This way the server and\r\n * client have the same markup no matter how wild the concurrent rendering may\r\n * have gotten.\r\n *\r\n * After the render, we patch up the components with an incremented ID. This\r\n * causes a double render on any components with `useId`. Shouldn't be a problem\r\n * since the components using this hook should be small, and we're only updating\r\n * the ID attribute on the DOM, nothing big is happening.\r\n *\r\n * It doesn't have to be an incremented number, though--we could do generate\r\n * random strings instead, but incrementing a number is probably the cheapest\r\n * thing we can do.\r\n *\r\n * Additionally, we only do this patchup on the very first client render ever.\r\n * Any calls to `useId` that happen dynamically in the client will be\r\n * populated immediately with a value. So, we only get the double render after\r\n * server hydration and never again, SO BACK OFF ALRIGHT?\r\n */\n\nvar serverHandoffComplete = false;\nvar id = 0;\n\nvar genId = function genId() {\n  return ++id;\n};\n/**\r\n * useId\r\n *\r\n * Autogenerate IDs to facilitate WAI-ARIA and server rendering.\r\n *\r\n * Note: The returned ID will initially be `null` and will update after a\r\n * component mounts. Users may need to supply their own ID if they need\r\n * consistent values for SSR.\r\n *\r\n * @see Docs https://reach.tech/auto-id\r\n */\n\n\nfunction useId(idFromProps) {\n  /*\r\n   * If this instance isn't part of the initial render, we don't have to do the\r\n   * double render/patch-up dance. We can just generate the ID and return it.\r\n   */\n  var initialId = idFromProps || (serverHandoffComplete ? genId() : null);\n\n  var _React$useState = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(initialId),\n      id = _React$useState[0],\n      setId = _React$useState[1];\n\n  Object(_reach_utils__WEBPACK_IMPORTED_MODULE_1__[\"useIsomorphicLayoutEffect\"])(function () {\n    if (id === null) {\n      /*\r\n       * Patch the ID after render. We do this in `useLayoutEffect` to avoid any\r\n       * rendering flicker, though it'll make the first render slower (unlikely\r\n       * to matter, but you're welcome to measure your app and let us know if\r\n       * it's a problem).\r\n       */\n      setId(genId());\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n    if (serverHandoffComplete === false) {\n      /*\r\n       * Flag all future uses of `useId` to skip the update dance. This is in\r\n       * `useEffect` because it goes after `useLayoutEffect`, ensuring we don't\r\n       * accidentally bail out of the patch-up dance prematurely.\r\n       */\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id != null ? String(id) : undefined;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0ByZWFjaC9jb21ib2JveC9ub2RlX21vZHVsZXMvQHJlYWNoL2F1dG8taWQvZGlzdC9hdXRvLWlkLmVzbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zcmMvaW5kZXgudHN4P2RlYjciXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIFdlbGNvbWUgdG8gQHJlYWNoL2F1dG8taWQhXG5cbiAqIExldCdzIHNlZSBpZiB3ZSBjYW4gbWFrZSBzZW5zZSBvZiB3aHkgdGhpcyBob29rIGV4aXN0cyBhbmQgaXRzXG4gKiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBTb21lIGJhY2tncm91bmQ6XG4gKiAgIDEuIEFjY2Vzc2liaWxpeSBBUElzIHJlbHkgaGVhdmlseSBvbiBlbGVtZW50IElEc1xuICogICAyLiBSZXF1aXJpbmcgZGV2ZWxvcGVycyB0byBwdXQgSURzIG9uIGV2ZXJ5IGVsZW1lbnQgaW4gUmVhY2ggVUkgaXMgYm90aFxuICogICAgICBjdW1iZXJzb21lIGFuZCBlcnJvci1wcm9uZVxuICogICAzLiBXaXRoIGEgY29tcG9uZW50IG1vZGVsLCB3ZSBjYW4gZ2VuZXJhdGUgSURzIGZvciB0aGVtIVxuICpcbiAqIFNvbHV0aW9uIDE6IEdlbmVyYXRlIHJhbmRvbSBJRHMuXG4gKlxuICogVGhpcyB3b3JrcyBncmVhdCBhcyBsb25nIGFzIHlvdSBkb24ndCBzZXJ2ZXIgcmVuZGVyIHlvdXIgYXBwLiBXaGVuIFJlYWN0IChpblxuICogdGhlIGNsaWVudCkgdHJpZXMgdG8gcmV1c2UgdGhlIG1hcmt1cCBmcm9tIHRoZSBzZXJ2ZXIsIHRoZSBJRHMgd29uJ3QgbWF0Y2hcbiAqIGFuZCBSZWFjdCB3aWxsIHRoZW4gcmVjcmVhdGUgdGhlIGVudGlyZSBET00gdHJlZS5cbiAqXG4gKiBTb2x1dGlvbiAyOiBJbmNyZW1lbnQgYW4gaW50ZWdlclxuICpcbiAqIFRoaXMgc291bmRzIGdyZWF0LiBTaW5jZSB3ZSdyZSByZW5kZXJpbmcgdGhlIGV4YWN0IHNhbWUgdHJlZSBvbiB0aGUgc2VydmVyXG4gKiBhbmQgY2xpZW50LCB3ZSBjYW4gaW5jcmVtZW50IGEgY291bnRlciBhbmQgZ2V0IGEgZGV0ZXJtaW5pc3RpYyByZXN1bHQgYmV0d2VlblxuICogY2xpZW50IGFuZCBzZXJ2ZXIuIEFsc28sIEpTIGludGVnZXJzIGNhbiBnbyB1cCB0byBuaW5lLXF1YWRyaWxsaW9uLiBJJ21cbiAqIHByZXR0eSBzdXJlIHRoZSB0YWIgd2lsbCBiZSBjbG9zZWQgYmVmb3JlIGFuIGFwcCBuZXZlciBuZWVkc1xuICogMTAgcXVhZHJpbGxpb24gSURzIVxuICpcbiAqIFByb2JsZW0gc29sdmVkLCByaWdodD9cbiAqXG4gKiBBaCwgYnV0IHRoZXJlJ3MgYSBjYXRjaCEgUmVhY3QncyBjb25jdXJyZW50IHJlbmRlcmluZyBtYWtlcyB0aGlzIGFwcHJvYWNoXG4gKiBub24tZGV0ZXJtaW5pc3RpYy4gV2hpbGUgdGhlIGNsaWVudCBhbmQgc2VydmVyIHdpbGwgZW5kIHVwIHdpdGggdGhlIHNhbWVcbiAqIGVsZW1lbnRzIGluIHRoZSBlbmQsIGRlcGVuZGluZyBvbiBzdXNwZW5zZSBib3VuZGFyaWVzIChhbmQgcG9zc2libHkgc29tZSB1c2VyXG4gKiBpbnB1dCBkdXJpbmcgdGhlIGluaXRpYWwgcmVuZGVyKSB0aGUgaW5jcmVtZW50aW5nIGludGVnZXJzIHdvbid0IGFsd2F5cyBtYXRjaFxuICogdXAuXG4gKlxuICogU29sdXRpb24gMzogRG9uJ3QgdXNlIElEcyBhdCBhbGwgb24gdGhlIHNlcnZlcjsgcGF0Y2ggYWZ0ZXIgZmlyc3QgcmVuZGVyLlxuICpcbiAqIFdoYXQgd2UndmUgZG9uZSBoZXJlIGlzIHNvbHV0aW9uIDIgd2l0aCBzb21lIHRyaWNrcy4gV2l0aCB0aGlzIGFwcHJvYWNoLCB0aGVcbiAqIElEIHJldHVybmVkIGlzIGFuIGVtcHR5IHN0cmluZyBvbiB0aGUgZmlyc3QgcmVuZGVyLiBUaGlzIHdheSB0aGUgc2VydmVyIGFuZFxuICogY2xpZW50IGhhdmUgdGhlIHNhbWUgbWFya3VwIG5vIG1hdHRlciBob3cgd2lsZCB0aGUgY29uY3VycmVudCByZW5kZXJpbmcgbWF5XG4gKiBoYXZlIGdvdHRlbi5cbiAqXG4gKiBBZnRlciB0aGUgcmVuZGVyLCB3ZSBwYXRjaCB1cCB0aGUgY29tcG9uZW50cyB3aXRoIGFuIGluY3JlbWVudGVkIElELiBUaGlzXG4gKiBjYXVzZXMgYSBkb3VibGUgcmVuZGVyIG9uIGFueSBjb21wb25lbnRzIHdpdGggYHVzZUlkYC4gU2hvdWxkbid0IGJlIGEgcHJvYmxlbVxuICogc2luY2UgdGhlIGNvbXBvbmVudHMgdXNpbmcgdGhpcyBob29rIHNob3VsZCBiZSBzbWFsbCwgYW5kIHdlJ3JlIG9ubHkgdXBkYXRpbmdcbiAqIHRoZSBJRCBhdHRyaWJ1dGUgb24gdGhlIERPTSwgbm90aGluZyBiaWcgaXMgaGFwcGVuaW5nLlxuICpcbiAqIEl0IGRvZXNuJ3QgaGF2ZSB0byBiZSBhbiBpbmNyZW1lbnRlZCBudW1iZXIsIHRob3VnaC0td2UgY291bGQgZG8gZ2VuZXJhdGVcbiAqIHJhbmRvbSBzdHJpbmdzIGluc3RlYWQsIGJ1dCBpbmNyZW1lbnRpbmcgYSBudW1iZXIgaXMgcHJvYmFibHkgdGhlIGNoZWFwZXN0XG4gKiB0aGluZyB3ZSBjYW4gZG8uXG4gKlxuICogQWRkaXRpb25hbGx5LCB3ZSBvbmx5IGRvIHRoaXMgcGF0Y2h1cCBvbiB0aGUgdmVyeSBmaXJzdCBjbGllbnQgcmVuZGVyIGV2ZXIuXG4gKiBBbnkgY2FsbHMgdG8gYHVzZUlkYCB0aGF0IGhhcHBlbiBkeW5hbWljYWxseSBpbiB0aGUgY2xpZW50IHdpbGwgYmVcbiAqIHBvcHVsYXRlZCBpbW1lZGlhdGVseSB3aXRoIGEgdmFsdWUuIFNvLCB3ZSBvbmx5IGdldCB0aGUgZG91YmxlIHJlbmRlciBhZnRlclxuICogc2VydmVyIGh5ZHJhdGlvbiBhbmQgbmV2ZXIgYWdhaW4sIFNPIEJBQ0sgT0ZGIEFMUklHSFQ/XG4gKi9cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IH0gZnJvbSBcIkByZWFjaC91dGlsc1wiO1xuXG5sZXQgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gZmFsc2U7XG5sZXQgaWQgPSAwO1xuY29uc3QgZ2VuSWQgPSAoKSA9PiArK2lkO1xuXG4vKipcbiAqIHVzZUlkXG4gKlxuICogQXV0b2dlbmVyYXRlIElEcyB0byBmYWNpbGl0YXRlIFdBSS1BUklBIGFuZCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICpcbiAqIE5vdGU6IFRoZSByZXR1cm5lZCBJRCB3aWxsIGluaXRpYWxseSBiZSBgbnVsbGAgYW5kIHdpbGwgdXBkYXRlIGFmdGVyIGFcbiAqIGNvbXBvbmVudCBtb3VudHMuIFVzZXJzIG1heSBuZWVkIHRvIHN1cHBseSB0aGVpciBvd24gSUQgaWYgdGhleSBuZWVkXG4gKiBjb25zaXN0ZW50IHZhbHVlcyBmb3IgU1NSLlxuICpcbiAqIEBzZWUgRG9jcyBodHRwczovL3JlYWNoLnRlY2gvYXV0by1pZFxuICovXG5mdW5jdGlvbiB1c2VJZChpZEZyb21Qcm9wcz86IHN0cmluZyB8IG51bGwpIHtcbiAgLypcbiAgICogSWYgdGhpcyBpbnN0YW5jZSBpc24ndCBwYXJ0IG9mIHRoZSBpbml0aWFsIHJlbmRlciwgd2UgZG9uJ3QgaGF2ZSB0byBkbyB0aGVcbiAgICogZG91YmxlIHJlbmRlci9wYXRjaC11cCBkYW5jZS4gV2UgY2FuIGp1c3QgZ2VuZXJhdGUgdGhlIElEIGFuZCByZXR1cm4gaXQuXG4gICAqL1xuICBjb25zdCBpbml0aWFsSWQgPSBpZEZyb21Qcm9wcyB8fCAoc2VydmVySGFuZG9mZkNvbXBsZXRlID8gZ2VuSWQoKSA6IG51bGwpO1xuXG4gIGNvbnN0IFtpZCwgc2V0SWRdID0gUmVhY3QudXNlU3RhdGUoaW5pdGlhbElkKTtcblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgIC8qXG4gICAgICAgKiBQYXRjaCB0aGUgSUQgYWZ0ZXIgcmVuZGVyLiBXZSBkbyB0aGlzIGluIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGF2b2lkIGFueVxuICAgICAgICogcmVuZGVyaW5nIGZsaWNrZXIsIHRob3VnaCBpdCdsbCBtYWtlIHRoZSBmaXJzdCByZW5kZXIgc2xvd2VyICh1bmxpa2VseVxuICAgICAgICogdG8gbWF0dGVyLCBidXQgeW91J3JlIHdlbGNvbWUgdG8gbWVhc3VyZSB5b3VyIGFwcCBhbmQgbGV0IHVzIGtub3cgaWZcbiAgICAgICAqIGl0J3MgYSBwcm9ibGVtKS5cbiAgICAgICAqL1xuICAgICAgc2V0SWQoZ2VuSWQoKSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHNlcnZlckhhbmRvZmZDb21wbGV0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIC8qXG4gICAgICAgKiBGbGFnIGFsbCBmdXR1cmUgdXNlcyBvZiBgdXNlSWRgIHRvIHNraXAgdGhlIHVwZGF0ZSBkYW5jZS4gVGhpcyBpcyBpblxuICAgICAgICogYHVzZUVmZmVjdGAgYmVjYXVzZSBpdCBnb2VzIGFmdGVyIGB1c2VMYXlvdXRFZmZlY3RgLCBlbnN1cmluZyB3ZSBkb24ndFxuICAgICAgICogYWNjaWRlbnRhbGx5IGJhaWwgb3V0IG9mIHRoZSBwYXRjaC11cCBkYW5jZSBwcmVtYXR1cmVseS5cbiAgICAgICAqL1xuICAgICAgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGlkICE9IG51bGwgPyBTdHJpbmcoaWQpIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgeyB1c2VJZCB9O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkRBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFSQTtBQUNBO0FBREE7QUFhQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@reach/combobox/node_modules/@reach/auto-id/dist/auto-id.esm.js\n");

/***/ }),

/***/ "../node_modules/@reach/descendants/dist/descendants.esm.js":
/*!******************************************************************!*\
  !*** ../node_modules/@reach/descendants/dist/descendants.esm.js ***!
  \******************************************************************/
/*! exports provided: DescendantProvider, createDescendantContext, useDescendant, useDescendantKeyDown, useDescendants, useDescendantsInit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DescendantProvider\", function() { return DescendantProvider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createDescendantContext\", function() { return createDescendantContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useDescendant\", function() { return useDescendant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useDescendantKeyDown\", function() { return useDescendantKeyDown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useDescendants\", function() { return useDescendants; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useDescendantsInit\", function() { return useDescendantsInit; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _reach_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reach/utils */ \"../node_modules/@reach/utils/dist/utils.esm.js\");\n\n\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction createDescendantContext(name, initialValue) {\n  if (initialValue === void 0) {\n    initialValue = {};\n  }\n\n  var descendants = [];\n  return Object(_reach_utils__WEBPACK_IMPORTED_MODULE_1__[\"createNamedContext\"])(name, _extends({\n    descendants: descendants,\n    registerDescendant: _reach_utils__WEBPACK_IMPORTED_MODULE_1__[\"noop\"],\n    unregisterDescendant: _reach_utils__WEBPACK_IMPORTED_MODULE_1__[\"noop\"]\n  }, initialValue));\n}\n/**\r\n * This hook registers our descendant by passing it into an array. We can then\r\n * search that array by to find its index when registering it in the component.\r\n * We use this for focus management, keyboard navigation, and typeahead\r\n * functionality for some components.\r\n *\r\n * The hook accepts the element node and (optionally) a key. The key is useful\r\n * if multiple descendants have identical text values and we need to\r\n * differentiate siblings for some reason.\r\n *\r\n * Our main goals with this are:\r\n *   1) maximum composability,\r\n *   2) minimal API friction\r\n *   3) SSR compatibility*\r\n *   4) concurrent safe\r\n *   5) index always up-to-date with the tree despite changes\r\n *   6) works with memoization of any component in the tree (hopefully)\r\n *\r\n * * As for SSR, the good news is that we don't actually need the index on the\r\n * server for most use-cases, as we are only using it to determine the order of\r\n * composed descendants for keyboard navigation. However, in the few cases where\r\n * this is not the case, we can require an explicit index from the app.\r\n */\n\n\nfunction useDescendant(descendant, context, indexProp) {\n  var forceUpdate = Object(_reach_utils__WEBPACK_IMPORTED_MODULE_1__[\"useForceUpdate\"])();\n\n  var _React$useContext = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(context),\n      registerDescendant = _React$useContext.registerDescendant,\n      unregisterDescendant = _React$useContext.unregisterDescendant,\n      descendants = _React$useContext.descendants; // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants\n  // so that everything is up-to-date before the user interacts with a\n  // collection.\n\n\n  var index = indexProp !== null && indexProp !== void 0 ? indexProp : descendants.findIndex(function (item) {\n    return item.element === descendant.element;\n  });\n  var previousDescendants = Object(_reach_utils__WEBPACK_IMPORTED_MODULE_1__[\"usePrevious\"])(descendants); // We also need to re-register descendants any time ANY of the other\n  // descendants have changed. My brain was melting when I wrote this and it\n  // feels a little off, but checking in render and using the result in the\n  // effect's dependency array works well enough.\n\n  var someDescendantsHaveChanged = descendants.some(function (descendant, index) {\n    var _previousDescendants$;\n\n    return descendant.element !== (previousDescendants === null || previousDescendants === void 0 ? void 0 : (_previousDescendants$ = previousDescendants[index]) === null || _previousDescendants$ === void 0 ? void 0 : _previousDescendants$.element);\n  }); // Prevent any flashing\n\n  Object(_reach_utils__WEBPACK_IMPORTED_MODULE_1__[\"useIsomorphicLayoutEffect\"])(function () {\n    if (!descendant.element) forceUpdate();\n    registerDescendant(_extends({}, descendant, {\n      index: index\n    }));\n    return function () {\n      return unregisterDescendant(descendant.element);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [forceUpdate, index, registerDescendant, someDescendantsHaveChanged, unregisterDescendant].concat(Object.values(descendant)));\n  return index;\n}\n\nfunction useDescendantsInit() {\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])([]);\n}\n\nfunction useDescendants(ctx) {\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(ctx).descendants;\n}\n\nfunction DescendantProvider(_ref) {\n  var Ctx = _ref.context,\n      children = _ref.children,\n      items = _ref.items,\n      set = _ref.set;\n  var registerDescendant = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(function (_ref2) {\n    var element = _ref2.element,\n        explicitIndex = _ref2.index,\n        rest = _objectWithoutPropertiesLoose(_ref2, [\"element\", \"index\"]);\n\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      var newItems;\n\n      if (explicitIndex != null) {\n        newItems = [].concat(items, [_extends({}, rest, {\n          element: element,\n          index: explicitIndex\n        })]);\n      } else if (items.length === 0) {\n        // If there are no items, register at index 0 and bail.\n        newItems = [].concat(items, [_extends({}, rest, {\n          element: element,\n          index: 0\n        })]);\n      } else if (items.find(function (item) {\n        return item.element === element;\n      })) {\n        // If the element is already registered, just use the same array\n        newItems = items;\n      } else {\n        // When registering a descendant, we need to make sure we insert in\n        // into the array in the same order that it appears in the DOM. So as\n        // new descendants are added or maybe some are removed, we always know\n        // that the array is up-to-date and correct.\n        //\n        // So here we look at our registered descendants and see if the new\n        // element we are adding appears earlier than an existing descendant's\n        // DOM node via `node.compareDocumentPosition`. If it does, we insert\n        // the new element at this index. Because `registerDescendant` will be\n        // called in an effect every time the descendants state value changes,\n        // we should be sure that this index is accurate when descendent\n        // elements come or go from our component.\n        var index = items.findIndex(function (item) {\n          if (!item.element || !element) {\n            return false;\n          } // Does this element's DOM node appear before another item in the\n          // array in our DOM tree? If so, return true to grab the index at\n          // this point in the array so we know where to insert the new\n          // element.\n\n\n          return Boolean(item.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING);\n        });\n\n        var newItem = _extends({}, rest, {\n          element: element,\n          index: index\n        }); // If an index is not found we will push the element to the end.\n\n\n        if (index === -1) {\n          newItems = [].concat(items, [newItem]);\n        } else {\n          newItems = [].concat(items.slice(0, index), [newItem], items.slice(index));\n        }\n      }\n\n      return newItems.map(function (item, index) {\n        return _extends({}, item, {\n          index: index\n        });\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  var unregisterDescendant = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(function (element) {\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      return items.filter(function (item) {\n        return element !== item.element;\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(Ctx.Provider, {\n    value: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useMemo\"])(function () {\n      return {\n        descendants: items,\n        registerDescendant: registerDescendant,\n        unregisterDescendant: unregisterDescendant\n      };\n    }, [items, registerDescendant, unregisterDescendant])\n  }, children);\n}\n/**\r\n * Testing this as an abstraction for compound components that use keyboard\r\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\r\n * across various components, but it may also prove to be too messy of an\r\n * abstraction in the end.\r\n *\r\n * Currently used in:\r\n *   - Tabs\r\n *   - Accordion\r\n *\r\n * @param context\r\n * @param options\r\n */\n\n\nfunction useDescendantKeyDown(context, options) {\n  var _React$useContext2 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(context),\n      descendants = _React$useContext2.descendants;\n\n  var callback = options.callback,\n      currentIndex = options.currentIndex,\n      filter = options.filter,\n      _options$key = options.key,\n      key = _options$key === void 0 ? \"index\" : _options$key,\n      _options$orientation = options.orientation,\n      orientation = _options$orientation === void 0 ? \"vertical\" : _options$orientation,\n      _options$rotate = options.rotate,\n      rotate = _options$rotate === void 0 ? true : _options$rotate,\n      _options$rtl = options.rtl,\n      rtl = _options$rtl === void 0 ? false : _options$rtl;\n  var index = currentIndex !== null && currentIndex !== void 0 ? currentIndex : -1;\n  return function handleKeyDown(event) {\n    if (![\"ArrowDown\", \"ArrowUp\", \"ArrowLeft\", \"ArrowRight\", \"PageUp\", \"PageDown\", \"Home\", \"End\"].includes(event.key)) {\n      return;\n    } // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n\n\n    var selectableDescendants = filter ? descendants.filter(filter) : descendants; // Current index should map to the updated array vs. the original\n    // descendants array.\n\n    if (filter) {\n      index = selectableDescendants.findIndex(function (descendant) {\n        return descendant.index === currentIndex;\n      });\n    } // We need some options for any of this to work!\n\n\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    function getNextOption() {\n      var atBottom = index === selectableDescendants.length - 1;\n      return atBottom ? rotate ? getFirstOption() : selectableDescendants[index] : selectableDescendants[(index + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      var atTop = index === 0;\n      return atTop ? rotate ? getLastOption() : selectableDescendants[index] : selectableDescendants[(index - 1 + selectableDescendants.length) % selectableDescendants.length];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n\n        break;\n\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n\n        break;\n\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n\n        break;\n\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n\n        break;\n\n      case \"PageUp\":\n        event.preventDefault();\n        var prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n\n      case \"Home\":\n        event.preventDefault();\n        var first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n\n      case \"PageDown\":\n        event.preventDefault();\n        var nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n\n      case \"End\":\n        event.preventDefault();\n        var last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0ByZWFjaC9kZXNjZW5kYW50cy9kaXN0L2Rlc2NlbmRhbnRzLmVzbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zcmMvaW5kZXgudHN4P2RlYjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge1xuICBjcmVhdGVOYW1lZENvbnRleHQsXG4gIG5vb3AsXG4gIHVzZUZvcmNlVXBkYXRlLFxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LFxuICB1c2VQcmV2aW91cyxcbn0gZnJvbSBcIkByZWFjaC91dGlsc1wiO1xuXG5mdW5jdGlvbiBjcmVhdGVEZXNjZW5kYW50Q29udGV4dDxEZXNjZW5kYW50VHlwZSBleHRlbmRzIERlc2NlbmRhbnQ+KFxuICBuYW1lOiBzdHJpbmcsXG4gIGluaXRpYWxWYWx1ZSA9IHt9XG4pIHtcbiAgdHlwZSBUID0gRGVzY2VuZGFudENvbnRleHRWYWx1ZTxEZXNjZW5kYW50VHlwZT47XG4gIGNvbnN0IGRlc2NlbmRhbnRzOiBEZXNjZW5kYW50VHlwZVtdID0gW107XG4gIHJldHVybiBjcmVhdGVOYW1lZENvbnRleHQ8VD4obmFtZSwge1xuICAgIGRlc2NlbmRhbnRzLFxuICAgIHJlZ2lzdGVyRGVzY2VuZGFudDogbm9vcCxcbiAgICB1bnJlZ2lzdGVyRGVzY2VuZGFudDogbm9vcCxcbiAgICAuLi5pbml0aWFsVmFsdWUsXG4gIH0pO1xufVxuXG4vKipcbiAqIFRoaXMgaG9vayByZWdpc3RlcnMgb3VyIGRlc2NlbmRhbnQgYnkgcGFzc2luZyBpdCBpbnRvIGFuIGFycmF5LiBXZSBjYW4gdGhlblxuICogc2VhcmNoIHRoYXQgYXJyYXkgYnkgdG8gZmluZCBpdHMgaW5kZXggd2hlbiByZWdpc3RlcmluZyBpdCBpbiB0aGUgY29tcG9uZW50LlxuICogV2UgdXNlIHRoaXMgZm9yIGZvY3VzIG1hbmFnZW1lbnQsIGtleWJvYXJkIG5hdmlnYXRpb24sIGFuZCB0eXBlYWhlYWRcbiAqIGZ1bmN0aW9uYWxpdHkgZm9yIHNvbWUgY29tcG9uZW50cy5cbiAqXG4gKiBUaGUgaG9vayBhY2NlcHRzIHRoZSBlbGVtZW50IG5vZGUgYW5kIChvcHRpb25hbGx5KSBhIGtleS4gVGhlIGtleSBpcyB1c2VmdWxcbiAqIGlmIG11bHRpcGxlIGRlc2NlbmRhbnRzIGhhdmUgaWRlbnRpY2FsIHRleHQgdmFsdWVzIGFuZCB3ZSBuZWVkIHRvXG4gKiBkaWZmZXJlbnRpYXRlIHNpYmxpbmdzIGZvciBzb21lIHJlYXNvbi5cbiAqXG4gKiBPdXIgbWFpbiBnb2FscyB3aXRoIHRoaXMgYXJlOlxuICogICAxKSBtYXhpbXVtIGNvbXBvc2FiaWxpdHksXG4gKiAgIDIpIG1pbmltYWwgQVBJIGZyaWN0aW9uXG4gKiAgIDMpIFNTUiBjb21wYXRpYmlsaXR5KlxuICogICA0KSBjb25jdXJyZW50IHNhZmVcbiAqICAgNSkgaW5kZXggYWx3YXlzIHVwLXRvLWRhdGUgd2l0aCB0aGUgdHJlZSBkZXNwaXRlIGNoYW5nZXNcbiAqICAgNikgd29ya3Mgd2l0aCBtZW1vaXphdGlvbiBvZiBhbnkgY29tcG9uZW50IGluIHRoZSB0cmVlIChob3BlZnVsbHkpXG4gKlxuICogKiBBcyBmb3IgU1NSLCB0aGUgZ29vZCBuZXdzIGlzIHRoYXQgd2UgZG9uJ3QgYWN0dWFsbHkgbmVlZCB0aGUgaW5kZXggb24gdGhlXG4gKiBzZXJ2ZXIgZm9yIG1vc3QgdXNlLWNhc2VzLCBhcyB3ZSBhcmUgb25seSB1c2luZyBpdCB0byBkZXRlcm1pbmUgdGhlIG9yZGVyIG9mXG4gKiBjb21wb3NlZCBkZXNjZW5kYW50cyBmb3Iga2V5Ym9hcmQgbmF2aWdhdGlvbi4gSG93ZXZlciwgaW4gdGhlIGZldyBjYXNlcyB3aGVyZVxuICogdGhpcyBpcyBub3QgdGhlIGNhc2UsIHdlIGNhbiByZXF1aXJlIGFuIGV4cGxpY2l0IGluZGV4IGZyb20gdGhlIGFwcC5cbiAqL1xuZnVuY3Rpb24gdXNlRGVzY2VuZGFudDxEZXNjZW5kYW50VHlwZSBleHRlbmRzIERlc2NlbmRhbnQ+KFxuICBkZXNjZW5kYW50OiBPbWl0PERlc2NlbmRhbnRUeXBlLCBcImluZGV4XCI+LFxuICBjb250ZXh0OiBSZWFjdC5Db250ZXh0PERlc2NlbmRhbnRDb250ZXh0VmFsdWU8RGVzY2VuZGFudFR5cGU+PixcbiAgaW5kZXhQcm9wPzogbnVtYmVyXG4pIHtcbiAgbGV0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcbiAgbGV0IHtcbiAgICByZWdpc3RlckRlc2NlbmRhbnQsXG4gICAgdW5yZWdpc3RlckRlc2NlbmRhbnQsXG4gICAgZGVzY2VuZGFudHMsXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuXG4gIC8vIFRoaXMgd2lsbCBpbml0aWFsbHkgcmV0dXJuIC0xIGJlY2F1c2Ugd2UgaGF2ZW4ndCByZWdpc3RlcmVkIHRoZSBkZXNjZW5kYW50XG4gIC8vIG9uIHRoZSBmaXJzdCByZW5kZXIuIEFmdGVyIHdlIHJlZ2lzdGVyLCB0aGlzIHdpbGwgdGhlbiByZXR1cm4gdGhlIGNvcnJlY3RcbiAgLy8gaW5kZXggb24gdGhlIGZvbGxvd2luZyByZW5kZXIgYW5kIHdlIHdpbGwgcmUtcmVnaXN0ZXIgZGVzY2VuZGFudHNcbiAgLy8gc28gdGhhdCBldmVyeXRoaW5nIGlzIHVwLXRvLWRhdGUgYmVmb3JlIHRoZSB1c2VyIGludGVyYWN0cyB3aXRoIGFcbiAgLy8gY29sbGVjdGlvbi5cbiAgbGV0IGluZGV4ID1cbiAgICBpbmRleFByb3AgPz9cbiAgICBkZXNjZW5kYW50cy5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0uZWxlbWVudCA9PT0gZGVzY2VuZGFudC5lbGVtZW50KTtcblxuICBsZXQgcHJldmlvdXNEZXNjZW5kYW50cyA9IHVzZVByZXZpb3VzKGRlc2NlbmRhbnRzKTtcblxuICAvLyBXZSBhbHNvIG5lZWQgdG8gcmUtcmVnaXN0ZXIgZGVzY2VuZGFudHMgYW55IHRpbWUgQU5ZIG9mIHRoZSBvdGhlclxuICAvLyBkZXNjZW5kYW50cyBoYXZlIGNoYW5nZWQuIE15IGJyYWluIHdhcyBtZWx0aW5nIHdoZW4gSSB3cm90ZSB0aGlzIGFuZCBpdFxuICAvLyBmZWVscyBhIGxpdHRsZSBvZmYsIGJ1dCBjaGVja2luZyBpbiByZW5kZXIgYW5kIHVzaW5nIHRoZSByZXN1bHQgaW4gdGhlXG4gIC8vIGVmZmVjdCdzIGRlcGVuZGVuY3kgYXJyYXkgd29ya3Mgd2VsbCBlbm91Z2guXG4gIGxldCBzb21lRGVzY2VuZGFudHNIYXZlQ2hhbmdlZCA9IGRlc2NlbmRhbnRzLnNvbWUoKGRlc2NlbmRhbnQsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIGRlc2NlbmRhbnQuZWxlbWVudCAhPT0gcHJldmlvdXNEZXNjZW5kYW50cz8uW2luZGV4XT8uZWxlbWVudDtcbiAgfSk7XG5cbiAgLy8gUHJldmVudCBhbnkgZmxhc2hpbmdcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFkZXNjZW5kYW50LmVsZW1lbnQpIGZvcmNlVXBkYXRlKCk7XG4gICAgcmVnaXN0ZXJEZXNjZW5kYW50KHtcbiAgICAgIC4uLmRlc2NlbmRhbnQsXG4gICAgICBpbmRleCxcbiAgICB9IGFzIERlc2NlbmRhbnRUeXBlKTtcbiAgICByZXR1cm4gKCkgPT4gdW5yZWdpc3RlckRlc2NlbmRhbnQoZGVzY2VuZGFudC5lbGVtZW50KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtcbiAgICBmb3JjZVVwZGF0ZSxcbiAgICBpbmRleCxcbiAgICByZWdpc3RlckRlc2NlbmRhbnQsXG4gICAgc29tZURlc2NlbmRhbnRzSGF2ZUNoYW5nZWQsXG4gICAgdW5yZWdpc3RlckRlc2NlbmRhbnQsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIC4uLk9iamVjdC52YWx1ZXMoZGVzY2VuZGFudCksXG4gIF0pO1xuXG4gIHJldHVybiBpbmRleDtcbn1cblxuZnVuY3Rpb24gdXNlRGVzY2VuZGFudHNJbml0PERlc2NlbmRhbnRUeXBlIGV4dGVuZHMgRGVzY2VuZGFudD4oKSB7XG4gIHJldHVybiBSZWFjdC51c2VTdGF0ZTxEZXNjZW5kYW50VHlwZVtdPihbXSk7XG59XG5cbmZ1bmN0aW9uIHVzZURlc2NlbmRhbnRzPERlc2NlbmRhbnRUeXBlIGV4dGVuZHMgRGVzY2VuZGFudD4oXG4gIGN0eDogUmVhY3QuQ29udGV4dDxEZXNjZW5kYW50Q29udGV4dFZhbHVlPERlc2NlbmRhbnRUeXBlPj5cbikge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChjdHgpLmRlc2NlbmRhbnRzO1xufVxuXG5mdW5jdGlvbiBEZXNjZW5kYW50UHJvdmlkZXI8RGVzY2VuZGFudFR5cGUgZXh0ZW5kcyBEZXNjZW5kYW50Pih7XG4gIGNvbnRleHQ6IEN0eCxcbiAgY2hpbGRyZW4sXG4gIGl0ZW1zLFxuICBzZXQsXG59OiB7XG4gIGNvbnRleHQ6IFJlYWN0LkNvbnRleHQ8RGVzY2VuZGFudENvbnRleHRWYWx1ZTxEZXNjZW5kYW50VHlwZT4+O1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuICBpdGVtczogRGVzY2VuZGFudFR5cGVbXTtcbiAgc2V0OiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxEZXNjZW5kYW50VHlwZVtdPj47XG59KSB7XG4gIGxldCByZWdpc3RlckRlc2NlbmRhbnQgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoe1xuICAgICAgZWxlbWVudCxcbiAgICAgIGluZGV4OiBleHBsaWNpdEluZGV4LFxuICAgICAgLi4ucmVzdFxuICAgIH06IE9taXQ8RGVzY2VuZGFudFR5cGUsIFwiaW5kZXhcIj4gJiB7IGluZGV4PzogbnVtYmVyIHwgdW5kZWZpbmVkIH0pID0+IHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNldCgoaXRlbXMpID0+IHtcbiAgICAgICAgbGV0IG5ld0l0ZW1zOiBEZXNjZW5kYW50VHlwZVtdO1xuICAgICAgICBpZiAoZXhwbGljaXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3SXRlbXMgPSBbXG4gICAgICAgICAgICAuLi5pdGVtcyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgaW5kZXg6IGV4cGxpY2l0SW5kZXgsXG4gICAgICAgICAgICB9IGFzIERlc2NlbmRhbnRUeXBlLFxuICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGl0ZW1zLCByZWdpc3RlciBhdCBpbmRleCAwIGFuZCBiYWlsLlxuICAgICAgICAgIG5ld0l0ZW1zID0gW1xuICAgICAgICAgICAgLi4uaXRlbXMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgfSBhcyBEZXNjZW5kYW50VHlwZSxcbiAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uZWxlbWVudCA9PT0gZWxlbWVudCkpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQsIGp1c3QgdXNlIHRoZSBzYW1lIGFycmF5XG4gICAgICAgICAgbmV3SXRlbXMgPSBpdGVtcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXaGVuIHJlZ2lzdGVyaW5nIGEgZGVzY2VuZGFudCwgd2UgbmVlZCB0byBtYWtlIHN1cmUgd2UgaW5zZXJ0IGluXG4gICAgICAgICAgLy8gaW50byB0aGUgYXJyYXkgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCBpdCBhcHBlYXJzIGluIHRoZSBET00uIFNvIGFzXG4gICAgICAgICAgLy8gbmV3IGRlc2NlbmRhbnRzIGFyZSBhZGRlZCBvciBtYXliZSBzb21lIGFyZSByZW1vdmVkLCB3ZSBhbHdheXMga25vd1xuICAgICAgICAgIC8vIHRoYXQgdGhlIGFycmF5IGlzIHVwLXRvLWRhdGUgYW5kIGNvcnJlY3QuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBTbyBoZXJlIHdlIGxvb2sgYXQgb3VyIHJlZ2lzdGVyZWQgZGVzY2VuZGFudHMgYW5kIHNlZSBpZiB0aGUgbmV3XG4gICAgICAgICAgLy8gZWxlbWVudCB3ZSBhcmUgYWRkaW5nIGFwcGVhcnMgZWFybGllciB0aGFuIGFuIGV4aXN0aW5nIGRlc2NlbmRhbnQnc1xuICAgICAgICAgIC8vIERPTSBub2RlIHZpYSBgbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbmAuIElmIGl0IGRvZXMsIHdlIGluc2VydFxuICAgICAgICAgIC8vIHRoZSBuZXcgZWxlbWVudCBhdCB0aGlzIGluZGV4LiBCZWNhdXNlIGByZWdpc3RlckRlc2NlbmRhbnRgIHdpbGwgYmVcbiAgICAgICAgICAvLyBjYWxsZWQgaW4gYW4gZWZmZWN0IGV2ZXJ5IHRpbWUgdGhlIGRlc2NlbmRhbnRzIHN0YXRlIHZhbHVlIGNoYW5nZXMsXG4gICAgICAgICAgLy8gd2Ugc2hvdWxkIGJlIHN1cmUgdGhhdCB0aGlzIGluZGV4IGlzIGFjY3VyYXRlIHdoZW4gZGVzY2VuZGVudFxuICAgICAgICAgIC8vIGVsZW1lbnRzIGNvbWUgb3IgZ28gZnJvbSBvdXIgY29tcG9uZW50LlxuICAgICAgICAgIGxldCBpbmRleCA9IGl0ZW1zLmZpbmRJbmRleCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpdGVtLmVsZW1lbnQgfHwgIWVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG9lcyB0aGlzIGVsZW1lbnQncyBET00gbm9kZSBhcHBlYXIgYmVmb3JlIGFub3RoZXIgaXRlbSBpbiB0aGVcbiAgICAgICAgICAgIC8vIGFycmF5IGluIG91ciBET00gdHJlZT8gSWYgc28sIHJldHVybiB0cnVlIHRvIGdyYWIgdGhlIGluZGV4IGF0XG4gICAgICAgICAgICAvLyB0aGlzIHBvaW50IGluIHRoZSBhcnJheSBzbyB3ZSBrbm93IHdoZXJlIHRvIGluc2VydCB0aGUgbmV3XG4gICAgICAgICAgICAvLyBlbGVtZW50LlxuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oXG4gICAgICAgICAgICAgIGl0ZW0uZWxlbWVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50IGFzIE5vZGUpICZcbiAgICAgICAgICAgICAgICBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElOR1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGxldCBuZXdJdGVtID0ge1xuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICB9IGFzIERlc2NlbmRhbnRUeXBlO1xuXG4gICAgICAgICAgLy8gSWYgYW4gaW5kZXggaXMgbm90IGZvdW5kIHdlIHdpbGwgcHVzaCB0aGUgZWxlbWVudCB0byB0aGUgZW5kLlxuICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5ld0l0ZW1zID0gWy4uLml0ZW1zLCBuZXdJdGVtXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3SXRlbXMgPSBbXG4gICAgICAgICAgICAgIC4uLml0ZW1zLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgICAgICAgbmV3SXRlbSxcbiAgICAgICAgICAgICAgLi4uaXRlbXMuc2xpY2UoaW5kZXgpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0l0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+ICh7IC4uLml0ZW0sIGluZGV4IH0pKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gc2V0IGlzIGEgc3RhdGUgc2V0dGVyIGluaXRpYWxpemVkIGJ5IHRoZSB1c2VEZXNjZW5kYW50c0luaXQgaG9vay5cbiAgICAvLyBXZSBjYW4gc2FmZWx5IGlnbm9yZSB0aGUgbGludCB3YXJuaW5nIGhlcmUgYmVjYXVzZSBpdCB3aWxsIG5vdCBjaGFuZ2VcbiAgICAvLyBiZXR3ZWVuIHJlbmRlcnMuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtdXG4gICk7XG5cbiAgbGV0IHVucmVnaXN0ZXJEZXNjZW5kYW50ID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGVsZW1lbnQ6IERlc2NlbmRhbnRUeXBlW1wiZWxlbWVudFwiXSkgPT4ge1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2V0KChpdGVtcykgPT4gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBlbGVtZW50ICE9PSBpdGVtLmVsZW1lbnQpKTtcbiAgICB9LFxuICAgIC8vIHNldCBpcyBhIHN0YXRlIHNldHRlciBpbml0aWFsaXplZCBieSB0aGUgdXNlRGVzY2VuZGFudHNJbml0IGhvb2suXG4gICAgLy8gV2UgY2FuIHNhZmVseSBpZ25vcmUgdGhlIGxpbnQgd2FybmluZyBoZXJlIGJlY2F1c2UgaXQgd2lsbCBub3QgY2hhbmdlXG4gICAgLy8gYmV0d2VlbiByZW5kZXJzLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXVxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPEN0eC5Qcm92aWRlclxuICAgICAgdmFsdWU9e1JlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlc2NlbmRhbnRzOiBpdGVtcyxcbiAgICAgICAgICByZWdpc3RlckRlc2NlbmRhbnQsXG4gICAgICAgICAgdW5yZWdpc3RlckRlc2NlbmRhbnQsXG4gICAgICAgIH07XG4gICAgICB9LCBbaXRlbXMsIHJlZ2lzdGVyRGVzY2VuZGFudCwgdW5yZWdpc3RlckRlc2NlbmRhbnRdKX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9DdHguUHJvdmlkZXI+XG4gICk7XG59XG5cbi8qKlxuICogVGVzdGluZyB0aGlzIGFzIGFuIGFic3RyYWN0aW9uIGZvciBjb21wb3VuZCBjb21wb25lbnRzIHRoYXQgdXNlIGtleWJvYXJkXG4gKiBuYXZpZ2F0aW9uLiBIb3BpbmcgdGhpcyB3aWxsIGhlbHAgdXMgcHJldmVudCBidWdzIGFuZCBtaXNtYXRjaGVkIGJlaGF2aW9yXG4gKiBhY3Jvc3MgdmFyaW91cyBjb21wb25lbnRzLCBidXQgaXQgbWF5IGFsc28gcHJvdmUgdG8gYmUgdG9vIG1lc3N5IG9mIGFuXG4gKiBhYnN0cmFjdGlvbiBpbiB0aGUgZW5kLlxuICpcbiAqIEN1cnJlbnRseSB1c2VkIGluOlxuICogICAtIFRhYnNcbiAqICAgLSBBY2NvcmRpb25cbiAqXG4gKiBAcGFyYW0gY29udGV4dFxuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gdXNlRGVzY2VuZGFudEtleURvd248XG4gIERlc2NlbmRhbnRUeXBlIGV4dGVuZHMgRGVzY2VuZGFudCxcbiAgSyBleHRlbmRzIGtleW9mIERlc2NlbmRhbnRUeXBlID0ga2V5b2YgRGVzY2VuZGFudFR5cGVcbj4oXG4gIGNvbnRleHQ6IFJlYWN0LkNvbnRleHQ8RGVzY2VuZGFudENvbnRleHRWYWx1ZTxEZXNjZW5kYW50VHlwZT4+LFxuICBvcHRpb25zOiB7XG4gICAgY3VycmVudEluZGV4OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuICAgIGtleT86IEsgfCBcIm9wdGlvblwiO1xuICAgIGZpbHRlcj86IChkZXNjZW5kYW50OiBEZXNjZW5kYW50VHlwZSkgPT4gYm9vbGVhbjtcbiAgICBvcmllbnRhdGlvbj86IFwidmVydGljYWxcIiB8IFwiaG9yaXpvbnRhbFwiIHwgXCJib3RoXCI7XG4gICAgcm90YXRlPzogYm9vbGVhbjtcbiAgICBydGw/OiBib29sZWFuO1xuICAgIGNhbGxiYWNrKG5leHRPcHRpb246IERlc2NlbmRhbnRUeXBlIHwgRGVzY2VuZGFudFR5cGVbS10pOiB2b2lkO1xuICB9XG4pIHtcbiAgbGV0IHsgZGVzY2VuZGFudHMgfSA9IFJlYWN0LnVzZUNvbnRleHQoY29udGV4dCk7XG4gIGxldCB7XG4gICAgY2FsbGJhY2ssXG4gICAgY3VycmVudEluZGV4LFxuICAgIGZpbHRlcixcbiAgICBrZXkgPSBcImluZGV4XCIgYXMgSyxcbiAgICBvcmllbnRhdGlvbiA9IFwidmVydGljYWxcIixcbiAgICByb3RhdGUgPSB0cnVlLFxuICAgIHJ0bCA9IGZhbHNlLFxuICB9ID0gb3B0aW9ucztcbiAgbGV0IGluZGV4ID0gY3VycmVudEluZGV4ID8/IC0xO1xuXG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50OiBSZWFjdC5LZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKFxuICAgICAgIVtcbiAgICAgICAgXCJBcnJvd0Rvd25cIixcbiAgICAgICAgXCJBcnJvd1VwXCIsXG4gICAgICAgIFwiQXJyb3dMZWZ0XCIsXG4gICAgICAgIFwiQXJyb3dSaWdodFwiLFxuICAgICAgICBcIlBhZ2VVcFwiLFxuICAgICAgICBcIlBhZ2VEb3duXCIsXG4gICAgICAgIFwiSG9tZVwiLFxuICAgICAgICBcIkVuZFwiLFxuICAgICAgXS5pbmNsdWRlcyhldmVudC5rZXkpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgdXNlIGEgZmlsdGVyIGZ1bmN0aW9uLCB3ZSBuZWVkIHRvIHJlLWluZGV4IG91ciBkZXNjZW5kYW50cyBhcnJheVxuICAgIC8vIHNvIHRoYXQgZmlsdGVyZWQgZGVzY2VuZGVudCBlbGVtZW50cyBhcmVuJ3Qgc2VsZWN0ZWQuXG4gICAgbGV0IHNlbGVjdGFibGVEZXNjZW5kYW50cyA9IGZpbHRlclxuICAgICAgPyBkZXNjZW5kYW50cy5maWx0ZXIoZmlsdGVyKVxuICAgICAgOiBkZXNjZW5kYW50cztcblxuICAgIC8vIEN1cnJlbnQgaW5kZXggc2hvdWxkIG1hcCB0byB0aGUgdXBkYXRlZCBhcnJheSB2cy4gdGhlIG9yaWdpbmFsXG4gICAgLy8gZGVzY2VuZGFudHMgYXJyYXkuXG4gICAgaWYgKGZpbHRlcikge1xuICAgICAgaW5kZXggPSBzZWxlY3RhYmxlRGVzY2VuZGFudHMuZmluZEluZGV4KFxuICAgICAgICAoZGVzY2VuZGFudCkgPT4gZGVzY2VuZGFudC5pbmRleCA9PT0gY3VycmVudEluZGV4XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFdlIG5lZWQgc29tZSBvcHRpb25zIGZvciBhbnkgb2YgdGhpcyB0byB3b3JrIVxuICAgIGlmICghc2VsZWN0YWJsZURlc2NlbmRhbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE5leHRPcHRpb24oKSB7XG4gICAgICBsZXQgYXRCb3R0b20gPSBpbmRleCA9PT0gc2VsZWN0YWJsZURlc2NlbmRhbnRzLmxlbmd0aCAtIDE7XG4gICAgICByZXR1cm4gYXRCb3R0b21cbiAgICAgICAgPyByb3RhdGVcbiAgICAgICAgICA/IGdldEZpcnN0T3B0aW9uKClcbiAgICAgICAgICA6IHNlbGVjdGFibGVEZXNjZW5kYW50c1tpbmRleF1cbiAgICAgICAgOiBzZWxlY3RhYmxlRGVzY2VuZGFudHNbKGluZGV4ICsgMSkgJSBzZWxlY3RhYmxlRGVzY2VuZGFudHMubGVuZ3RoXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQcmV2aW91c09wdGlvbigpIHtcbiAgICAgIGxldCBhdFRvcCA9IGluZGV4ID09PSAwO1xuICAgICAgcmV0dXJuIGF0VG9wXG4gICAgICAgID8gcm90YXRlXG4gICAgICAgICAgPyBnZXRMYXN0T3B0aW9uKClcbiAgICAgICAgICA6IHNlbGVjdGFibGVEZXNjZW5kYW50c1tpbmRleF1cbiAgICAgICAgOiBzZWxlY3RhYmxlRGVzY2VuZGFudHNbXG4gICAgICAgICAgICAoaW5kZXggLSAxICsgc2VsZWN0YWJsZURlc2NlbmRhbnRzLmxlbmd0aCkgJVxuICAgICAgICAgICAgICBzZWxlY3RhYmxlRGVzY2VuZGFudHMubGVuZ3RoXG4gICAgICAgICAgXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRGaXJzdE9wdGlvbigpIHtcbiAgICAgIHJldHVybiBzZWxlY3RhYmxlRGVzY2VuZGFudHNbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TGFzdE9wdGlvbigpIHtcbiAgICAgIHJldHVybiBzZWxlY3RhYmxlRGVzY2VuZGFudHNbc2VsZWN0YWJsZURlc2NlbmRhbnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiIHx8IG9yaWVudGF0aW9uID09PSBcImJvdGhcIikge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgbGV0IG5leHQgPSBnZXROZXh0T3B0aW9uKCk7XG4gICAgICAgICAgY2FsbGJhY2soa2V5ID09PSBcIm9wdGlvblwiID8gbmV4dCA6IG5leHRba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiB8fCBvcmllbnRhdGlvbiA9PT0gXCJib3RoXCIpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGxldCBwcmV2ID0gZ2V0UHJldmlvdXNPcHRpb24oKTtcbiAgICAgICAgICBjYWxsYmFjayhrZXkgPT09IFwib3B0aW9uXCIgPyBwcmV2IDogcHJldltrZXldKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiB8fCBvcmllbnRhdGlvbiA9PT0gXCJib3RoXCIpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGxldCBuZXh0T3JQcmV2ID0gKHJ0bCA/IGdldE5leHRPcHRpb24gOiBnZXRQcmV2aW91c09wdGlvbikoKTtcbiAgICAgICAgICBjYWxsYmFjayhrZXkgPT09IFwib3B0aW9uXCIgPyBuZXh0T3JQcmV2IDogbmV4dE9yUHJldltrZXldKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgfHwgb3JpZW50YXRpb24gPT09IFwiYm90aFwiKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBsZXQgcHJldk9yTmV4dCA9IChydGwgPyBnZXRQcmV2aW91c09wdGlvbiA6IGdldE5leHRPcHRpb24pKCk7XG4gICAgICAgICAgY2FsbGJhY2soa2V5ID09PSBcIm9wdGlvblwiID8gcHJldk9yTmV4dCA6IHByZXZPck5leHRba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiUGFnZVVwXCI6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxldCBwcmV2T3JGaXJzdCA9IChldmVudC5jdHJsS2V5XG4gICAgICAgICAgPyBnZXRQcmV2aW91c09wdGlvblxuICAgICAgICAgIDogZ2V0Rmlyc3RPcHRpb24pKCk7XG4gICAgICAgIGNhbGxiYWNrKGtleSA9PT0gXCJvcHRpb25cIiA/IHByZXZPckZpcnN0IDogcHJldk9yRmlyc3Rba2V5XSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkhvbWVcIjpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IGZpcnN0ID0gZ2V0Rmlyc3RPcHRpb24oKTtcbiAgICAgICAgY2FsbGJhY2soa2V5ID09PSBcIm9wdGlvblwiID8gZmlyc3QgOiBmaXJzdFtrZXldKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiUGFnZURvd25cIjpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IG5leHRPckxhc3QgPSAoZXZlbnQuY3RybEtleSA/IGdldE5leHRPcHRpb24gOiBnZXRMYXN0T3B0aW9uKSgpO1xuICAgICAgICBjYWxsYmFjayhrZXkgPT09IFwib3B0aW9uXCIgPyBuZXh0T3JMYXN0IDogbmV4dE9yTGFzdFtrZXldKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxldCBsYXN0ID0gZ2V0TGFzdE9wdGlvbigpO1xuICAgICAgICBjYWxsYmFjayhrZXkgPT09IFwib3B0aW9uXCIgPyBsYXN0IDogbGFzdFtrZXldKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVHlwZXNcblxudHlwZSBTb21lRWxlbWVudDxUPiA9IFQgZXh0ZW5kcyBFbGVtZW50ID8gVCA6IEhUTUxFbGVtZW50O1xuXG50eXBlIERlc2NlbmRhbnQ8RWxlbWVudFR5cGUgPSBIVE1MRWxlbWVudD4gPSB7XG4gIGVsZW1lbnQ6IFNvbWVFbGVtZW50PEVsZW1lbnRUeXBlPiB8IG51bGw7XG4gIGluZGV4OiBudW1iZXI7XG59O1xuXG5pbnRlcmZhY2UgRGVzY2VuZGFudENvbnRleHRWYWx1ZTxEZXNjZW5kYW50VHlwZSBleHRlbmRzIERlc2NlbmRhbnQ+IHtcbiAgZGVzY2VuZGFudHM6IERlc2NlbmRhbnRUeXBlW107XG4gIHJlZ2lzdGVyRGVzY2VuZGFudChkZXNjZW5kYW50OiBEZXNjZW5kYW50VHlwZSk6IHZvaWQ7XG4gIHVucmVnaXN0ZXJEZXNjZW5kYW50KGVsZW1lbnQ6IERlc2NlbmRhbnRUeXBlW1wiZWxlbWVudFwiXSk6IHZvaWQ7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFeHBvcnRzXG5cbmV4cG9ydCB0eXBlIHsgRGVzY2VuZGFudCwgRGVzY2VuZGFudENvbnRleHRWYWx1ZSB9O1xuZXhwb3J0IHtcbiAgY3JlYXRlRGVzY2VuZGFudENvbnRleHQsXG4gIERlc2NlbmRhbnRQcm92aWRlcixcbiAgdXNlRGVzY2VuZGFudCxcbiAgdXNlRGVzY2VuZGFudEtleURvd24sXG4gIHVzZURlc2NlbmRhbnRzLFxuICB1c2VEZXNjZW5kYW50c0luaXQsXG59O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBU0E7QUFFQTtBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBO0FBS0E7QUFDQTtBQUlBO0FBSEE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUZBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7QUFDQTtBQTVCQTtBQUNBO0FBK0JBO0FBQ0E7QUFDQTtBQUVBO0FBRkE7QUFJQTtBQUFBO0FBTkE7QUFBQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBTEE7QUFEQTtBQVVBO0FBQ0E7QUFJQTtBQUNBO0FBTEE7QUFGQTtBQVVBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQVJBO0FBQ0E7QUFhQTtBQUVBO0FBQ0E7QUFIQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBREE7QUFHQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFwRUE7QUFWQTtBQWtGQTtBQUNBO0FBQ0E7QUFwRkE7QUF3RkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFOQTtBQVNBO0FBQ0E7QUFDQTtBQVhBO0FBZUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQURBO0FBWUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FBYUE7QUFlQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUpBO0FBSUE7QUFIQTtBQUdBO0FBRkE7QUFFQTtBQURBO0FBRUE7QUFFQTtBQUNBO0FBWUE7QUFiQTtBQWlCQTtBQUNBO0FBQ0E7QUFEQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQXpCQTtBQUNBO0FBQ0E7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsREE7QUFoRUE7QUFxSEE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@reach/descendants/dist/descendants.esm.js\n");

/***/ }),

/***/ "../node_modules/@reach/popover/dist/popover.esm.js":
/*!**********************************************************!*\
  !*** ../node_modules/@reach/popover/dist/popover.esm.js ***!
  \**********************************************************/
/*! exports provided: default, Popover, getCollisions, positionDefault, positionMatchWidth, positionRight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Popover\", function() { return Popover; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCollisions\", function() { return getCollisions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"positionDefault\", function() { return positionDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"positionMatchWidth\", function() { return positionMatchWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"positionRight\", function() { return positionRight; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _reach_portal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reach/portal */ \"../node_modules/@reach/portal/dist/portal.esm.js\");\n/* harmony import */ var _reach_rect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reach/rect */ \"../node_modules/@reach/popover/node_modules/@reach/rect/dist/rect.esm.js\");\n/* harmony import */ var _reach_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @reach/utils */ \"../node_modules/@reach/utils/dist/utils.esm.js\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tabbable */ \"../node_modules/tabbable/index.js\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(tabbable__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n/**\r\n * Popover\r\n */\n\n\nvar Popover = /*#__PURE__*/Object(_reach_utils__WEBPACK_IMPORTED_MODULE_3__[\"forwardRefWithAs\"])(function Popover(props, ref) {\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(_reach_portal__WEBPACK_IMPORTED_MODULE_1__[\"Portal\"], null, Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(PopoverImpl, Object.assign({\n    ref: ref\n  }, props)));\n});\n\nif (true) {\n  Popover.displayName = \"Popover\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * PopoverImpl\r\n *\r\n * Popover is conditionally rendered so we can't start measuring until it shows\r\n * up, so useRect needs to live down here not up in Popover\r\n */\n\n\nvar PopoverImpl = /*#__PURE__*/Object(_reach_utils__WEBPACK_IMPORTED_MODULE_3__[\"forwardRefWithAs\"])(function PopoverImpl(_ref, forwardedRef) {\n  var _ref$as = _ref.as,\n      Comp = _ref$as === void 0 ? \"div\" : _ref$as,\n      targetRef = _ref.targetRef,\n      _ref$position = _ref.position,\n      position = _ref$position === void 0 ? positionDefault : _ref$position,\n      _ref$unstable_observa = _ref.unstable_observableRefs,\n      unstable_observableRefs = _ref$unstable_observa === void 0 ? [] : _ref$unstable_observa,\n      props = _objectWithoutPropertiesLoose(_ref, [\"as\", \"targetRef\", \"position\", \"unstable_observableRefs\"]);\n\n  var popoverRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(null);\n  var popoverRect = Object(_reach_rect__WEBPACK_IMPORTED_MODULE_2__[\"useRect\"])(popoverRef, {\n    observe: !props.hidden\n  });\n  var targetRect = Object(_reach_rect__WEBPACK_IMPORTED_MODULE_2__[\"useRect\"])(targetRef, {\n    observe: !props.hidden\n  });\n  var ref = Object(_reach_utils__WEBPACK_IMPORTED_MODULE_3__[\"useForkedRef\"])(popoverRef, forwardedRef);\n  useSimulateTabNavigationForReactTree(targetRef, popoverRef);\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(Comp, Object.assign({\n    \"data-reach-popover\": \"\",\n    ref: ref\n  }, props, {\n    style: _extends({\n      position: \"absolute\"\n    }, getStyles.apply(void 0, [position, targetRect, popoverRect].concat(unstable_observableRefs)), props.style)\n  }));\n});\n\nif (true) {\n  PopoverImpl.displayName = \"PopoverImpl\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n\nfunction getStyles(position, targetRect, popoverRect) {\n  for (var _len = arguments.length, unstable_observableRefs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    unstable_observableRefs[_key - 3] = arguments[_key];\n  }\n\n  return popoverRect ? position.apply(void 0, [targetRect, popoverRect].concat(unstable_observableRefs.map(function (ref) {\n    return ref.current;\n  }))) : {\n    visibility: \"hidden\"\n  };\n}\n\nfunction getTopPosition(targetRect, popoverRect) {\n  var _getCollisions = getCollisions(targetRect, popoverRect),\n      directionUp = _getCollisions.directionUp;\n\n  return {\n    top: directionUp ? targetRect.top - popoverRect.height + window.pageYOffset + \"px\" : targetRect.top + targetRect.height + window.pageYOffset + \"px\"\n  };\n}\n\nvar positionDefault = function positionDefault(targetRect, popoverRect) {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  var _getCollisions2 = getCollisions(targetRect, popoverRect),\n      directionRight = _getCollisions2.directionRight;\n\n  return _extends({\n    left: directionRight ? targetRect.right - popoverRect.width + window.pageXOffset + \"px\" : targetRect.left + window.pageXOffset + \"px\"\n  }, getTopPosition(targetRect, popoverRect));\n};\n\nvar positionRight = function positionRight(targetRect, popoverRect) {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  var _getCollisions3 = getCollisions(targetRect, popoverRect),\n      directionLeft = _getCollisions3.directionLeft;\n\n  return _extends({\n    left: directionLeft ? targetRect.left + window.pageXOffset + \"px\" : targetRect.right - popoverRect.width + window.pageXOffset + \"px\"\n  }, getTopPosition(targetRect, popoverRect));\n};\n\nvar positionMatchWidth = function positionMatchWidth(targetRect, popoverRect) {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  return _extends({\n    width: targetRect.width,\n    left: targetRect.left\n  }, getTopPosition(targetRect, popoverRect));\n};\n\nfunction getCollisions(targetRect, popoverRect, offsetLeft, offsetBottom) {\n  if (offsetLeft === void 0) {\n    offsetLeft = 0;\n  }\n\n  if (offsetBottom === void 0) {\n    offsetBottom = 0;\n  }\n\n  var collisions = {\n    top: targetRect.top - popoverRect.height < 0,\n    right: window.innerWidth < targetRect.left + popoverRect.width - offsetLeft,\n    bottom: window.innerHeight < targetRect.bottom + popoverRect.height - offsetBottom,\n    left: targetRect.left + targetRect.width - popoverRect.width < 0\n  };\n  var directionRight = collisions.right && !collisions.left;\n  var directionLeft = collisions.left && !collisions.right;\n  var directionUp = collisions.bottom && !collisions.top;\n  var directionDown = collisions.top && !collisions.bottom;\n  return {\n    directionRight: directionRight,\n    directionLeft: directionLeft,\n    directionUp: directionUp,\n    directionDown: directionDown\n  };\n} // Heads up, my jQuery past haunts this function. This hook scopes the tab\n// order to the React element tree, instead of the DOM tree. This way, when the\n// user navigates with tab from the targetRef, the tab order moves into the\n// popup, and then out of the popup back to the rest of the document.\n// (We call targetRef, triggerRef inside this function to avoid confusion with\n// event.target)\n\n\nfunction useSimulateTabNavigationForReactTree(triggerRef, popoverRef) {\n  var ownerDocument = Object(_reach_utils__WEBPACK_IMPORTED_MODULE_3__[\"getOwnerDocument\"])(triggerRef.current);\n\n  function handleKeyDown(event) {\n    if (event.key === \"Tab\" && popoverRef.current && tabbable__WEBPACK_IMPORTED_MODULE_4___default()(popoverRef.current).length === 0) {\n      return;\n    }\n\n    if (event.key === \"Tab\" && event.shiftKey) {\n      if (shiftTabbedFromElementAfterTrigger(event)) {\n        focusLastTabbableInPopover(event);\n      } else if (shiftTabbedOutOfPopover(event)) {\n        focusTriggerRef(event);\n      } else if (shiftTabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover();\n      }\n    } else if (event.key === \"Tab\") {\n      if (tabbedFromTriggerToPopover()) {\n        focusFirstPopoverTabbable(event);\n      } else if (tabbedOutOfPopover()) {\n        focusTabbableAfterTrigger(event);\n      } else if (tabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover();\n      }\n    }\n  }\n\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n    ownerDocument.addEventListener(\"keydown\", handleKeyDown);\n    return function () {\n      ownerDocument.removeEventListener(\"keydown\", handleKeyDown);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  function getElementAfterTrigger() {\n    var elements = tabbable__WEBPACK_IMPORTED_MODULE_4___default()(ownerDocument);\n    var targetIndex = elements && triggerRef.current ? elements.indexOf(triggerRef.current) : -1;\n    var elementAfterTrigger = elements && elements[targetIndex + 1];\n    return popoverRef.current && popoverRef.current.contains(elementAfterTrigger || null) ? false : elementAfterTrigger;\n  }\n\n  function tabbedFromTriggerToPopover() {\n    return triggerRef.current ? triggerRef.current === ownerDocument.activeElement : false;\n  }\n\n  function focusFirstPopoverTabbable(event) {\n    var elements = popoverRef.current && tabbable__WEBPACK_IMPORTED_MODULE_4___default()(popoverRef.current);\n\n    if (elements && elements[0]) {\n      event.preventDefault();\n      elements[0].focus();\n    }\n  }\n\n  function tabbedOutOfPopover() {\n    var inPopover = popoverRef.current ? popoverRef.current.contains(ownerDocument.activeElement || null) : false;\n\n    if (inPopover) {\n      var elements = popoverRef.current && tabbable__WEBPACK_IMPORTED_MODULE_4___default()(popoverRef.current);\n      return Boolean(elements && elements[elements.length - 1] === ownerDocument.activeElement);\n    }\n\n    return false;\n  }\n\n  function focusTabbableAfterTrigger(event) {\n    var elementAfterTrigger = getElementAfterTrigger();\n\n    if (elementAfterTrigger) {\n      event.preventDefault();\n      elementAfterTrigger.focus();\n    }\n  }\n\n  function shiftTabbedFromElementAfterTrigger(event) {\n    if (!event.shiftKey) return;\n    var elementAfterTrigger = getElementAfterTrigger();\n    return event.target === elementAfterTrigger;\n  }\n\n  function focusLastTabbableInPopover(event) {\n    var elements = popoverRef.current && tabbable__WEBPACK_IMPORTED_MODULE_4___default()(popoverRef.current);\n    var last = elements && elements[elements.length - 1];\n\n    if (last) {\n      event.preventDefault();\n      last.focus();\n    }\n  }\n\n  function shiftTabbedOutOfPopover(event) {\n    var elements = popoverRef.current && tabbable__WEBPACK_IMPORTED_MODULE_4___default()(popoverRef.current);\n\n    if (elements) {\n      return elements.length === 0 ? false : event.target === elements[0];\n    }\n\n    return false;\n  }\n\n  function focusTriggerRef(event) {\n    var _triggerRef$current;\n\n    event.preventDefault();\n    (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.focus();\n  }\n\n  function tabbedToBrowserChrome(event) {\n    var elements = popoverRef.current ? tabbable__WEBPACK_IMPORTED_MODULE_4___default()(ownerDocument).filter(function (element) {\n      return !popoverRef.current.contains(element);\n    }) : null;\n    return elements ? event.target === elements[elements.length - 1] : false;\n  }\n\n  function shiftTabbedToBrowserChrome(event) {\n    // we're assuming the popover will never contain the first tabbable\n    // element, and it better not, because the trigger needs to be tabbable!\n    return event.target === tabbable__WEBPACK_IMPORTED_MODULE_4___default()(ownerDocument)[0];\n  }\n\n  var restoreTabIndexTupl√©s = [];\n\n  function disableTabbablesInPopover() {\n    var elements = popoverRef.current && tabbable__WEBPACK_IMPORTED_MODULE_4___default()(popoverRef.current);\n\n    if (elements) {\n      elements.forEach(function (element) {\n        restoreTabIndexTupl√©s.push([element, element.tabIndex]);\n        element.tabIndex = -1;\n      });\n      ownerDocument.addEventListener(\"focusin\", enableTabbablesInPopover);\n    }\n  }\n\n  function enableTabbablesInPopover() {\n    ownerDocument.removeEventListener(\"focusin\", enableTabbablesInPopover);\n    restoreTabIndexTupl√©s.forEach(function (_ref2) {\n      var element = _ref2[0],\n          tabIndex = _ref2[1];\n      element.tabIndex = tabIndex;\n    });\n  }\n} ////////////////////////////////////////////////////////////////////////////////\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Popover);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0ByZWFjaC9wb3BvdmVyL2Rpc3QvcG9wb3Zlci5lc20uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2luZGV4LnRzeD9kZWI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV2VsY29tZSB0byBAcmVhY2gvcG9wb3ZlciFcbiAqL1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFBvcnRhbCB9IGZyb20gXCJAcmVhY2gvcG9ydGFsXCI7XG5pbXBvcnQgeyB1c2VSZWN0LCBQUmVjdCB9IGZyb20gXCJAcmVhY2gvcmVjdFwiO1xuaW1wb3J0IHsgZm9yd2FyZFJlZldpdGhBcywgZ2V0T3duZXJEb2N1bWVudCwgdXNlRm9ya2VkUmVmIH0gZnJvbSBcIkByZWFjaC91dGlsc1wiO1xuaW1wb3J0IHRhYmJhYmxlIGZyb20gXCJ0YWJiYWJsZVwiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIFBvcG92ZXJcbiAqL1xuY29uc3QgUG9wb3ZlciA9IGZvcndhcmRSZWZXaXRoQXM8UG9wb3ZlclByb3BzLCBcImRpdlwiPihmdW5jdGlvbiBQb3BvdmVyKFxuICBwcm9wcyxcbiAgcmVmXG4pIHtcbiAgcmV0dXJuIChcbiAgICA8UG9ydGFsPlxuICAgICAgPFBvcG92ZXJJbXBsIHJlZj17cmVmfSB7Li4ucHJvcHN9IC8+XG4gICAgPC9Qb3J0YWw+XG4gICk7XG59KTtcblxudHlwZSBQb3BvdmVyUHJvcHMgPSB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gIHRhcmdldFJlZjogUmVhY3QuUmVmT2JqZWN0PEhUTUxFbGVtZW50PjtcbiAgcG9zaXRpb24/OiBQb3NpdGlvbjtcbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgcG9wb3ZlciBtYXJrdXAsIGJ1dCBoaWRlIGl0IOKAkyB1c2VkIGJ5IE1lbnVCdXR0b24gc28gdGhhdCBpdFxuICAgKiBjYW4gaGF2ZSBhbiBgYXJpYS1jb250cm9sc2AgYXR0cmlidXRlIGV2ZW4gd2hlbiBpdHMgbWVudSBpc24ndCBvcGVuLCBhbmRcbiAgICogdXNlZCBpbnNpZGUgYFBvcG92ZXJgIGFzIGEgaGludCB0aGF0IHdlIGNhbiB0ZWxsIGB1c2VSZWN0YCB0byBzdG9wXG4gICAqIG9ic2VydmluZyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICAgKi9cbiAgaGlkZGVuPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFRlc3RpbmcgdGhpcyBBUEkgc28gd2UgbWlnaHQgYWNjZXB0IGFkZGl0aW9uYWwgbm9kZXMgdGhhdCBhcHBzIGNhbiB1c2UgdG9cbiAgICogZGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wb3Zlci4gT25lIGV4YW1wbGUgd2hlcmUgaXQgbWF5IGJlIHVzZWZ1bFxuICAgKiBpcyBmb3IgcG9zaXRpb25pbmcgdGhlIHBvcG92ZXIgb2YgYSBsaXN0Ym94IHdoZXJlIHRoZSBjdXJzb3IgcmVzdHMgb24gdG9wXG4gICAqIG9mIHRoZSBzZWxlY3RlZCBvcHRpb24uIFByZXR0eSBzdXJlIHRoaXMgd2lsbCBjaGFuZ2Ugc28gZG9uJ3QgdXNlIGl0XG4gICAqIGFueXdoZXJlIGluIHB1YmxpYyB5ZXQhXG4gICAqL1xuICB1bnN0YWJsZV9vYnNlcnZhYmxlUmVmcz86IFJlYWN0LlJlZk9iamVjdDxQb3NzaWJsZU5vZGU+W107XG59O1xuXG5pZiAoX19ERVZfXykge1xuICBQb3BvdmVyLmRpc3BsYXlOYW1lID0gXCJQb3BvdmVyXCI7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogUG9wb3ZlckltcGxcbiAqXG4gKiBQb3BvdmVyIGlzIGNvbmRpdGlvbmFsbHkgcmVuZGVyZWQgc28gd2UgY2FuJ3Qgc3RhcnQgbWVhc3VyaW5nIHVudGlsIGl0IHNob3dzXG4gKiB1cCwgc28gdXNlUmVjdCBuZWVkcyB0byBsaXZlIGRvd24gaGVyZSBub3QgdXAgaW4gUG9wb3ZlclxuICovXG5jb25zdCBQb3BvdmVySW1wbCA9IGZvcndhcmRSZWZXaXRoQXM8UG9wb3ZlclByb3BzLCBcImRpdlwiPihmdW5jdGlvbiBQb3BvdmVySW1wbChcbiAge1xuICAgIGFzOiBDb21wID0gXCJkaXZcIixcbiAgICB0YXJnZXRSZWYsXG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbkRlZmF1bHQsXG4gICAgdW5zdGFibGVfb2JzZXJ2YWJsZVJlZnMgPSBbXSxcbiAgICAuLi5wcm9wc1xuICB9LFxuICBmb3J3YXJkZWRSZWZcbikge1xuICBjb25zdCBwb3BvdmVyUmVmID0gUmVhY3QudXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgcG9wb3ZlclJlY3QgPSB1c2VSZWN0KHBvcG92ZXJSZWYsIHsgb2JzZXJ2ZTogIXByb3BzLmhpZGRlbiB9KTtcbiAgY29uc3QgdGFyZ2V0UmVjdCA9IHVzZVJlY3QodGFyZ2V0UmVmLCB7IG9ic2VydmU6ICFwcm9wcy5oaWRkZW4gfSk7XG4gIGNvbnN0IHJlZiA9IHVzZUZvcmtlZFJlZihwb3BvdmVyUmVmLCBmb3J3YXJkZWRSZWYpO1xuXG4gIHVzZVNpbXVsYXRlVGFiTmF2aWdhdGlvbkZvclJlYWN0VHJlZSh0YXJnZXRSZWYsIHBvcG92ZXJSZWYpO1xuXG4gIHJldHVybiAoXG4gICAgPENvbXBcbiAgICAgIGRhdGEtcmVhY2gtcG9wb3Zlcj1cIlwiXG4gICAgICByZWY9e3JlZn1cbiAgICAgIHsuLi5wcm9wc31cbiAgICAgIHN0eWxlPXt7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIC4uLmdldFN0eWxlcyhcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICB0YXJnZXRSZWN0LFxuICAgICAgICAgIHBvcG92ZXJSZWN0LFxuICAgICAgICAgIC4uLnVuc3RhYmxlX29ic2VydmFibGVSZWZzXG4gICAgICAgICksXG4gICAgICAgIC4uLnByb3BzLnN0eWxlLFxuICAgICAgfX1cbiAgICAvPlxuICApO1xufSk7XG5cbmlmIChfX0RFVl9fKSB7XG4gIFBvcG92ZXJJbXBsLmRpc3BsYXlOYW1lID0gXCJQb3BvdmVySW1wbFwiO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBnZXRTdHlsZXMoXG4gIHBvc2l0aW9uOiBQb3NpdGlvbixcbiAgdGFyZ2V0UmVjdDogUFJlY3QgfCBudWxsLFxuICBwb3BvdmVyUmVjdDogUFJlY3QgfCBudWxsLFxuICAuLi51bnN0YWJsZV9vYnNlcnZhYmxlUmVmczogUmVhY3QuUmVmT2JqZWN0PFBvc3NpYmxlTm9kZT5bXVxuKTogUmVhY3QuQ1NTUHJvcGVydGllcyB7XG4gIHJldHVybiBwb3BvdmVyUmVjdFxuICAgID8gcG9zaXRpb24oXG4gICAgICAgIHRhcmdldFJlY3QsXG4gICAgICAgIHBvcG92ZXJSZWN0LFxuICAgICAgICAuLi51bnN0YWJsZV9vYnNlcnZhYmxlUmVmcy5tYXAoKHJlZikgPT4gcmVmLmN1cnJlbnQpXG4gICAgICApXG4gICAgOiB7IHZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VG9wUG9zaXRpb24odGFyZ2V0UmVjdDogUFJlY3QsIHBvcG92ZXJSZWN0OiBQUmVjdCkge1xuICBjb25zdCB7IGRpcmVjdGlvblVwIH0gPSBnZXRDb2xsaXNpb25zKHRhcmdldFJlY3QsIHBvcG92ZXJSZWN0KTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IGRpcmVjdGlvblVwXG4gICAgICA/IGAke3RhcmdldFJlY3QudG9wIC0gcG9wb3ZlclJlY3QuaGVpZ2h0ICsgd2luZG93LnBhZ2VZT2Zmc2V0fXB4YFxuICAgICAgOiBgJHt0YXJnZXRSZWN0LnRvcCArIHRhcmdldFJlY3QuaGVpZ2h0ICsgd2luZG93LnBhZ2VZT2Zmc2V0fXB4YCxcbiAgfTtcbn1cblxuY29uc3QgcG9zaXRpb25EZWZhdWx0OiBQb3NpdGlvbiA9ICh0YXJnZXRSZWN0LCBwb3BvdmVyUmVjdCkgPT4ge1xuICBpZiAoIXRhcmdldFJlY3QgfHwgIXBvcG92ZXJSZWN0KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgY29uc3QgeyBkaXJlY3Rpb25SaWdodCB9ID0gZ2V0Q29sbGlzaW9ucyh0YXJnZXRSZWN0LCBwb3BvdmVyUmVjdCk7XG4gIHJldHVybiB7XG4gICAgbGVmdDogZGlyZWN0aW9uUmlnaHRcbiAgICAgID8gYCR7dGFyZ2V0UmVjdC5yaWdodCAtIHBvcG92ZXJSZWN0LndpZHRoICsgd2luZG93LnBhZ2VYT2Zmc2V0fXB4YFxuICAgICAgOiBgJHt0YXJnZXRSZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXR9cHhgLFxuICAgIC4uLmdldFRvcFBvc2l0aW9uKHRhcmdldFJlY3QsIHBvcG92ZXJSZWN0KSxcbiAgfTtcbn07XG5cbmNvbnN0IHBvc2l0aW9uUmlnaHQ6IFBvc2l0aW9uID0gKHRhcmdldFJlY3QsIHBvcG92ZXJSZWN0KSA9PiB7XG4gIGlmICghdGFyZ2V0UmVjdCB8fCAhcG9wb3ZlclJlY3QpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBjb25zdCB7IGRpcmVjdGlvbkxlZnQgfSA9IGdldENvbGxpc2lvbnModGFyZ2V0UmVjdCwgcG9wb3ZlclJlY3QpO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGRpcmVjdGlvbkxlZnRcbiAgICAgID8gYCR7dGFyZ2V0UmVjdC5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0fXB4YFxuICAgICAgOiBgJHt0YXJnZXRSZWN0LnJpZ2h0IC0gcG9wb3ZlclJlY3Qud2lkdGggKyB3aW5kb3cucGFnZVhPZmZzZXR9cHhgLFxuICAgIC4uLmdldFRvcFBvc2l0aW9uKHRhcmdldFJlY3QsIHBvcG92ZXJSZWN0KSxcbiAgfTtcbn07XG5cbmNvbnN0IHBvc2l0aW9uTWF0Y2hXaWR0aDogUG9zaXRpb24gPSAodGFyZ2V0UmVjdCwgcG9wb3ZlclJlY3QpID0+IHtcbiAgaWYgKCF0YXJnZXRSZWN0IHx8ICFwb3BvdmVyUmVjdCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHRhcmdldFJlY3Qud2lkdGgsXG4gICAgbGVmdDogdGFyZ2V0UmVjdC5sZWZ0LFxuICAgIC4uLmdldFRvcFBvc2l0aW9uKHRhcmdldFJlY3QsIHBvcG92ZXJSZWN0KSxcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldENvbGxpc2lvbnMoXG4gIHRhcmdldFJlY3Q6IFBSZWN0LFxuICBwb3BvdmVyUmVjdDogUFJlY3QsXG4gIG9mZnNldExlZnQ6IG51bWJlciA9IDAsXG4gIG9mZnNldEJvdHRvbTogbnVtYmVyID0gMFxuKSB7XG4gIGNvbnN0IGNvbGxpc2lvbnMgPSB7XG4gICAgdG9wOiB0YXJnZXRSZWN0LnRvcCAtIHBvcG92ZXJSZWN0LmhlaWdodCA8IDAsXG4gICAgcmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoIDwgdGFyZ2V0UmVjdC5sZWZ0ICsgcG9wb3ZlclJlY3Qud2lkdGggLSBvZmZzZXRMZWZ0LFxuICAgIGJvdHRvbTpcbiAgICAgIHdpbmRvdy5pbm5lckhlaWdodCA8XG4gICAgICB0YXJnZXRSZWN0LmJvdHRvbSArIHBvcG92ZXJSZWN0LmhlaWdodCAtIG9mZnNldEJvdHRvbSxcbiAgICBsZWZ0OiB0YXJnZXRSZWN0LmxlZnQgKyB0YXJnZXRSZWN0LndpZHRoIC0gcG9wb3ZlclJlY3Qud2lkdGggPCAwLFxuICB9O1xuXG4gIGNvbnN0IGRpcmVjdGlvblJpZ2h0ID0gY29sbGlzaW9ucy5yaWdodCAmJiAhY29sbGlzaW9ucy5sZWZ0O1xuICBjb25zdCBkaXJlY3Rpb25MZWZ0ID0gY29sbGlzaW9ucy5sZWZ0ICYmICFjb2xsaXNpb25zLnJpZ2h0O1xuICBjb25zdCBkaXJlY3Rpb25VcCA9IGNvbGxpc2lvbnMuYm90dG9tICYmICFjb2xsaXNpb25zLnRvcDtcbiAgY29uc3QgZGlyZWN0aW9uRG93biA9IGNvbGxpc2lvbnMudG9wICYmICFjb2xsaXNpb25zLmJvdHRvbTtcblxuICByZXR1cm4geyBkaXJlY3Rpb25SaWdodCwgZGlyZWN0aW9uTGVmdCwgZGlyZWN0aW9uVXAsIGRpcmVjdGlvbkRvd24gfTtcbn1cblxuLy8gSGVhZHMgdXAsIG15IGpRdWVyeSBwYXN0IGhhdW50cyB0aGlzIGZ1bmN0aW9uLiBUaGlzIGhvb2sgc2NvcGVzIHRoZSB0YWJcbi8vIG9yZGVyIHRvIHRoZSBSZWFjdCBlbGVtZW50IHRyZWUsIGluc3RlYWQgb2YgdGhlIERPTSB0cmVlLiBUaGlzIHdheSwgd2hlbiB0aGVcbi8vIHVzZXIgbmF2aWdhdGVzIHdpdGggdGFiIGZyb20gdGhlIHRhcmdldFJlZiwgdGhlIHRhYiBvcmRlciBtb3ZlcyBpbnRvIHRoZVxuLy8gcG9wdXAsIGFuZCB0aGVuIG91dCBvZiB0aGUgcG9wdXAgYmFjayB0byB0aGUgcmVzdCBvZiB0aGUgZG9jdW1lbnQuXG4vLyAoV2UgY2FsbCB0YXJnZXRSZWYsIHRyaWdnZXJSZWYgaW5zaWRlIHRoaXMgZnVuY3Rpb24gdG8gYXZvaWQgY29uZnVzaW9uIHdpdGhcbi8vIGV2ZW50LnRhcmdldClcbmZ1bmN0aW9uIHVzZVNpbXVsYXRlVGFiTmF2aWdhdGlvbkZvclJlYWN0VHJlZTxcbiAgVCBleHRlbmRzIEhUTUxFbGVtZW50LFxuICBQIGV4dGVuZHMgSFRNTEVsZW1lbnRcbj4odHJpZ2dlclJlZjogUmVhY3QuUmVmT2JqZWN0PFQ+LCBwb3BvdmVyUmVmOiBSZWFjdC5SZWZPYmplY3Q8UD4pIHtcbiAgY29uc3Qgb3duZXJEb2N1bWVudCA9IGdldE93bmVyRG9jdW1lbnQodHJpZ2dlclJlZi5jdXJyZW50KSE7XG5cbiAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChcbiAgICAgIGV2ZW50LmtleSA9PT0gXCJUYWJcIiAmJlxuICAgICAgcG9wb3ZlclJlZi5jdXJyZW50ICYmXG4gICAgICB0YWJiYWJsZShwb3BvdmVyUmVmLmN1cnJlbnQpLmxlbmd0aCA9PT0gMFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5rZXkgPT09IFwiVGFiXCIgJiYgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIGlmIChzaGlmdFRhYmJlZEZyb21FbGVtZW50QWZ0ZXJUcmlnZ2VyKGV2ZW50KSkge1xuICAgICAgICBmb2N1c0xhc3RUYWJiYWJsZUluUG9wb3ZlcihldmVudCk7XG4gICAgICB9IGVsc2UgaWYgKHNoaWZ0VGFiYmVkT3V0T2ZQb3BvdmVyKGV2ZW50KSkge1xuICAgICAgICBmb2N1c1RyaWdnZXJSZWYoZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChzaGlmdFRhYmJlZFRvQnJvd3NlckNocm9tZShldmVudCkpIHtcbiAgICAgICAgZGlzYWJsZVRhYmJhYmxlc0luUG9wb3ZlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICBpZiAodGFiYmVkRnJvbVRyaWdnZXJUb1BvcG92ZXIoKSkge1xuICAgICAgICBmb2N1c0ZpcnN0UG9wb3ZlclRhYmJhYmxlKGV2ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAodGFiYmVkT3V0T2ZQb3BvdmVyKCkpIHtcbiAgICAgICAgZm9jdXNUYWJiYWJsZUFmdGVyVHJpZ2dlcihldmVudCk7XG4gICAgICB9IGVsc2UgaWYgKHRhYmJlZFRvQnJvd3NlckNocm9tZShldmVudCkpIHtcbiAgICAgICAgZGlzYWJsZVRhYmJhYmxlc0luUG9wb3ZlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgb3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgb3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRBZnRlclRyaWdnZXIoKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0YWJiYWJsZShvd25lckRvY3VtZW50KTtcbiAgICBjb25zdCB0YXJnZXRJbmRleCA9XG4gICAgICBlbGVtZW50cyAmJiB0cmlnZ2VyUmVmLmN1cnJlbnRcbiAgICAgICAgPyBlbGVtZW50cy5pbmRleE9mKHRyaWdnZXJSZWYuY3VycmVudClcbiAgICAgICAgOiAtMTtcbiAgICBjb25zdCBlbGVtZW50QWZ0ZXJUcmlnZ2VyID0gZWxlbWVudHMgJiYgZWxlbWVudHNbdGFyZ2V0SW5kZXggKyAxXTtcbiAgICByZXR1cm4gcG9wb3ZlclJlZi5jdXJyZW50ICYmXG4gICAgICBwb3BvdmVyUmVmLmN1cnJlbnQuY29udGFpbnMoZWxlbWVudEFmdGVyVHJpZ2dlciB8fCBudWxsKVxuICAgICAgPyBmYWxzZVxuICAgICAgOiBlbGVtZW50QWZ0ZXJUcmlnZ2VyO1xuICB9XG5cbiAgZnVuY3Rpb24gdGFiYmVkRnJvbVRyaWdnZXJUb1BvcG92ZXIoKSB7XG4gICAgcmV0dXJuIHRyaWdnZXJSZWYuY3VycmVudFxuICAgICAgPyB0cmlnZ2VyUmVmLmN1cnJlbnQgPT09IG93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgICAgOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvY3VzRmlyc3RQb3BvdmVyVGFiYmFibGUoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHBvcG92ZXJSZWYuY3VycmVudCAmJiB0YWJiYWJsZShwb3BvdmVyUmVmLmN1cnJlbnQpO1xuICAgIGlmIChlbGVtZW50cyAmJiBlbGVtZW50c1swXSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGVsZW1lbnRzWzBdLmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGFiYmVkT3V0T2ZQb3BvdmVyKCkge1xuICAgIGNvbnN0IGluUG9wb3ZlciA9IHBvcG92ZXJSZWYuY3VycmVudFxuICAgICAgPyBwb3BvdmVyUmVmLmN1cnJlbnQuY29udGFpbnMob3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IG51bGwpXG4gICAgICA6IGZhbHNlO1xuICAgIGlmIChpblBvcG92ZXIpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gcG9wb3ZlclJlZi5jdXJyZW50ICYmIHRhYmJhYmxlKHBvcG92ZXJSZWYuY3VycmVudCk7XG4gICAgICByZXR1cm4gQm9vbGVhbihcbiAgICAgICAgZWxlbWVudHMgJiZcbiAgICAgICAgICBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXSA9PT0gb3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBmb2N1c1RhYmJhYmxlQWZ0ZXJUcmlnZ2VyKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3QgZWxlbWVudEFmdGVyVHJpZ2dlciA9IGdldEVsZW1lbnRBZnRlclRyaWdnZXIoKTtcbiAgICBpZiAoZWxlbWVudEFmdGVyVHJpZ2dlcikge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGVsZW1lbnRBZnRlclRyaWdnZXIuZm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzaGlmdFRhYmJlZEZyb21FbGVtZW50QWZ0ZXJUcmlnZ2VyKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5zaGlmdEtleSkgcmV0dXJuO1xuICAgIGNvbnN0IGVsZW1lbnRBZnRlclRyaWdnZXIgPSBnZXRFbGVtZW50QWZ0ZXJUcmlnZ2VyKCk7XG4gICAgcmV0dXJuIGV2ZW50LnRhcmdldCA9PT0gZWxlbWVudEFmdGVyVHJpZ2dlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvY3VzTGFzdFRhYmJhYmxlSW5Qb3BvdmVyKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBwb3BvdmVyUmVmLmN1cnJlbnQgJiYgdGFiYmFibGUocG9wb3ZlclJlZi5jdXJyZW50KTtcbiAgICBjb25zdCBsYXN0ID0gZWxlbWVudHMgJiYgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBsYXN0LmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2hpZnRUYWJiZWRPdXRPZlBvcG92ZXIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHBvcG92ZXJSZWYuY3VycmVudCAmJiB0YWJiYWJsZShwb3BvdmVyUmVmLmN1cnJlbnQpO1xuICAgIGlmIChlbGVtZW50cykge1xuICAgICAgcmV0dXJuIGVsZW1lbnRzLmxlbmd0aCA9PT0gMCA/IGZhbHNlIDogZXZlbnQudGFyZ2V0ID09PSBlbGVtZW50c1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9jdXNUcmlnZ2VyUmVmKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0cmlnZ2VyUmVmLmN1cnJlbnQ/LmZvY3VzKCk7XG4gIH1cblxuICBmdW5jdGlvbiB0YWJiZWRUb0Jyb3dzZXJDaHJvbWUoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHBvcG92ZXJSZWYuY3VycmVudFxuICAgICAgPyB0YWJiYWJsZShvd25lckRvY3VtZW50KS5maWx0ZXIoXG4gICAgICAgICAgKGVsZW1lbnQpID0+ICFwb3BvdmVyUmVmLmN1cnJlbnQhLmNvbnRhaW5zKGVsZW1lbnQpXG4gICAgICAgIClcbiAgICAgIDogbnVsbDtcbiAgICByZXR1cm4gZWxlbWVudHMgPyBldmVudC50YXJnZXQgPT09IGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdIDogZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBzaGlmdFRhYmJlZFRvQnJvd3NlckNocm9tZShldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIC8vIHdlJ3JlIGFzc3VtaW5nIHRoZSBwb3BvdmVyIHdpbGwgbmV2ZXIgY29udGFpbiB0aGUgZmlyc3QgdGFiYmFibGVcbiAgICAvLyBlbGVtZW50LCBhbmQgaXQgYmV0dGVyIG5vdCwgYmVjYXVzZSB0aGUgdHJpZ2dlciBuZWVkcyB0byBiZSB0YWJiYWJsZSFcbiAgICByZXR1cm4gZXZlbnQudGFyZ2V0ID09PSB0YWJiYWJsZShvd25lckRvY3VtZW50KVswXTtcbiAgfVxuXG4gIGxldCByZXN0b3JlVGFiSW5kZXhUdXBsw6lzOiBbSFRNTEVsZW1lbnQsIG51bWJlcl1bXSA9IFtdO1xuXG4gIGZ1bmN0aW9uIGRpc2FibGVUYWJiYWJsZXNJblBvcG92ZXIoKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBwb3BvdmVyUmVmLmN1cnJlbnQgJiYgdGFiYmFibGUocG9wb3ZlclJlZi5jdXJyZW50KTtcbiAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgcmVzdG9yZVRhYkluZGV4VHVwbMOpcy5wdXNoKFtlbGVtZW50LCBlbGVtZW50LnRhYkluZGV4XSk7XG4gICAgICAgIGVsZW1lbnQudGFiSW5kZXggPSAtMTtcbiAgICAgIH0pO1xuICAgICAgb3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBlbmFibGVUYWJiYWJsZXNJblBvcG92ZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuYWJsZVRhYmJhYmxlc0luUG9wb3ZlcigpIHtcbiAgICBvd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGVuYWJsZVRhYmJhYmxlc0luUG9wb3Zlcik7XG4gICAgcmVzdG9yZVRhYkluZGV4VHVwbMOpcy5mb3JFYWNoKChbZWxlbWVudCwgdGFiSW5kZXhdKSA9PiB7XG4gICAgICBlbGVtZW50LnRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFR5cGVzXG5cbnR5cGUgUG9zaXRpb24gPSAoXG4gIHRhcmdldFJlY3Q/OiBQUmVjdCB8IG51bGwsXG4gIHBvcG92ZXJSZWN0PzogUFJlY3QgfCBudWxsLFxuICAuLi51bnN0YWJsZV9vYnNlcnZhYmxlTm9kZXM6IFBvc3NpYmxlTm9kZVtdXG4pID0+IFJlYWN0LkNTU1Byb3BlcnRpZXM7XG5cbnR5cGUgUG9zc2libGVOb2RlID0gbnVsbCB8IHVuZGVmaW5lZCB8IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudDtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEV4cG9ydHNcblxuZXhwb3J0IGRlZmF1bHQgUG9wb3ZlcjtcbmV4cG9ydCB0eXBlIHsgUG9wb3ZlclByb3BzLCBQb3NpdGlvbiB9O1xuZXhwb3J0IHtcbiAgZ2V0Q29sbGlzaW9ucyxcbiAgUG9wb3ZlcixcbiAgcG9zaXRpb25EZWZhdWx0LFxuICBwb3NpdGlvbk1hdGNoV2lkdGgsXG4gIHBvc2l0aW9uUmlnaHQsXG59O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFZQTs7Ozs7QUFHQTtBQUlBO0FBRUE7QUFBQTtBQU5BO0FBQ0E7QUErQkE7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7Ozs7QUFNQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBREE7QUFyQkE7QUFDQTtBQW1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUFBOzs7QUFFQTtBQUlBO0FBSkE7QUFNQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7O0FBT0E7QUFHQTtBQUFBOzs7QUFDQTtBQUFBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBTkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7OyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@reach/popover/dist/popover.esm.js\n");

/***/ }),

/***/ "../node_modules/@reach/popover/node_modules/@reach/rect/dist/rect.esm.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@reach/popover/node_modules/@reach/rect/dist/rect.esm.js ***!
  \********************************************************************************/
/*! exports provided: default, Rect, useRect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rect\", function() { return Rect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useRect\", function() { return useRect; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"../node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _reach_observe_rect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reach/observe-rect */ \"../node_modules/@reach/observe-rect/dist/observe-rect.esm.js\");\n/* harmony import */ var _reach_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @reach/utils */ \"../node_modules/@reach/utils/dist/utils.esm.js\");\n\n\n\n\n/**\r\n * Welcome to @reach/rect!\r\n *\r\n * Measures DOM elements (aka. bounding client rect).\r\n *\r\n * @see getBoundingClientRect https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\r\n * @see Docs                  https://reach.tech/rect\r\n * @see Source                https://github.com/reach/reach-ui/tree/main/packages/rect\r\n */\n\n/**\r\n * Rect\r\n *\r\n * @param props\r\n */\n\nvar Rect = function Rect(_ref) {\n  var onChange = _ref.onChange,\n      _ref$observe = _ref.observe,\n      observe = _ref$observe === void 0 ? true : _ref$observe,\n      children = _ref.children;\n  var ref = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(null);\n  var rect = useRect(ref, {\n    observe: observe,\n    onChange: onChange\n  });\n  return children({\n    ref: ref,\n    rect: rect\n  });\n};\n\nif (true) {\n  Rect.displayName = \"Rect\";\n  Rect.propTypes = {\n    children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,\n    observe: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n    onChange: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func\n  };\n}\n/**\r\n * useRect\r\n *\r\n * @param nodeRef\r\n * @param observe\r\n * @param onChange\r\n */\n\n\nfunction useRect(nodeRef, observeOrOptions, deprecated_onChange) {\n  var observe;\n  var onChange;\n\n  if (Object(_reach_utils__WEBPACK_IMPORTED_MODULE_3__[\"isBoolean\"])(observeOrOptions)) {\n    observe = observeOrOptions;\n  } else {\n    var _observeOrOptions$obs;\n\n    observe = (_observeOrOptions$obs = observeOrOptions === null || observeOrOptions === void 0 ? void 0 : observeOrOptions.observe) !== null && _observeOrOptions$obs !== void 0 ? _observeOrOptions$obs : true;\n    onChange = observeOrOptions === null || observeOrOptions === void 0 ? void 0 : observeOrOptions.onChange;\n  }\n\n  if (Object(_reach_utils__WEBPACK_IMPORTED_MODULE_3__[\"isFunction\"])(deprecated_onChange)) {\n    onChange = deprecated_onChange;\n  }\n\n  if (true) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n       true ? Object(_reach_utils__WEBPACK_IMPORTED_MODULE_3__[\"warning\"])(!Object(_reach_utils__WEBPACK_IMPORTED_MODULE_3__[\"isBoolean\"])(observeOrOptions), \"Passing `observe` as the second argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `observe` property as the second argument (`useRect(ref, { observe })`).\\n\" + \"See https://reach.tech/rect#userect-observe\") : undefined;\n    }, [observeOrOptions]); // eslint-disable-next-line react-hooks/rules-of-hooks\n\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n       true ? Object(_reach_utils__WEBPACK_IMPORTED_MODULE_3__[\"warning\"])(!Object(_reach_utils__WEBPACK_IMPORTED_MODULE_3__[\"isFunction\"])(deprecated_onChange), \"Passing `onChange` as the third argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `onChange` property as the second argument (`useRect(ref, { onChange })`).\\n\" + \"See https://reach.tech/rect#userect-onchange\") : undefined;\n    }, [deprecated_onChange]);\n  }\n\n  var _React$useState = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(nodeRef.current),\n      element = _React$useState[0],\n      setElement = _React$useState[1];\n\n  var initialRectIsSet = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\n  var initialRefIsSet = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\n\n  var _React$useState2 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(null),\n      rect = _React$useState2[0],\n      setRect = _React$useState2[1];\n\n  var onChangeRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(onChange);\n  var stableOnChange = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(function (rect) {\n    onChangeRef.current && onChangeRef.current(rect);\n  }, []); // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  Object(_reach_utils__WEBPACK_IMPORTED_MODULE_3__[\"useIsomorphicLayoutEffect\"])(function () {\n    onChangeRef.current = onChange;\n\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n  Object(_reach_utils__WEBPACK_IMPORTED_MODULE_3__[\"useIsomorphicLayoutEffect\"])(function () {\n    if (element && !initialRectIsSet.current) {\n      initialRectIsSet.current = true;\n      setRect(element.getBoundingClientRect());\n    }\n  }, [element]);\n  Object(_reach_utils__WEBPACK_IMPORTED_MODULE_3__[\"useIsomorphicLayoutEffect\"])(function () {\n    var observer;\n    var elem = element; // State initializes before refs are placed, meaning the element state will\n    // be undefined on the first render. We still want the rect on the first\n    // render, so initially we'll use the nodeRef that was passed instead of\n    // state for our measurements.\n\n    if (!initialRefIsSet.current) {\n      initialRefIsSet.current = true;\n      elem = nodeRef.current;\n    }\n\n    if (!elem) {\n      if (true) {\n        console.warn(\"You need to place the ref\");\n      }\n\n      return cleanup;\n    }\n\n    observer = Object(_reach_observe_rect__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(elem, function (rect) {\n      stableOnChange(rect);\n      setRect(rect);\n    });\n    observe && observer.observe();\n    return cleanup;\n\n    function cleanup() {\n      observer && observer.unobserve();\n    }\n  }, [observe, element, nodeRef, stableOnChange]);\n  return rect;\n} ////////////////////////////////////////////////////////////////////////////////\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Rect);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0ByZWFjaC9wb3BvdmVyL25vZGVfbW9kdWxlcy9AcmVhY2gvcmVjdC9kaXN0L3JlY3QuZXNtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3NyYy9pbmRleC50c3g/ZGViNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFdlbGNvbWUgdG8gQHJlYWNoL3JlY3QhXG4gKlxuICogTWVhc3VyZXMgRE9NIGVsZW1lbnRzIChha2EuIGJvdW5kaW5nIGNsaWVudCByZWN0KS5cbiAqXG4gKiBAc2VlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9nZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBzZWUgRG9jcyAgICAgICAgICAgICAgICAgIGh0dHBzOi8vcmVhY2gudGVjaC9yZWN0XG4gKiBAc2VlIFNvdXJjZSAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcmVhY2gvcmVhY2gtdWkvdHJlZS9tYWluL3BhY2thZ2VzL3JlY3RcbiAqL1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCBvYnNlcnZlUmVjdCBmcm9tIFwiQHJlYWNoL29ic2VydmUtcmVjdFwiO1xuaW1wb3J0IHtcbiAgaXNCb29sZWFuLFxuICBpc0Z1bmN0aW9uLFxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdCxcbiAgd2FybmluZyxcbn0gZnJvbSBcIkByZWFjaC91dGlsc1wiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIFJlY3RcbiAqXG4gKiBAcGFyYW0gcHJvcHNcbiAqL1xuY29uc3QgUmVjdDogUmVhY3QuRkM8UmVjdFByb3BzPiA9ICh7IG9uQ2hhbmdlLCBvYnNlcnZlID0gdHJ1ZSwgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWY8SFRNTEVsZW1lbnQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgcmVjdCA9IHVzZVJlY3QocmVmLCB7IG9ic2VydmUsIG9uQ2hhbmdlIH0pO1xuICByZXR1cm4gY2hpbGRyZW4oeyByZWYsIHJlY3QgfSk7XG59O1xuXG4vKipcbiAqIEBzZWUgRG9jcyBodHRwczovL3JlYWNoLnRlY2gvcmVjdCNyZWN0LXByb3BzXG4gKi9cbnR5cGUgUmVjdFByb3BzID0gVXNlUmVjdE9wdGlvbnMgJiB7XG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgY2FsbHMgYmFjayB0byB5b3Ugd2l0aCBhIGByZWZgIHRvIHBsYWNlIG9uIGFuIGVsZW1lbnQgYW5kXG4gICAqIHRoZSBgcmVjdGAgbWVhc3VyZW1lbnRzIG9mIHRoZSBkb20gbm9kZS5cbiAgICpcbiAgICogKipOb3RlKio6IE9uIHRoZSBmaXJzdCByZW5kZXIgYHJlY3RgIHdpbGwgYmUgYHVuZGVmaW5lZGAgYmVjYXVzZSB3ZSBjYW4ndFxuICAgKiBtZWFzdXJlIGEgbm9kZSB0aGF0IGhhcyBub3QgeWV0IGJlZW4gcmVuZGVyZWQuIE1ha2Ugc3VyZSB5b3VyIGNvZGUgYWNjb3VudHNcbiAgICogZm9yIHRoaXMuXG4gICAqXG4gICAqIEBzZWUgRG9jcyBodHRwczovL3JlYWNoLnRlY2gvcmVjdCNyZWN0LW9uY2hhbmdlXG4gICAqL1xuICBjaGlsZHJlbihhcmdzOiB7XG4gICAgcmVjdDogUFJlY3QgfCBudWxsO1xuICAgIHJlZjogUmVhY3QuUmVmT2JqZWN0PGFueT47XG4gIH0pOiBKU1guRWxlbWVudDtcbn07XG5cbmlmIChfX0RFVl9fKSB7XG4gIFJlY3QuZGlzcGxheU5hbWUgPSBcIlJlY3RcIjtcbiAgUmVjdC5wcm9wVHlwZXMgPSB7XG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgb2JzZXJ2ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICB9O1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiB1c2VSZWN0PFQgZXh0ZW5kcyBFbGVtZW50ID0gSFRNTEVsZW1lbnQ+KFxuICBub2RlUmVmOiBSZWFjdC5SZWZPYmplY3Q8VCB8IHVuZGVmaW5lZCB8IG51bGw+LFxuICBvcHRpb25zPzogVXNlUmVjdE9wdGlvbnNcbik6IG51bGwgfCBET01SZWN0O1xuXG5mdW5jdGlvbiB1c2VSZWN0PFQgZXh0ZW5kcyBFbGVtZW50ID0gSFRNTEVsZW1lbnQ+KFxuICBub2RlUmVmOiBSZWFjdC5SZWZPYmplY3Q8VCB8IHVuZGVmaW5lZCB8IG51bGw+LFxuICBvYnNlcnZlPzogVXNlUmVjdE9wdGlvbnNbXCJvYnNlcnZlXCJdLFxuICBvbkNoYW5nZT86IFVzZVJlY3RPcHRpb25zW1wib25DaGFuZ2VcIl1cbik6IG51bGwgfCBET01SZWN0O1xuXG4vKipcbiAqIHVzZVJlY3RcbiAqXG4gKiBAcGFyYW0gbm9kZVJlZlxuICogQHBhcmFtIG9ic2VydmVcbiAqIEBwYXJhbSBvbkNoYW5nZVxuICovXG5mdW5jdGlvbiB1c2VSZWN0PFQgZXh0ZW5kcyBFbGVtZW50ID0gSFRNTEVsZW1lbnQ+KFxuICBub2RlUmVmOiBSZWFjdC5SZWZPYmplY3Q8VCB8IHVuZGVmaW5lZCB8IG51bGw+LFxuICBvYnNlcnZlT3JPcHRpb25zPzogYm9vbGVhbiB8IFVzZVJlY3RPcHRpb25zLFxuICBkZXByZWNhdGVkX29uQ2hhbmdlPzogVXNlUmVjdE9wdGlvbnNbXCJvbkNoYW5nZVwiXVxuKTogbnVsbCB8IERPTVJlY3Qge1xuICBsZXQgb2JzZXJ2ZTogYm9vbGVhbjtcbiAgbGV0IG9uQ2hhbmdlOiBVc2VSZWN0T3B0aW9uc1tcIm9uQ2hhbmdlXCJdO1xuICBpZiAoaXNCb29sZWFuKG9ic2VydmVPck9wdGlvbnMpKSB7XG4gICAgb2JzZXJ2ZSA9IG9ic2VydmVPck9wdGlvbnM7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSA9IG9ic2VydmVPck9wdGlvbnM/Lm9ic2VydmUgPz8gdHJ1ZTtcbiAgICBvbkNoYW5nZSA9IG9ic2VydmVPck9wdGlvbnM/Lm9uQ2hhbmdlO1xuICB9XG4gIGlmIChpc0Z1bmN0aW9uKGRlcHJlY2F0ZWRfb25DaGFuZ2UpKSB7XG4gICAgb25DaGFuZ2UgPSBkZXByZWNhdGVkX29uQ2hhbmdlO1xuICB9XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgIWlzQm9vbGVhbihvYnNlcnZlT3JPcHRpb25zKSxcbiAgICAgICAgXCJQYXNzaW5nIGBvYnNlcnZlYCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGB1c2VSZWN0YCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjaCBVSS4gSW5zdGVhZCwgeW91IGNhbiBwYXNzIGFuIG9iamVjdCBvZiBvcHRpb25zIHdpdGggYW4gYG9ic2VydmVgIHByb3BlcnR5IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgKGB1c2VSZWN0KHJlZiwgeyBvYnNlcnZlIH0pYCkuXFxuXCIgK1xuICAgICAgICAgIFwiU2VlIGh0dHBzOi8vcmVhY2gudGVjaC9yZWN0I3VzZXJlY3Qtb2JzZXJ2ZVwiXG4gICAgICApO1xuICAgIH0sIFtvYnNlcnZlT3JPcHRpb25zXSk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgIWlzRnVuY3Rpb24oZGVwcmVjYXRlZF9vbkNoYW5nZSksXG4gICAgICAgIFwiUGFzc2luZyBgb25DaGFuZ2VgIGFzIHRoZSB0aGlyZCBhcmd1bWVudCB0byBgdXNlUmVjdGAgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgUmVhY2ggVUkuIEluc3RlYWQsIHlvdSBjYW4gcGFzcyBhbiBvYmplY3Qgb2Ygb3B0aW9ucyB3aXRoIGFuIGBvbkNoYW5nZWAgcHJvcGVydHkgYXMgdGhlIHNlY29uZCBhcmd1bWVudCAoYHVzZVJlY3QocmVmLCB7IG9uQ2hhbmdlIH0pYCkuXFxuXCIgK1xuICAgICAgICAgIFwiU2VlIGh0dHBzOi8vcmVhY2gudGVjaC9yZWN0I3VzZXJlY3Qtb25jaGFuZ2VcIlxuICAgICAgKTtcbiAgICB9LCBbZGVwcmVjYXRlZF9vbkNoYW5nZV0pO1xuICB9XG5cbiAgbGV0IFtlbGVtZW50LCBzZXRFbGVtZW50XSA9IFJlYWN0LnVzZVN0YXRlKG5vZGVSZWYuY3VycmVudCk7XG4gIGxldCBpbml0aWFsUmVjdElzU2V0ID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgbGV0IGluaXRpYWxSZWZJc1NldCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGxldCBbcmVjdCwgc2V0UmVjdF0gPSBSZWFjdC51c2VTdGF0ZTxET01SZWN0IHwgbnVsbD4obnVsbCk7XG4gIGxldCBvbkNoYW5nZVJlZiA9IFJlYWN0LnVzZVJlZihvbkNoYW5nZSk7XG4gIGxldCBzdGFibGVPbkNoYW5nZSA9IFJlYWN0LnVzZUNhbGxiYWNrKChyZWN0OiBQUmVjdCkgPT4ge1xuICAgIG9uQ2hhbmdlUmVmLmN1cnJlbnQgJiYgb25DaGFuZ2VSZWYuY3VycmVudChyZWN0KTtcbiAgfSwgW10pO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBvbkNoYW5nZVJlZi5jdXJyZW50ID0gb25DaGFuZ2U7XG4gICAgaWYgKG5vZGVSZWYuY3VycmVudCAhPT0gZWxlbWVudCkge1xuICAgICAgc2V0RWxlbWVudChub2RlUmVmLmN1cnJlbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZWxlbWVudCAmJiAhaW5pdGlhbFJlY3RJc1NldC5jdXJyZW50KSB7XG4gICAgICBpbml0aWFsUmVjdElzU2V0LmN1cnJlbnQgPSB0cnVlO1xuICAgICAgc2V0UmVjdChlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICB9XG4gIH0sIFtlbGVtZW50XSk7XG5cbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBsZXQgb2JzZXJ2ZXI6IFJldHVyblR5cGU8dHlwZW9mIG9ic2VydmVSZWN0PjtcbiAgICBsZXQgZWxlbSA9IGVsZW1lbnQ7XG5cbiAgICAvLyBTdGF0ZSBpbml0aWFsaXplcyBiZWZvcmUgcmVmcyBhcmUgcGxhY2VkLCBtZWFuaW5nIHRoZSBlbGVtZW50IHN0YXRlIHdpbGxcbiAgICAvLyBiZSB1bmRlZmluZWQgb24gdGhlIGZpcnN0IHJlbmRlci4gV2Ugc3RpbGwgd2FudCB0aGUgcmVjdCBvbiB0aGUgZmlyc3RcbiAgICAvLyByZW5kZXIsIHNvIGluaXRpYWxseSB3ZSdsbCB1c2UgdGhlIG5vZGVSZWYgdGhhdCB3YXMgcGFzc2VkIGluc3RlYWQgb2ZcbiAgICAvLyBzdGF0ZSBmb3Igb3VyIG1lYXN1cmVtZW50cy5cbiAgICBpZiAoIWluaXRpYWxSZWZJc1NldC5jdXJyZW50KSB7XG4gICAgICBpbml0aWFsUmVmSXNTZXQuY3VycmVudCA9IHRydWU7XG4gICAgICBlbGVtID0gbm9kZVJlZi5jdXJyZW50O1xuICAgIH1cblxuICAgIGlmICghZWxlbSkge1xuICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiWW91IG5lZWQgdG8gcGxhY2UgdGhlIHJlZlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgIH1cblxuICAgIG9ic2VydmVyID0gb2JzZXJ2ZVJlY3QoZWxlbSwgKHJlY3QpID0+IHtcbiAgICAgIHN0YWJsZU9uQ2hhbmdlKHJlY3QpO1xuICAgICAgc2V0UmVjdChyZWN0KTtcbiAgICB9KTtcblxuICAgIG9ic2VydmUgJiYgb2JzZXJ2ZXIub2JzZXJ2ZSgpO1xuICAgIHJldHVybiBjbGVhbnVwO1xuXG4gICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIG9ic2VydmVyICYmIG9ic2VydmVyLnVub2JzZXJ2ZSgpO1xuICAgIH1cbiAgfSwgW29ic2VydmUsIGVsZW1lbnQsIG5vZGVSZWYsIHN0YWJsZU9uQ2hhbmdlXSk7XG5cbiAgcmV0dXJuIHJlY3Q7XG59XG5cbi8qKlxuICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9yZWN0I3VzZXJlY3RcbiAqL1xudHlwZSBVc2VSZWN0T3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIFRlbGxzIGBSZWN0YCB0byBvYnNlcnZlIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBvciBub3QuIFdoaWxlIG9ic2VydmluZyxcbiAgICogdGhlIGBjaGlsZHJlbmAgcmVuZGVyIHByb3AgbWF5IGNhbGwgYmFjayB2ZXJ5IHF1aWNrbHkgKGVzcGVjaWFsbHkgd2hpbGVcbiAgICogc2Nyb2xsaW5nKSBzbyBpdCBjYW4gYmUgaW1wb3J0YW50IGZvciBwZXJmb3JtYW5jZSB0byBhdm9pZCBvYnNlcnZpbmcgd2hlblxuICAgKiB5b3UgZG9uJ3QgbmVlZCB0by5cbiAgICpcbiAgICogVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCBmb3IgZWxlbWVudHMgdGhhdCBwb3Agb3ZlciBvdGhlciBlbGVtZW50cyAobGlrZSBhXG4gICAqIGRyb3Bkb3duIG1lbnUpLCBzbyB5b3UgZG9uJ3QgbmVlZCB0byBvYnNlcnZlIGFsbCB0aGUgdGltZSwgb25seSB3aGVuIHRoZVxuICAgKiBwb3B1cCBpcyBhY3RpdmUuXG4gICAqXG4gICAqIFBhc3MgYHRydWVgIHRvIG9ic2VydmUsIGBmYWxzZWAgdG8gaWdub3JlLlxuICAgKlxuICAgKiBAc2VlIERvY3MgaHR0cHM6Ly9yZWFjaC50ZWNoL3JlY3QjdXNlcmVjdC1vYnNlcnZlXG4gICAqL1xuICBvYnNlcnZlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIENhbGxzIGJhY2sgd2hlbmV2ZXIgdGhlIGByZWN0YCBvZiB0aGUgZWxlbWVudCBjaGFuZ2VzLlxuICAgKlxuICAgKiBAc2VlIERvY3MgaHR0cHM6Ly9yZWFjaC50ZWNoL3JlY3QjdXNlcmVjdC1vbmNoYW5nZVxuICAgKi9cbiAgb25DaGFuZ2U/OiAocmVjdDogUFJlY3QpID0+IHZvaWQ7XG59O1xuXG50eXBlIFBSZWN0ID0gUGFydGlhbDxET01SZWN0PiAmIHtcbiAgcmVhZG9ubHkgYm90dG9tOiBudW1iZXI7XG4gIHJlYWRvbmx5IGhlaWdodDogbnVtYmVyO1xuICByZWFkb25seSBsZWZ0OiBudW1iZXI7XG4gIHJlYWRvbmx5IHJpZ2h0OiBudW1iZXI7XG4gIHJlYWRvbmx5IHRvcDogbnVtYmVyO1xuICByZWFkb25seSB3aWR0aDogbnVtYmVyO1xufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEV4cG9ydHNcblxuZXhwb3J0IGRlZmF1bHQgUmVjdDtcbmV4cG9ydCB0eXBlIHsgUFJlY3QsIFVzZVJlY3RPcHRpb25zLCBSZWN0UHJvcHMgfTtcbmV4cG9ydCB7IFJlY3QsIHVzZVJlY3QgfTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7O0FBc0JBOzs7Ozs7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBOzs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQWVBOzs7Ozs7Ozs7QUFPQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBUUE7QUFDQTtBQURBO0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5QkE7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7OyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@reach/popover/node_modules/@reach/rect/dist/rect.esm.js\n");

/***/ }),

/***/ "../node_modules/@reach/portal/dist/portal.esm.js":
/*!********************************************************!*\
  !*** ../node_modules/@reach/portal/dist/portal.esm.js ***!
  \********************************************************/
/*! exports provided: default, Portal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Portal\", function() { return Portal; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _reach_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reach/utils */ \"../node_modules/@reach/utils/dist/utils.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"../node_modules/@hot-loader/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n/**\r\n * Welcome to @reach/portal!\r\n *\r\n * Creates and appends a DOM node to the end of `document.body` and renders a\r\n * React tree into it. Useful for rendering a natural React element hierarchy\r\n * with a different DOM hierarchy to prevent parent styles from clipping or\r\n * hiding content (for popovers, dropdowns, and modals).\r\n *\r\n * @see Docs   https://reach.tech/portal\r\n * @see Source https://github.com/reach/reach-ui/tree/main/packages/portal\r\n * @see React  https://reactjs.org/docs/portals.html\r\n */\n\n/**\r\n * Portal\r\n *\r\n * @see Docs https://reach.tech/portal#portal\r\n */\n\nvar Portal = function Portal(_ref) {\n  var children = _ref.children,\n      _ref$type = _ref.type,\n      type = _ref$type === void 0 ? \"reach-portal\" : _ref$type;\n  var mountNode = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(null);\n  var portalNode = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(null);\n  var forceUpdate = Object(_reach_utils__WEBPACK_IMPORTED_MODULE_1__[\"useForceUpdate\"])();\n  Object(_reach_utils__WEBPACK_IMPORTED_MODULE_1__[\"useIsomorphicLayoutEffect\"])(function () {\n    // This ref may be null when a hot-loader replaces components on the page\n    if (!mountNode.current) return; // It's possible that the content of the portal has, itself, been portaled.\n    // In that case, it's important to append to the correct document element.\n\n    var ownerDocument = mountNode.current.ownerDocument;\n    portalNode.current = ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.createElement(type);\n    ownerDocument.body.appendChild(portalNode.current);\n    forceUpdate();\n    return function () {\n      if (portalNode.current && portalNode.current.ownerDocument) {\n        portalNode.current.ownerDocument.body.removeChild(portalNode.current);\n      }\n    };\n  }, [type, forceUpdate]);\n  return portalNode.current ? Object(react_dom__WEBPACK_IMPORTED_MODULE_2__[\"createPortal\"])(children, portalNode.current) : Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(\"span\", {\n    ref: mountNode\n  });\n};\n\nif (true) {\n  Portal.displayName = \"Portal\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Portal);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0ByZWFjaC9wb3J0YWwvZGlzdC9wb3J0YWwuZXNtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3NyYy9pbmRleC50c3g/ZGViNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFdlbGNvbWUgdG8gQHJlYWNoL3BvcnRhbCFcbiAqXG4gKiBDcmVhdGVzIGFuZCBhcHBlbmRzIGEgRE9NIG5vZGUgdG8gdGhlIGVuZCBvZiBgZG9jdW1lbnQuYm9keWAgYW5kIHJlbmRlcnMgYVxuICogUmVhY3QgdHJlZSBpbnRvIGl0LiBVc2VmdWwgZm9yIHJlbmRlcmluZyBhIG5hdHVyYWwgUmVhY3QgZWxlbWVudCBoaWVyYXJjaHlcbiAqIHdpdGggYSBkaWZmZXJlbnQgRE9NIGhpZXJhcmNoeSB0byBwcmV2ZW50IHBhcmVudCBzdHlsZXMgZnJvbSBjbGlwcGluZyBvclxuICogaGlkaW5nIGNvbnRlbnQgKGZvciBwb3BvdmVycywgZHJvcGRvd25zLCBhbmQgbW9kYWxzKS5cbiAqXG4gKiBAc2VlIERvY3MgICBodHRwczovL3JlYWNoLnRlY2gvcG9ydGFsXG4gKiBAc2VlIFNvdXJjZSBodHRwczovL2dpdGh1Yi5jb20vcmVhY2gvcmVhY2gtdWkvdHJlZS9tYWluL3BhY2thZ2VzL3BvcnRhbFxuICogQHNlZSBSZWFjdCAgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3BvcnRhbHMuaHRtbFxuICovXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCwgdXNlRm9yY2VVcGRhdGUgfSBmcm9tIFwiQHJlYWNoL3V0aWxzXCI7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tIFwicmVhY3QtZG9tXCI7XG5cbi8qKlxuICogUG9ydGFsXG4gKlxuICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9wb3J0YWwjcG9ydGFsXG4gKi9cbmNvbnN0IFBvcnRhbDogUmVhY3QuRkM8UG9ydGFsUHJvcHM+ID0gKHsgY2hpbGRyZW4sIHR5cGUgPSBcInJlYWNoLXBvcnRhbFwiIH0pID0+IHtcbiAgbGV0IG1vdW50Tm9kZSA9IFJlYWN0LnVzZVJlZjxIVE1MRGl2RWxlbWVudCB8IG51bGw+KG51bGwpO1xuICBsZXQgcG9ydGFsTm9kZSA9IFJlYWN0LnVzZVJlZjxIVE1MRWxlbWVudCB8IG51bGw+KG51bGwpO1xuICBsZXQgZm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZSgpO1xuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFRoaXMgcmVmIG1heSBiZSBudWxsIHdoZW4gYSBob3QtbG9hZGVyIHJlcGxhY2VzIGNvbXBvbmVudHMgb24gdGhlIHBhZ2VcbiAgICBpZiAoIW1vdW50Tm9kZS5jdXJyZW50KSByZXR1cm47XG4gICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHRoZSBjb250ZW50IG9mIHRoZSBwb3J0YWwgaGFzLCBpdHNlbGYsIGJlZW4gcG9ydGFsZWQuXG4gICAgLy8gSW4gdGhhdCBjYXNlLCBpdCdzIGltcG9ydGFudCB0byBhcHBlbmQgdG8gdGhlIGNvcnJlY3QgZG9jdW1lbnQgZWxlbWVudC5cbiAgICBjb25zdCBvd25lckRvY3VtZW50ID0gbW91bnROb2RlLmN1cnJlbnQhLm93bmVyRG9jdW1lbnQ7XG4gICAgcG9ydGFsTm9kZS5jdXJyZW50ID0gb3duZXJEb2N1bWVudD8uY3JlYXRlRWxlbWVudCh0eXBlKSE7XG4gICAgb3duZXJEb2N1bWVudCEuYm9keS5hcHBlbmRDaGlsZChwb3J0YWxOb2RlLmN1cnJlbnQpO1xuICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChwb3J0YWxOb2RlLmN1cnJlbnQgJiYgcG9ydGFsTm9kZS5jdXJyZW50Lm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgcG9ydGFsTm9kZS5jdXJyZW50Lm93bmVyRG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChwb3J0YWxOb2RlLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFt0eXBlLCBmb3JjZVVwZGF0ZV0pO1xuXG4gIHJldHVybiBwb3J0YWxOb2RlLmN1cnJlbnQgPyAoXG4gICAgY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBwb3J0YWxOb2RlLmN1cnJlbnQpXG4gICkgOiAoXG4gICAgPHNwYW4gcmVmPXttb3VudE5vZGV9IC8+XG4gICk7XG59O1xuXG4vKipcbiAqIEBzZWUgRG9jcyBodHRwczovL3JlYWNoLnRlY2gvcG9ydGFsI3BvcnRhbC1wcm9wc1xuICovXG50eXBlIFBvcnRhbFByb3BzID0ge1xuICAvKipcbiAgICogUmVndWxhciBSZWFjdCBjaGlsZHJlbi5cbiAgICpcbiAgICogQHNlZSBEb2NzIGh0dHBzOi8vcmVhY2gudGVjaC9wb3J0YWwjcG9ydGFsLWNoaWxkcmVuXG4gICAqL1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuICAvKipcbiAgICogVGhlIERPTSBlbGVtZW50IHR5cGUgdG8gcmVuZGVyLlxuICAgKlxuICAgKiBAc2VlIERvY3MgaHR0cHM6Ly9yZWFjaC50ZWNoL3BvcnRhbCNwb3J0YWwtdHlwZVxuICAgKi9cbiAgdHlwZT86IHN0cmluZztcbn07XG5cbmlmIChfX0RFVl9fKSB7XG4gIFBvcnRhbC5kaXNwbGF5TmFtZSA9IFwiUG9ydGFsXCI7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFeHBvcnRzXG5cbmV4cG9ydCBkZWZhdWx0IFBvcnRhbDtcbmV4cG9ydCB0eXBlIHsgUG9ydGFsUHJvcHMgfTtcbmV4cG9ydCB7IFBvcnRhbCB9O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7QUFpQkE7Ozs7OztBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQVRBO0FBZ0JBO0FBR0E7QUFBQTs7O0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@reach/portal/dist/portal.esm.js\n");

/***/ }),

/***/ "../node_modules/@reach/utils/dist/utils.esm.js":
/*!******************************************************!*\
  !*** ../node_modules/@reach/utils/dist/utils.esm.js ***!
  \******************************************************/
/*! exports provided: assignRef, boolOrBoolString, canUseDOM, checkStyles, cloneValidElement, createNamedContext, forwardRefWithAs, getDocumentDimensions, getElementComputedStyle, getOwnerDocument, getOwnerWindow, getScrollPosition, getScrollbarOffset, isBoolean, isFunction, isNumber, isRightClick, isString, makeId, memoWithAs, noop, ponyfillGlobal, stateToAttributeString, useCallbackProp, useCheckStyles, useConstant, useControlledState, useControlledSwitchWarning, useEventCallback, useEventListener, useFocusChange, useForceUpdate, useForkedRef, useIsomorphicLayoutEffect, useLazyRef, usePrevious, useStableCallback, useStateLogger, useUpdateEffect, warning, wrapEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assignRef\", function() { return assignRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"boolOrBoolString\", function() { return boolOrBoolString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canUseDOM\", function() { return canUseDOM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkStyles\", function() { return checkStyles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cloneValidElement\", function() { return cloneValidElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createNamedContext\", function() { return createNamedContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forwardRefWithAs\", function() { return forwardRefWithAs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDocumentDimensions\", function() { return getDocumentDimensions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getElementComputedStyle\", function() { return getElementComputedStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOwnerDocument\", function() { return getOwnerDocument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOwnerWindow\", function() { return getOwnerWindow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getScrollPosition\", function() { return getScrollPosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getScrollbarOffset\", function() { return getScrollbarOffset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBoolean\", function() { return isBoolean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isFunction\", function() { return isFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumber\", function() { return isNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isRightClick\", function() { return isRightClick; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isString\", function() { return isString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeId\", function() { return makeId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"memoWithAs\", function() { return memoWithAs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"noop\", function() { return noop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ponyfillGlobal\", function() { return ponyfillGlobal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stateToAttributeString\", function() { return stateToAttributeString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useCallbackProp\", function() { return useCallbackProp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useCheckStyles\", function() { return useCheckStyles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useConstant\", function() { return useConstant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useControlledState\", function() { return useControlledState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useControlledSwitchWarning\", function() { return useControlledSwitchWarning; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useEventCallback\", function() { return useEventCallback; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useEventListener\", function() { return useEventListener; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useFocusChange\", function() { return useFocusChange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useForceUpdate\", function() { return useForceUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useForkedRef\", function() { return useForkedRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useIsomorphicLayoutEffect\", function() { return useIsomorphicLayoutEffect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useLazyRef\", function() { return useLazyRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"usePrevious\", function() { return usePrevious; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useStableCallback\", function() { return useStableCallback; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useStateLogger\", function() { return useStateLogger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useUpdateEffect\", function() { return useUpdateEffect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"warning\", function() { return warning; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wrapEvent\", function() { return wrapEvent; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! warning */ \"../node_modules/warning/warning.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n/* eslint-disable no-restricted-globals, eqeqeq  */\n\n/**\r\n * React currently throws a warning when using useLayoutEffect on the server.\r\n * To get around it, we can conditionally useEffect on the server (no-op) and\r\n * useLayoutEffect in the browser. We occasionally need useLayoutEffect to\r\n * ensure we don't get a render flash for certain operations, but we may also\r\n * need affected components to render on the server. One example is when setting\r\n * a component's descendants to retrieve their index values.\r\n *\r\n * Important to note that using this hook as an escape hatch will break the\r\n * eslint dependency warnings unless you rename the import to `useLayoutEffect`.\r\n * Use sparingly only when the effect won't effect the rendered HTML to avoid\r\n * any server/client mismatch.\r\n *\r\n * If a useLayoutEffect is needed and the result would create a mismatch, it's\r\n * likely that the component in question shouldn't be rendered on the server at\r\n * all, so a better approach would be to lazily render those in a parent\r\n * component after client-side hydration.\r\n *\r\n * TODO: We are calling useLayoutEffect in a couple of places that will likely\r\n * cause some issues for SSR users, whether the warning shows or not. Audit and\r\n * fix these.\r\n *\r\n * https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\r\n * https://github.com/reduxjs/react-redux/blob/master/src/utils/useIsomorphicLayoutEffect.js\r\n *\r\n * @param effect\r\n * @param deps\r\n */\n\nvar useIsomorphicLayoutEffect = /*#__PURE__*/canUseDOM() ? react__WEBPACK_IMPORTED_MODULE_0__[\"useLayoutEffect\"] : react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"];\nvar checkedPkgs = {};\n/**\r\n * Copy of Facebook's warning package.\r\n *\r\n * Similar to invariant but only logs a warning if the condition is not met.\r\n * This can be used to log issues in development environments in critical paths.\r\n * Removing the logging code for production environments will keep the same\r\n * logic and follow the same code paths.\r\n *\r\n * @see https://github.com/BerkeleyTrue/warning/blob/master/warning.js\r\n */\n\nvar warning = warning__WEBPACK_IMPORTED_MODULE_1___default.a;\n/**\r\n * When in dev mode, checks that styles for a given @reach package are loaded.\r\n *\r\n * @param packageName Name of the package to check.\r\n * @example checkStyles(\"dialog\") will check for styles for @reach/dialog\r\n */\n\nvar checkStyles = noop;\n\nif (true) {\n  // In CJS files, process.env.NODE_ENV is stripped from our build, but we need\n  // it to prevent style checks from clogging up user logs while testing.\n  // This is a workaround until we can tweak the build a bit to accommodate.\n  var _ref = typeof process !== \"undefined\" ? process : {\n    env: {\n      NODE_ENV: \"development\"\n    }\n  },\n      env = _ref.env;\n\n  checkStyles = function checkStyles(packageName) {\n    // only check once per package\n    if (checkedPkgs[packageName]) return;\n    checkedPkgs[packageName] = true;\n\n    if (env.NODE_ENV !== \"test\" && parseInt(window.getComputedStyle(document.body).getPropertyValue(\"--reach-\" + packageName), 10) !== 1) {\n      console.warn(\"@reach/\" + packageName + \" styles not found. If you are using a bundler like webpack or parcel include this in the entry file of your app before any of your own styles:\\n\\n    import \\\"@reach/\" + packageName + \"/styles.css\\\";\\n\\n  Otherwise you'll need to include them some other way:\\n\\n    <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"node_modules/@reach/\" + packageName + \"/styles.css\\\" />\\n\\n  For more information visit https://ui.reach.tech/styling.\\n  \");\n    }\n  };\n}\n/**\r\n * Ponyfill for the global object in some environments.\r\n *\r\n * @link https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\r\n */\n\n\nvar ponyfillGlobal = typeof window != \"undefined\" && window.Math == Math ? window : typeof self != \"undefined\" && self.Math == Math ? self :\n/*#__PURE__*/\n// eslint-disable-next-line no-new-func\nFunction(\"return this\")();\n/**\r\n * Passes or assigns an arbitrary value to a ref function or object.\r\n *\r\n * @param ref\r\n * @param value\r\n */\n\nfunction assignRef(ref, value) {\n  if (ref == null) return;\n\n  if (isFunction(ref)) {\n    ref(value);\n  } else {\n    try {\n      ref.current = value;\n    } catch (error) {\n      throw new Error(\"Cannot assign value \\\"\" + value + \"\\\" to ref \\\"\" + ref + \"\\\"\");\n    }\n  }\n}\n/**\r\n * Checks true|\"true\" vs false|\"false\"\r\n *\r\n * @param value\r\n */\n\n\nfunction boolOrBoolString(value) {\n  return value === \"true\" ? true : isBoolean(value) ? value : false;\n}\n\nfunction canUseDOM() {\n  return !!(typeof window !== \"undefined\" && window.document && window.document.createElement);\n}\n/**\r\n * Type-safe clone element\r\n *\r\n * @param element\r\n * @param props\r\n * @param children\r\n */\n\n\nfunction cloneValidElement(element, props) {\n  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    children[_key - 2] = arguments[_key];\n  }\n\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"isValidElement\"])(element) ? react__WEBPACK_IMPORTED_MODULE_0__[\"cloneElement\"].apply(react__WEBPACK_IMPORTED_MODULE_0__, [element, props].concat(children)) : element;\n}\n\nfunction createNamedContext(name, defaultValue) {\n  var Ctx = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createContext\"])(defaultValue);\n  Ctx.displayName = name;\n  return Ctx;\n}\n/**\r\n * This is a hack for sure. The thing is, getting a component to intelligently\r\n * infer props based on a component or JSX string passed into an `as` prop is\r\n * kind of a huge pain. Getting it to work and satisfy the constraints of\r\n * `forwardRef` seems dang near impossible. To avoid needing to do this awkward\r\n * type song-and-dance every time we want to forward a ref into a component\r\n * that accepts an `as` prop, we abstract all of that mess to this function for\r\n * the time time being.\r\n */\n\n\nfunction forwardRefWithAs(render) {\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"forwardRef\"])(render);\n}\n\nfunction memoWithAs(Component, propsAreEqual) {\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"memo\"])(Component, propsAreEqual);\n}\n/**\r\n * Get the size of the working document minus the scrollbar offset.\r\n *\r\n * @param element\r\n */\n\n\nfunction getDocumentDimensions(element) {\n  var _ownerDocument$docume, _ownerDocument$docume2;\n\n  var ownerDocument = getOwnerDocument(element);\n  var ownerWindow = ownerDocument.defaultView || window;\n\n  if (!ownerDocument) {\n    return {\n      width: 0,\n      height: 0\n    };\n  }\n\n  return {\n    width: (_ownerDocument$docume = ownerDocument.documentElement.clientWidth) !== null && _ownerDocument$docume !== void 0 ? _ownerDocument$docume : ownerWindow.innerWidth,\n    height: (_ownerDocument$docume2 = ownerDocument.documentElement.clientHeight) !== null && _ownerDocument$docume2 !== void 0 ? _ownerDocument$docume2 : ownerWindow.innerHeight\n  };\n}\n/**\r\n * Get the scoll position of the global window object relative to a given node.\r\n *\r\n * @param element\r\n */\n\n\nfunction getScrollPosition(element) {\n  var ownerDocument = getOwnerDocument(element);\n  var ownerWindow = ownerDocument.defaultView || window;\n\n  if (!ownerDocument) {\n    return {\n      scrollX: 0,\n      scrollY: 0\n    };\n  }\n\n  return {\n    scrollX: ownerWindow.scrollX,\n    scrollY: ownerWindow.scrollY\n  };\n}\n/**\r\n * Get a computed style value by property.\r\n *\r\n * @param element\r\n * @param styleProp\r\n */\n\n\nfunction getElementComputedStyle(element, styleProp) {\n  var ownerDocument = getOwnerDocument(element);\n  var ownerWindow = (ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.defaultView) || window;\n\n  if (ownerWindow) {\n    return ownerWindow.getComputedStyle(element, null).getPropertyValue(styleProp);\n  }\n\n  return null;\n}\n/**\r\n * Get an element's owner document. Useful when components are used in iframes\r\n * or other environments like dev tools.\r\n *\r\n * @param element\r\n */\n\n\nfunction getOwnerDocument(element) {\n  return canUseDOM() ? element ? element.ownerDocument : document : null;\n}\n/**\r\n * TODO: Remove in 1.0\r\n */\n\n\nfunction getOwnerWindow(element) {\n  var ownerDocument = getOwnerDocument(element);\n  return ownerDocument ? ownerDocument.defaultView || window : null;\n}\n/**\r\n * Get the scrollbar offset distance.\r\n *\r\n * TODO: Remove in 1.0 (we used this in public examples)\r\n */\n\n\nfunction getScrollbarOffset() {\n  try {\n    if (window.innerWidth > document.documentElement.clientWidth) {\n      return window.innerWidth - document.documentElement.clientWidth;\n    }\n  } catch (err) {}\n\n  return 0;\n}\n/**\r\n * Checks whether or not a value is a boolean.\r\n *\r\n * @param value\r\n */\n\n\nfunction isBoolean(value) {\n  return typeof value === \"boolean\";\n}\n/**\r\n * Checks whether or not a value is a function.\r\n *\r\n * @param value\r\n */\n\n\nfunction isFunction(value) {\n  return !!(value && {}.toString.call(value) == \"[object Function]\");\n}\n/**\r\n * Checks whether or not a value is a number.\r\n *\r\n * @param value\r\n */\n\n\nfunction isNumber(value) {\n  return typeof value === \"number\" && !isNaN(value);\n}\n/**\r\n * Detects right clicks\r\n *\r\n * @param nativeEvent\r\n */\n\n\nfunction isRightClick(nativeEvent) {\n  return \"which\" in nativeEvent ? nativeEvent.which === 3 : \"button\" in nativeEvent ? nativeEvent.button === 2 : false;\n}\n/**\r\n * Checks whether or not a value is a string.\r\n *\r\n * @param value\r\n */\n\n\nfunction isString(value) {\n  return typeof value === \"string\";\n}\n/**\r\n * Joins strings to format IDs for compound components.\r\n *\r\n * @param args\r\n */\n\n\nfunction makeId() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return args.filter(function (val) {\n    return val != null;\n  }).join(\"--\");\n}\n/**\r\n * No-op function.\r\n */\n\n\nfunction noop() {}\n/**\r\n * Convert our state strings for HTML data attributes.\r\n * No need for a fancy kebab-caser here, we know what our state strings are!\r\n *\r\n * @param state\r\n */\n\n\nfunction stateToAttributeString(state) {\n  return String(state).replace(/([\\s_]+)/g, \"-\").toLowerCase();\n}\n/**\r\n * Check if a component is controlled or uncontrolled and return the correct\r\n * state value and setter accordingly. If the component state is controlled by\r\n * the app, the setter is a noop.\r\n *\r\n * @param controlledValue\r\n * @param defaultValue\r\n */\n\n\nfunction useControlledState(controlledValue, defaultValue) {\n  var controlledRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(controlledValue != null);\n\n  var _React$useState = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(defaultValue),\n      valueState = _React$useState[0],\n      setValue = _React$useState[1];\n\n  var set = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(function (n) {\n    if (!controlledRef.current) {\n      setValue(n);\n    }\n  }, []);\n  return [controlledRef.current ? controlledValue : valueState, set];\n}\n/**\r\n * Logs a warning in dev mode when a component switches from controlled to\r\n * uncontrolled, or vice versa\r\n *\r\n * A single prop should typically be used to determine whether or not a\r\n * component is controlled or not.\r\n *\r\n * @param controlledValue\r\n * @param controlledPropName\r\n * @param componentName\r\n */\n\n\nvar useControlledSwitchWarning = noop;\n\nif (true) {\n  useControlledSwitchWarning = function useControlledSwitchWarning(controlledValue, controlledPropName, componentName) {\n    var controlledRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(controlledValue != null);\n    var nameCache = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({\n      componentName: componentName,\n      controlledPropName: controlledPropName\n    });\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n      nameCache.current = {\n        componentName: componentName,\n        controlledPropName: controlledPropName\n      };\n    }, [componentName, controlledPropName]);\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n      var wasControlled = controlledRef.current;\n      var _nameCache$current = nameCache.current,\n          componentName = _nameCache$current.componentName,\n          controlledPropName = _nameCache$current.controlledPropName;\n      var isControlled = controlledValue != null;\n\n      if (wasControlled !== isControlled) {\n        console.error(\"A component is changing an \" + (wasControlled ? \"\" : \"un\") + \"controlled `\" + controlledPropName + \"` state of \" + componentName + \" to be \" + (wasControlled ? \"un\" : \"\") + \"controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled \" + componentName + \" element for the lifetime of the component.\\nMore info: https://fb.me/react-controlled-components\");\n      }\n    }, [controlledValue]);\n  };\n}\n\nvar useCheckStyles = noop;\n\nif (true) {\n  useCheckStyles = function useCheckStyles(pkg) {\n    var name = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(pkg);\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n      return void (name.current = pkg);\n    }, [pkg]);\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n      return checkStyles(name.current);\n    }, []);\n  };\n}\n/**\r\n * React hook for creating a value exactly once.\r\n * @see https://github.com/Andarist/use-constant\r\n */\n\n\nfunction useConstant(fn) {\n  var ref = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])();\n\n  if (!ref.current) {\n    ref.current = {\n      v: fn()\n    };\n  }\n\n  return ref.current.v;\n}\n/**\r\n * @param callback\r\n */\n\n\nfunction useEventCallback(callback) {\n  var ref = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(callback);\n  useIsomorphicLayoutEffect(function () {\n    ref.current = callback;\n  });\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(function (event) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    return ref.current.apply(ref, [event].concat(args));\n  }, []);\n}\n\nfunction useLazyRef(fn) {\n  var ref = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({\n    __internalSet: true\n  });\n\n  if (ref.current && ref.current.__internalSet === true) {\n    ref.current = fn();\n  }\n\n  return ref;\n}\n/**\r\n * TODO: Remove in 1.0\r\n * @alias useStableCallback\r\n * @param callback\r\n */\n\n\nvar useCallbackProp = useStableCallback;\n/**\r\n * Adds a DOM event listener\r\n *\r\n * @param eventName\r\n * @param listener\r\n * @param element\r\n */\n\nfunction useEventListener(eventName, listener, element) {\n  if (element === void 0) {\n    element = window;\n  }\n\n  var savedHandler = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(listener);\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n    savedHandler.current = listener;\n  }, [listener]);\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n    var isSupported = element && element.addEventListener;\n\n    if (!isSupported) {\n      if (true) {\n        console.warn(\"Event listener not supported on the element provided\");\n      }\n\n      return;\n    }\n\n    function eventListener(event) {\n      savedHandler.current(event);\n    }\n\n    element.addEventListener(eventName, eventListener);\n    return function () {\n      element.removeEventListener(eventName, eventListener);\n    };\n  }, [eventName, element]);\n}\n/**\r\n * Detect when focus changes in our document.\r\n *\r\n * @param handleChange\r\n * @param when\r\n * @param ownerDocument\r\n */\n\n\nfunction useFocusChange(handleChange, when, ownerDocument) {\n  if (handleChange === void 0) {\n    handleChange = console.log;\n  }\n\n  if (when === void 0) {\n    when = \"focus\";\n  }\n\n  if (ownerDocument === void 0) {\n    ownerDocument = document;\n  }\n\n  var lastActiveElement = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(ownerDocument.activeElement);\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n    lastActiveElement.current = ownerDocument.activeElement;\n\n    function onChange(event) {\n      if (lastActiveElement.current !== ownerDocument.activeElement) {\n        handleChange(ownerDocument.activeElement, lastActiveElement.current, event);\n        lastActiveElement.current = ownerDocument.activeElement;\n      }\n    }\n\n    ownerDocument.addEventListener(when, onChange, true);\n    return function () {\n      ownerDocument.removeEventListener(when, onChange);\n    };\n  }, [when, handleChange, ownerDocument]);\n}\n/**\r\n * Forces a re-render, similar to `forceUpdate` in class components.\r\n */\n\n\nfunction useForceUpdate() {\n  var _React$useState2 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(Object.create(null)),\n      dispatch = _React$useState2[1];\n\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(function () {\n    dispatch(Object.create(null));\n  }, []);\n}\n/**\r\n * Passes or assigns a value to multiple refs (typically a DOM node). Useful for\r\n * dealing with components that need an explicit ref for DOM calculations but\r\n * also forwards refs assigned by an app.\r\n *\r\n * @param refs Refs to fork\r\n */\n\n\nfunction useForkedRef() {\n  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    refs[_key4] = arguments[_key4];\n  }\n\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useMemo\"])(function () {\n    if (refs.every(function (ref) {\n      return ref == null;\n    })) {\n      return null;\n    }\n\n    return function (node) {\n      refs.forEach(function (ref) {\n        assignRef(ref, node);\n      });\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [].concat(refs));\n}\n/**\r\n * Returns the previous value of a reference after a component update.\r\n *\r\n * @param value\r\n */\n\n\nfunction usePrevious(value) {\n  var ref = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(null);\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n/**\r\n * Converts a callback to a ref to avoid triggering re-renders when passed as a\r\n * prop and exposed as a stable function to avoid executing effects when\r\n * passed as a dependency.\r\n */\n\n\nfunction useStableCallback(callback) {\n  var callbackRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(callback);\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n    callbackRef.current = callback;\n  }); // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  return Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(function () {\n    callbackRef.current && callbackRef.current.apply(callbackRef, arguments);\n  }, []);\n}\n/**\r\n * Call an effect after a component update, skipping the initial mount.\r\n *\r\n * @param effect Effect to call\r\n * @param deps Effect dependency list\r\n */\n\n\nfunction useUpdateEffect(effect, deps) {\n  var mounted = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n    if (mounted.current) {\n      effect();\n    } else {\n      mounted.current = true;\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, deps);\n}\n/**\r\n * Just a lil state logger\r\n *\r\n * @param state\r\n * @param DEBUG\r\n */\n\n\nvar useStateLogger = noop;\n\nif (true) {\n  useStateLogger = function useStateLogger(state, DEBUG) {\n    if (DEBUG === void 0) {\n      DEBUG = false;\n    }\n\n    var debugRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(DEBUG);\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n      debugRef.current = DEBUG;\n    }, [DEBUG]);\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n      if (debugRef.current) {\n        console.group(\"State Updated\");\n        console.log(\"%c\" + state, \"font-weight: normal; font-size: 120%; font-style: italic;\");\n        console.groupEnd();\n      }\n    }, [state]);\n  };\n}\n/**\r\n * Wraps a lib-defined event handler and a user-defined event handler, returning\r\n * a single handler that allows a user to prevent lib-defined handlers from\r\n * firing.\r\n *\r\n * @param theirHandler User-supplied event handler\r\n * @param ourHandler Library-supplied event handler\r\n */\n\n\nfunction wrapEvent(theirHandler, ourHandler) {\n  return function (event) {\n    theirHandler && theirHandler(event);\n\n    if (!event.defaultPrevented) {\n      return ourHandler(event);\n    }\n  };\n}\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../web/node_modules/process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0ByZWFjaC91dGlscy9kaXN0L3V0aWxzLmVzbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zcmMvaW5kZXgudHN4P2RlYjciXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzLCBlcWVxZXEgICovXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IGZiV2FybmluZyBmcm9tIFwid2FybmluZ1wiO1xuaW1wb3J0IHR5cGUge1xuICBBcyxcbiAgQXNzaWduYWJsZVJlZixcbiAgQ29tcG9uZW50V2l0aEFzLFxuICBDb21wb25lbnRXaXRoRm9yd2FyZGVkUmVmLFxuICBEaXN0cmlidXRpdmVPbWl0LFxuICBFbGVtZW50VGFnTmFtZU1hcCxcbiAgRm9yd2FyZFJlZkV4b3RpY0NvbXBvbmVudFdpdGhBcyxcbiAgRm9yd2FyZFJlZldpdGhBc1JlbmRlckZ1bmN0aW9uLFxuICBGdW5jdGlvbkNvbXBvbmVudFdpdGhBcyxcbiAgTWVtb0V4b3RpY0NvbXBvbmVudFdpdGhBcyxcbiAgUHJvcHNGcm9tQXMsXG4gIFByb3BzV2l0aEFzLFxuICBTaW5nbGVPckFycmF5LFxuICBUaGVuQXJnLFxufSBmcm9tIFwiLi90eXBlc1wiO1xuXG4vKipcbiAqIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXG4gKiBUbyBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxuICogdXNlTGF5b3V0RWZmZWN0IGluIHRoZSBicm93c2VyLiBXZSBvY2Nhc2lvbmFsbHkgbmVlZCB1c2VMYXlvdXRFZmZlY3QgdG9cbiAqIGVuc3VyZSB3ZSBkb24ndCBnZXQgYSByZW5kZXIgZmxhc2ggZm9yIGNlcnRhaW4gb3BlcmF0aW9ucywgYnV0IHdlIG1heSBhbHNvXG4gKiBuZWVkIGFmZmVjdGVkIGNvbXBvbmVudHMgdG8gcmVuZGVyIG9uIHRoZSBzZXJ2ZXIuIE9uZSBleGFtcGxlIGlzIHdoZW4gc2V0dGluZ1xuICogYSBjb21wb25lbnQncyBkZXNjZW5kYW50cyB0byByZXRyaWV2ZSB0aGVpciBpbmRleCB2YWx1ZXMuXG4gKlxuICogSW1wb3J0YW50IHRvIG5vdGUgdGhhdCB1c2luZyB0aGlzIGhvb2sgYXMgYW4gZXNjYXBlIGhhdGNoIHdpbGwgYnJlYWsgdGhlXG4gKiBlc2xpbnQgZGVwZW5kZW5jeSB3YXJuaW5ncyB1bmxlc3MgeW91IHJlbmFtZSB0aGUgaW1wb3J0IHRvIGB1c2VMYXlvdXRFZmZlY3RgLlxuICogVXNlIHNwYXJpbmdseSBvbmx5IHdoZW4gdGhlIGVmZmVjdCB3b24ndCBlZmZlY3QgdGhlIHJlbmRlcmVkIEhUTUwgdG8gYXZvaWRcbiAqIGFueSBzZXJ2ZXIvY2xpZW50IG1pc21hdGNoLlxuICpcbiAqIElmIGEgdXNlTGF5b3V0RWZmZWN0IGlzIG5lZWRlZCBhbmQgdGhlIHJlc3VsdCB3b3VsZCBjcmVhdGUgYSBtaXNtYXRjaCwgaXQnc1xuICogbGlrZWx5IHRoYXQgdGhlIGNvbXBvbmVudCBpbiBxdWVzdGlvbiBzaG91bGRuJ3QgYmUgcmVuZGVyZWQgb24gdGhlIHNlcnZlciBhdFxuICogYWxsLCBzbyBhIGJldHRlciBhcHByb2FjaCB3b3VsZCBiZSB0byBsYXppbHkgcmVuZGVyIHRob3NlIGluIGEgcGFyZW50XG4gKiBjb21wb25lbnQgYWZ0ZXIgY2xpZW50LXNpZGUgaHlkcmF0aW9uLlxuICpcbiAqIFRPRE86IFdlIGFyZSBjYWxsaW5nIHVzZUxheW91dEVmZmVjdCBpbiBhIGNvdXBsZSBvZiBwbGFjZXMgdGhhdCB3aWxsIGxpa2VseVxuICogY2F1c2Ugc29tZSBpc3N1ZXMgZm9yIFNTUiB1c2Vycywgd2hldGhlciB0aGUgd2FybmluZyBzaG93cyBvciBub3QuIEF1ZGl0IGFuZFxuICogZml4IHRoZXNlLlxuICpcbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2dhZWFyb24vZTdkOTdjZGYzOGEyOTA3OTI0ZWExMmU0ZWJkZjNjODVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWR1eGpzL3JlYWN0LXJlZHV4L2Jsb2IvbWFzdGVyL3NyYy91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LmpzXG4gKlxuICogQHBhcmFtIGVmZmVjdFxuICogQHBhcmFtIGRlcHNcbiAqL1xuZXhwb3J0IGNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBjYW5Vc2VET00oKVxuICA/IFJlYWN0LnVzZUxheW91dEVmZmVjdFxuICA6IFJlYWN0LnVzZUVmZmVjdDtcblxubGV0IGNoZWNrZWRQa2dzOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSA9IHt9O1xuXG4vKipcbiAqIENvcHkgb2YgRmFjZWJvb2sncyB3YXJuaW5nIHBhY2thZ2UuXG4gKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbCBwYXRocy5cbiAqIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGUgc2FtZVxuICogbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0JlcmtlbGV5VHJ1ZS93YXJuaW5nL2Jsb2IvbWFzdGVyL3dhcm5pbmcuanNcbiAqL1xuZXhwb3J0IGNvbnN0IHdhcm5pbmcgPSBmYldhcm5pbmc7XG5cbi8qKlxuICogV2hlbiBpbiBkZXYgbW9kZSwgY2hlY2tzIHRoYXQgc3R5bGVzIGZvciBhIGdpdmVuIEByZWFjaCBwYWNrYWdlIGFyZSBsb2FkZWQuXG4gKlxuICogQHBhcmFtIHBhY2thZ2VOYW1lIE5hbWUgb2YgdGhlIHBhY2thZ2UgdG8gY2hlY2suXG4gKiBAZXhhbXBsZSBjaGVja1N0eWxlcyhcImRpYWxvZ1wiKSB3aWxsIGNoZWNrIGZvciBzdHlsZXMgZm9yIEByZWFjaC9kaWFsb2dcbiAqL1xubGV0IGNoZWNrU3R5bGVzOiAocGFja2FnZU5hbWU6IHN0cmluZykgPT4gdm9pZCA9IG5vb3A7XG5cbmlmIChfX0RFVl9fKSB7XG4gIC8vIEluIENKUyBmaWxlcywgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgaXMgc3RyaXBwZWQgZnJvbSBvdXIgYnVpbGQsIGJ1dCB3ZSBuZWVkXG4gIC8vIGl0IHRvIHByZXZlbnQgc3R5bGUgY2hlY2tzIGZyb20gY2xvZ2dpbmcgdXAgdXNlciBsb2dzIHdoaWxlIHRlc3RpbmcuXG4gIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIHVudGlsIHdlIGNhbiB0d2VhayB0aGUgYnVpbGQgYSBiaXQgdG8gYWNjb21tb2RhdGUuXG4gIGxldCB7IGVudiB9ID1cbiAgICB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgPyBwcm9jZXNzXG4gICAgICA6IHsgZW52OiB7IE5PREVfRU5WOiBcImRldmVsb3BtZW50XCIgfSB9O1xuXG4gIGNoZWNrU3R5bGVzID0gZnVuY3Rpb24gY2hlY2tTdHlsZXMocGFja2FnZU5hbWU6IHN0cmluZykge1xuICAgIC8vIG9ubHkgY2hlY2sgb25jZSBwZXIgcGFja2FnZVxuICAgIGlmIChjaGVja2VkUGtnc1twYWNrYWdlTmFtZV0pIHJldHVybjtcbiAgICBjaGVja2VkUGtnc1twYWNrYWdlTmFtZV0gPSB0cnVlO1xuXG4gICAgaWYgKFxuICAgICAgZW52Lk5PREVfRU5WICE9PSBcInRlc3RcIiAmJlxuICAgICAgcGFyc2VJbnQoXG4gICAgICAgIHdpbmRvd1xuICAgICAgICAgIC5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpXG4gICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUoYC0tcmVhY2gtJHtwYWNrYWdlTmFtZX1gKSxcbiAgICAgICAgMTBcbiAgICAgICkgIT09IDFcbiAgICApIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYEByZWFjaC8ke3BhY2thZ2VOYW1lfSBzdHlsZXMgbm90IGZvdW5kLiBJZiB5b3UgYXJlIHVzaW5nIGEgYnVuZGxlciBsaWtlIHdlYnBhY2sgb3IgcGFyY2VsIGluY2x1ZGUgdGhpcyBpbiB0aGUgZW50cnkgZmlsZSBvZiB5b3VyIGFwcCBiZWZvcmUgYW55IG9mIHlvdXIgb3duIHN0eWxlczpcblxuICAgIGltcG9ydCBcIkByZWFjaC8ke3BhY2thZ2VOYW1lfS9zdHlsZXMuY3NzXCI7XG5cbiAgT3RoZXJ3aXNlIHlvdSdsbCBuZWVkIHRvIGluY2x1ZGUgdGhlbSBzb21lIG90aGVyIHdheTpcblxuICAgIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiB0eXBlPVwidGV4dC9jc3NcIiBocmVmPVwibm9kZV9tb2R1bGVzL0ByZWFjaC8ke3BhY2thZ2VOYW1lfS9zdHlsZXMuY3NzXCIgLz5cblxuICBGb3IgbW9yZSBpbmZvcm1hdGlvbiB2aXNpdCBodHRwczovL3VpLnJlYWNoLnRlY2gvc3R5bGluZy5cbiAgYFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7IGNoZWNrU3R5bGVzIH07XG5cbi8qKlxuICogUG9ueWZpbGwgZm9yIHRoZSBnbG9iYWwgb2JqZWN0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG4gKi9cbmV4cG9ydCBjb25zdCBwb255ZmlsbEdsb2JhbCA9XG4gIHR5cGVvZiB3aW5kb3cgIT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gICAgPyB3aW5kb3dcbiAgICA6IHR5cGVvZiBzZWxmICE9IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5NYXRoID09IE1hdGhcbiAgICA/IHNlbGZcbiAgICA6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vKipcbiAqIFBhc3NlcyBvciBhc3NpZ25zIGFuIGFyYml0cmFyeSB2YWx1ZSB0byBhIHJlZiBmdW5jdGlvbiBvciBvYmplY3QuXG4gKlxuICogQHBhcmFtIHJlZlxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25SZWY8UmVmVmFsdWVUeXBlID0gYW55PihcbiAgcmVmOiBBc3NpZ25hYmxlUmVmPFJlZlZhbHVlVHlwZT4gfCBudWxsIHwgdW5kZWZpbmVkLFxuICB2YWx1ZTogYW55XG4pIHtcbiAgaWYgKHJlZiA9PSBudWxsKSByZXR1cm47XG4gIGlmIChpc0Z1bmN0aW9uKHJlZikpIHtcbiAgICByZWYodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhc3NpZ24gdmFsdWUgXCIke3ZhbHVlfVwiIHRvIHJlZiBcIiR7cmVmfVwiYCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIHRydWV8XCJ0cnVlXCIgdnMgZmFsc2V8XCJmYWxzZVwiXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib29sT3JCb29sU3RyaW5nKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBcInRydWVcIiB8IHRydWUge1xuICByZXR1cm4gdmFsdWUgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6IGlzQm9vbGVhbih2YWx1ZSkgPyB2YWx1ZSA6IGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FuVXNlRE9NKCkge1xuICByZXR1cm4gISEoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHdpbmRvdy5kb2N1bWVudCAmJlxuICAgIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50XG4gICk7XG59XG5cbi8qKlxuICogVHlwZS1zYWZlIGNsb25lIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0gZWxlbWVudFxuICogQHBhcmFtIHByb3BzXG4gKiBAcGFyYW0gY2hpbGRyZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lVmFsaWRFbGVtZW50PFByb3BzPihcbiAgZWxlbWVudDogUmVhY3QuUmVhY3RFbGVtZW50PFByb3BzPiB8IFJlYWN0LlJlYWN0Tm9kZSxcbiAgcHJvcHM/OiBQYXJ0aWFsPFByb3BzPiAmIFJlYWN0LkF0dHJpYnV0ZXMsXG4gIC4uLmNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVbXVxuKTogUmVhY3QuUmVhY3RFbGVtZW50PFByb3BzPiB8IFJlYWN0LlJlYWN0Tm9kZSB7XG4gIHJldHVybiBSZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KVxuICAgID8gUmVhY3QuY2xvbmVFbGVtZW50KGVsZW1lbnQsIHByb3BzLCAuLi5jaGlsZHJlbilcbiAgICA6IGVsZW1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOYW1lZENvbnRleHQ8Q29udGV4dFZhbHVlVHlwZT4oXG4gIG5hbWU6IHN0cmluZyxcbiAgZGVmYXVsdFZhbHVlOiBDb250ZXh0VmFsdWVUeXBlXG4pOiBSZWFjdC5Db250ZXh0PENvbnRleHRWYWx1ZVR5cGU+IHtcbiAgY29uc3QgQ3R4ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxDb250ZXh0VmFsdWVUeXBlPihkZWZhdWx0VmFsdWUpO1xuICBDdHguZGlzcGxheU5hbWUgPSBuYW1lO1xuICByZXR1cm4gQ3R4O1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYSBoYWNrIGZvciBzdXJlLiBUaGUgdGhpbmcgaXMsIGdldHRpbmcgYSBjb21wb25lbnQgdG8gaW50ZWxsaWdlbnRseVxuICogaW5mZXIgcHJvcHMgYmFzZWQgb24gYSBjb21wb25lbnQgb3IgSlNYIHN0cmluZyBwYXNzZWQgaW50byBhbiBgYXNgIHByb3AgaXNcbiAqIGtpbmQgb2YgYSBodWdlIHBhaW4uIEdldHRpbmcgaXQgdG8gd29yayBhbmQgc2F0aXNmeSB0aGUgY29uc3RyYWludHMgb2ZcbiAqIGBmb3J3YXJkUmVmYCBzZWVtcyBkYW5nIG5lYXIgaW1wb3NzaWJsZS4gVG8gYXZvaWQgbmVlZGluZyB0byBkbyB0aGlzIGF3a3dhcmRcbiAqIHR5cGUgc29uZy1hbmQtZGFuY2UgZXZlcnkgdGltZSB3ZSB3YW50IHRvIGZvcndhcmQgYSByZWYgaW50byBhIGNvbXBvbmVudFxuICogdGhhdCBhY2NlcHRzIGFuIGBhc2AgcHJvcCwgd2UgYWJzdHJhY3QgYWxsIG9mIHRoYXQgbWVzcyB0byB0aGlzIGZ1bmN0aW9uIGZvclxuICogdGhlIHRpbWUgdGltZSBiZWluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRSZWZXaXRoQXM8XG4gIFByb3BzLFxuICBEZWZhdWx0Q29tcG9uZW50VHlwZSBleHRlbmRzIEFzID0gXCJkaXZcIlxuPihyZW5kZXI6IEZvcndhcmRSZWZXaXRoQXNSZW5kZXJGdW5jdGlvbjxEZWZhdWx0Q29tcG9uZW50VHlwZSwgUHJvcHM+KSB7XG4gIHJldHVybiBSZWFjdC5mb3J3YXJkUmVmKHJlbmRlcikgYXMgRm9yd2FyZFJlZkV4b3RpY0NvbXBvbmVudFdpdGhBczxcbiAgICBEZWZhdWx0Q29tcG9uZW50VHlwZSxcbiAgICBQcm9wc1xuICA+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVtb1dpdGhBczxQcm9wcywgRGVmYXVsdENvbXBvbmVudFR5cGUgZXh0ZW5kcyBBcyA9IFwiZGl2XCI+KFxuICBDb21wb25lbnQ6IEZ1bmN0aW9uQ29tcG9uZW50V2l0aEFzPERlZmF1bHRDb21wb25lbnRUeXBlLCBQcm9wcz4sXG4gIHByb3BzQXJlRXF1YWw/OiAoXG4gICAgcHJldlByb3BzOiBSZWFkb25seTxSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjxQcm9wcz4+LFxuICAgIG5leHRQcm9wczogUmVhZG9ubHk8UmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48UHJvcHM+PlxuICApID0+IGJvb2xlYW5cbikge1xuICByZXR1cm4gUmVhY3QubWVtbyhDb21wb25lbnQsIHByb3BzQXJlRXF1YWwpIGFzIE1lbW9FeG90aWNDb21wb25lbnRXaXRoQXM8XG4gICAgRGVmYXVsdENvbXBvbmVudFR5cGUsXG4gICAgUHJvcHNcbiAgPjtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgdGhlIHdvcmtpbmcgZG9jdW1lbnQgbWludXMgdGhlIHNjcm9sbGJhciBvZmZzZXQuXG4gKlxuICogQHBhcmFtIGVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvY3VtZW50RGltZW5zaW9ucyhcbiAgZWxlbWVudD86IEhUTUxFbGVtZW50IHwgbnVsbCB8IHVuZGVmaW5lZFxuKSB7XG4gIGxldCBvd25lckRvY3VtZW50ID0gZ2V0T3duZXJEb2N1bWVudChlbGVtZW50KSE7XG4gIGxldCBvd25lcldpbmRvdyA9IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICBpZiAoIW93bmVyRG9jdW1lbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IG93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoID8/IG93bmVyV2luZG93LmlubmVyV2lkdGgsXG4gICAgaGVpZ2h0OlxuICAgICAgb3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ID8/IG93bmVyV2luZG93LmlubmVySGVpZ2h0LFxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgc2NvbGwgcG9zaXRpb24gb2YgdGhlIGdsb2JhbCB3aW5kb3cgb2JqZWN0IHJlbGF0aXZlIHRvIGEgZ2l2ZW4gbm9kZS5cbiAqXG4gKiBAcGFyYW0gZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb24oZWxlbWVudD86IEhUTUxFbGVtZW50IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICBsZXQgb3duZXJEb2N1bWVudCA9IGdldE93bmVyRG9jdW1lbnQoZWxlbWVudCkhO1xuICBsZXQgb3duZXJXaW5kb3cgPSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgaWYgKCFvd25lckRvY3VtZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbFg6IDAsXG4gICAgICBzY3JvbGxZOiAwLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxYOiBvd25lcldpbmRvdy5zY3JvbGxYLFxuICAgIHNjcm9sbFk6IG93bmVyV2luZG93LnNjcm9sbFksXG4gIH07XG59XG5cbi8qKlxuICogR2V0IGEgY29tcHV0ZWQgc3R5bGUgdmFsdWUgYnkgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIGVsZW1lbnRcbiAqIEBwYXJhbSBzdHlsZVByb3BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnRDb21wdXRlZFN0eWxlKGVsZW1lbnQ6IEVsZW1lbnQsIHN0eWxlUHJvcDogc3RyaW5nKSB7XG4gIGxldCBvd25lckRvY3VtZW50ID0gZ2V0T3duZXJEb2N1bWVudChlbGVtZW50KTtcbiAgbGV0IG93bmVyV2luZG93ID0gb3duZXJEb2N1bWVudD8uZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICBpZiAob3duZXJXaW5kb3cpIHtcbiAgICByZXR1cm4gb3duZXJXaW5kb3dcbiAgICAgIC5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpXG4gICAgICAuZ2V0UHJvcGVydHlWYWx1ZShzdHlsZVByb3ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEdldCBhbiBlbGVtZW50J3Mgb3duZXIgZG9jdW1lbnQuIFVzZWZ1bCB3aGVuIGNvbXBvbmVudHMgYXJlIHVzZWQgaW4gaWZyYW1lc1xuICogb3Igb3RoZXIgZW52aXJvbm1lbnRzIGxpa2UgZGV2IHRvb2xzLlxuICpcbiAqIEBwYXJhbSBlbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPd25lckRvY3VtZW50PFQgZXh0ZW5kcyBFbGVtZW50PihcbiAgZWxlbWVudDogVCB8IG51bGwgfCB1bmRlZmluZWRcbikge1xuICByZXR1cm4gY2FuVXNlRE9NKCkgPyAoZWxlbWVudCA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IGRvY3VtZW50KSA6IG51bGw7XG59XG5cbi8qKlxuICogVE9ETzogUmVtb3ZlIGluIDEuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3duZXJXaW5kb3c8VCBleHRlbmRzIEVsZW1lbnQ+KFxuICBlbGVtZW50OiBUIHwgbnVsbCB8IHVuZGVmaW5lZFxuKSB7XG4gIGxldCBvd25lckRvY3VtZW50ID0gZ2V0T3duZXJEb2N1bWVudChlbGVtZW50KTtcbiAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IG51bGw7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzY3JvbGxiYXIgb2Zmc2V0IGRpc3RhbmNlLlxuICpcbiAqIFRPRE86IFJlbW92ZSBpbiAxLjAgKHdlIHVzZWQgdGhpcyBpbiBwdWJsaWMgZXhhbXBsZXMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY3JvbGxiYXJPZmZzZXQoKSB7XG4gIHRyeSB7XG4gICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKSB7XG4gICAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHt9XG4gIHJldHVybiAwO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBhIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAqXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZTogYW55KTogdmFsdWUgaXMgYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBhIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBGdW5jdGlvbiB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB7fS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBcIltvYmplY3QgRnVuY3Rpb25dXCIpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBhIHZhbHVlIGlzIGEgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWU6IGFueSk6IHZhbHVlIGlzIG51bWJlciB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgIWlzTmFOKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHJpZ2h0IGNsaWNrc1xuICpcbiAqIEBwYXJhbSBuYXRpdmVFdmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNSaWdodENsaWNrKFxuICBuYXRpdmVFdmVudDogTW91c2VFdmVudCB8IFBvaW50ZXJFdmVudCB8IFRvdWNoRXZlbnRcbikge1xuICByZXR1cm4gXCJ3aGljaFwiIGluIG5hdGl2ZUV2ZW50XG4gICAgPyBuYXRpdmVFdmVudC53aGljaCA9PT0gM1xuICAgIDogXCJidXR0b25cIiBpbiBuYXRpdmVFdmVudFxuICAgID8gKG5hdGl2ZUV2ZW50IGFzIGFueSkuYnV0dG9uID09PSAyXG4gICAgOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufVxuXG4vKipcbiAqIEpvaW5zIHN0cmluZ3MgdG8gZm9ybWF0IElEcyBmb3IgY29tcG91bmQgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUlkKC4uLmFyZ3M6IChzdHJpbmcgfCBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkKVtdKSB7XG4gIHJldHVybiBhcmdzLmZpbHRlcigodmFsKSA9PiB2YWwgIT0gbnVsbCkuam9pbihcIi0tXCIpO1xufVxuXG4vKipcbiAqIE5vLW9wIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpOiB2b2lkIHt9XG5cbi8qKlxuICogQ29udmVydCBvdXIgc3RhdGUgc3RyaW5ncyBmb3IgSFRNTCBkYXRhIGF0dHJpYnV0ZXMuXG4gKiBObyBuZWVkIGZvciBhIGZhbmN5IGtlYmFiLWNhc2VyIGhlcmUsIHdlIGtub3cgd2hhdCBvdXIgc3RhdGUgc3RyaW5ncyBhcmUhXG4gKlxuICogQHBhcmFtIHN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZVRvQXR0cmlidXRlU3RyaW5nKHN0YXRlOiBhbnkpIHtcbiAgcmV0dXJuIFN0cmluZyhzdGF0ZSlcbiAgICAucmVwbGFjZSgvKFtcXHNfXSspL2csIFwiLVwiKVxuICAgIC50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY29tcG9uZW50IGlzIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGFuZCByZXR1cm4gdGhlIGNvcnJlY3RcbiAqIHN0YXRlIHZhbHVlIGFuZCBzZXR0ZXIgYWNjb3JkaW5nbHkuIElmIHRoZSBjb21wb25lbnQgc3RhdGUgaXMgY29udHJvbGxlZCBieVxuICogdGhlIGFwcCwgdGhlIHNldHRlciBpcyBhIG5vb3AuXG4gKlxuICogQHBhcmFtIGNvbnRyb2xsZWRWYWx1ZVxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29udHJvbGxlZFN0YXRlPFQgPSBhbnk+KFxuICBjb250cm9sbGVkVmFsdWU6IFQgfCB1bmRlZmluZWQsXG4gIGRlZmF1bHRWYWx1ZTogVFxuKTogW1QsIFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPFQ+Pl0ge1xuICBsZXQgY29udHJvbGxlZFJlZiA9IFJlYWN0LnVzZVJlZihjb250cm9sbGVkVmFsdWUgIT0gbnVsbCk7XG4gIGxldCBbdmFsdWVTdGF0ZSwgc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUoZGVmYXVsdFZhbHVlKTtcbiAgbGV0IHNldDogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248VD4+ID0gUmVhY3QudXNlQ2FsbGJhY2soKG4pID0+IHtcbiAgICBpZiAoIWNvbnRyb2xsZWRSZWYuY3VycmVudCkge1xuICAgICAgc2V0VmFsdWUobik7XG4gICAgfVxuICB9LCBbXSk7XG4gIHJldHVybiBbY29udHJvbGxlZFJlZi5jdXJyZW50ID8gKGNvbnRyb2xsZWRWYWx1ZSBhcyBUKSA6IHZhbHVlU3RhdGUsIHNldF07XG59XG5cbi8qKlxuICogTG9ncyBhIHdhcm5pbmcgaW4gZGV2IG1vZGUgd2hlbiBhIGNvbXBvbmVudCBzd2l0Y2hlcyBmcm9tIGNvbnRyb2xsZWQgdG9cbiAqIHVuY29udHJvbGxlZCwgb3IgdmljZSB2ZXJzYVxuICpcbiAqIEEgc2luZ2xlIHByb3Agc2hvdWxkIHR5cGljYWxseSBiZSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhXG4gKiBjb21wb25lbnQgaXMgY29udHJvbGxlZCBvciBub3QuXG4gKlxuICogQHBhcmFtIGNvbnRyb2xsZWRWYWx1ZVxuICogQHBhcmFtIGNvbnRyb2xsZWRQcm9wTmFtZVxuICogQHBhcmFtIGNvbXBvbmVudE5hbWVcbiAqL1xubGV0IHVzZUNvbnRyb2xsZWRTd2l0Y2hXYXJuaW5nOiAoXG4gIGNvbnRyb2xsZWRWYWx1ZTogYW55LFxuICBjb250cm9sbGVkUHJvcE5hbWU6IHN0cmluZyxcbiAgY29tcG9uZW50TmFtZTogc3RyaW5nXG4pID0+IHZvaWQgPSBub29wO1xuXG5pZiAoX19ERVZfXykge1xuICB1c2VDb250cm9sbGVkU3dpdGNoV2FybmluZyA9IGZ1bmN0aW9uIHVzZUNvbnRyb2xsZWRTd2l0Y2hXYXJuaW5nKFxuICAgIGNvbnRyb2xsZWRWYWx1ZSxcbiAgICBjb250cm9sbGVkUHJvcE5hbWUsXG4gICAgY29tcG9uZW50TmFtZVxuICApIHtcbiAgICBsZXQgY29udHJvbGxlZFJlZiA9IFJlYWN0LnVzZVJlZihjb250cm9sbGVkVmFsdWUgIT0gbnVsbCk7XG4gICAgbGV0IG5hbWVDYWNoZSA9IFJlYWN0LnVzZVJlZih7IGNvbXBvbmVudE5hbWUsIGNvbnRyb2xsZWRQcm9wTmFtZSB9KTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgbmFtZUNhY2hlLmN1cnJlbnQgPSB7IGNvbXBvbmVudE5hbWUsIGNvbnRyb2xsZWRQcm9wTmFtZSB9O1xuICAgIH0sIFtjb21wb25lbnROYW1lLCBjb250cm9sbGVkUHJvcE5hbWVdKTtcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBsZXQgeyBjdXJyZW50OiB3YXNDb250cm9sbGVkIH0gPSBjb250cm9sbGVkUmVmO1xuICAgICAgbGV0IHsgY29tcG9uZW50TmFtZSwgY29udHJvbGxlZFByb3BOYW1lIH0gPSBuYW1lQ2FjaGUuY3VycmVudDtcbiAgICAgIGxldCBpc0NvbnRyb2xsZWQgPSBjb250cm9sbGVkVmFsdWUgIT0gbnVsbDtcbiAgICAgIGlmICh3YXNDb250cm9sbGVkICE9PSBpc0NvbnRyb2xsZWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYW4gJHtcbiAgICAgICAgICAgIHdhc0NvbnRyb2xsZWQgPyBcIlwiIDogXCJ1blwiXG4gICAgICAgICAgfWNvbnRyb2xsZWQgXFxgJHtjb250cm9sbGVkUHJvcE5hbWV9XFxgIHN0YXRlIG9mICR7Y29tcG9uZW50TmFtZX0gdG8gYmUgJHtcbiAgICAgICAgICAgIHdhc0NvbnRyb2xsZWQgPyBcInVuXCIgOiBcIlwiXG4gICAgICAgICAgfWNvbnRyb2xsZWQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSB0aGUgdmFsdWUgY2hhbmdpbmcgZnJvbSB1bmRlZmluZWQgdG8gYSBkZWZpbmVkIHZhbHVlLCB3aGljaCBzaG91bGQgbm90IGhhcHBlbi4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAke2NvbXBvbmVudE5hbWV9IGVsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LlxuTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50c2BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCBbY29udHJvbGxlZFZhbHVlXSk7XG4gIH07XG59XG5cbmV4cG9ydCB7IHVzZUNvbnRyb2xsZWRTd2l0Y2hXYXJuaW5nIH07XG5cbmxldCB1c2VDaGVja1N0eWxlczogKHBhY2thZ2VOYW1lOiBzdHJpbmcpID0+IHZvaWQgPSBub29wO1xuXG5pZiAoX19ERVZfXykge1xuICB1c2VDaGVja1N0eWxlcyA9IGZ1bmN0aW9uIHVzZUNoZWNrU3R5bGVzKHBrZzogc3RyaW5nKSB7XG4gICAgbGV0IG5hbWUgPSBSZWFjdC51c2VSZWYocGtnKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4gdm9pZCAobmFtZS5jdXJyZW50ID0gcGtnKSwgW3BrZ10pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiBjaGVja1N0eWxlcyhuYW1lLmN1cnJlbnQpLCBbXSk7XG4gIH07XG59XG5cbmV4cG9ydCB7IHVzZUNoZWNrU3R5bGVzIH07XG5cbi8qKlxuICogUmVhY3QgaG9vayBmb3IgY3JlYXRpbmcgYSB2YWx1ZSBleGFjdGx5IG9uY2UuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9BbmRhcmlzdC91c2UtY29uc3RhbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbnN0YW50PFZhbHVlVHlwZT4oZm46ICgpID0+IFZhbHVlVHlwZSk6IFZhbHVlVHlwZSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZjx7IHY6IFZhbHVlVHlwZSB9PigpO1xuICBpZiAoIXJlZi5jdXJyZW50KSB7XG4gICAgcmVmLmN1cnJlbnQgPSB7IHY6IGZuKCkgfTtcbiAgfVxuICByZXR1cm4gcmVmLmN1cnJlbnQudjtcbn1cblxuLyoqXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUV2ZW50Q2FsbGJhY2s8RSBleHRlbmRzIEV2ZW50IHwgUmVhY3QuU3ludGhldGljRXZlbnQ+KFxuICBjYWxsYmFjazogKGV2ZW50OiBFLCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZFxuKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihjYWxsYmFjayk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gY2FsbGJhY2s7XG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50OiBFLCAuLi5hcmdzOiBhbnlbXSkgPT4gcmVmLmN1cnJlbnQoZXZlbnQsIC4uLmFyZ3MpLFxuICAgIFtdXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VMYXp5UmVmPEYgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG4gIGZuOiBGXG4pOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PFJldHVyblR5cGU8Rj4+IHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmPGFueT4oeyBfX2ludGVybmFsU2V0OiB0cnVlIH0pO1xuICBpZiAocmVmLmN1cnJlbnQgJiYgcmVmLmN1cnJlbnQuX19pbnRlcm5hbFNldCA9PT0gdHJ1ZSkge1xuICAgIHJlZi5jdXJyZW50ID0gZm4oKTtcbiAgfVxuICByZXR1cm4gcmVmO1xufVxuXG4vKipcbiAqIFRPRE86IFJlbW92ZSBpbiAxLjBcbiAqIEBhbGlhcyB1c2VTdGFibGVDYWxsYmFja1xuICogQHBhcmFtIGNhbGxiYWNrXG4gKi9cbmV4cG9ydCBjb25zdCB1c2VDYWxsYmFja1Byb3AgPSB1c2VTdGFibGVDYWxsYmFjaztcblxuLyoqXG4gKiBBZGRzIGEgRE9NIGV2ZW50IGxpc3RlbmVyXG4gKlxuICogQHBhcmFtIGV2ZW50TmFtZVxuICogQHBhcmFtIGxpc3RlbmVyXG4gKiBAcGFyYW0gZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRXZlbnRMaXN0ZW5lcjxLIGV4dGVuZHMga2V5b2YgV2luZG93RXZlbnRNYXA+KFxuICBldmVudE5hbWU6IEssXG4gIGxpc3RlbmVyOiAoZXZlbnQ6IFdpbmRvd0V2ZW50TWFwW0tdKSA9PiBhbnksXG4gIGVsZW1lbnQ6IEhUTUxFbGVtZW50IHwgRG9jdW1lbnQgfCBXaW5kb3cgfCBFdmVudFRhcmdldCA9IHdpbmRvd1xuKSB7XG4gIGNvbnN0IHNhdmVkSGFuZGxlciA9IFJlYWN0LnVzZVJlZihsaXN0ZW5lcik7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2F2ZWRIYW5kbGVyLmN1cnJlbnQgPSBsaXN0ZW5lcjtcbiAgfSwgW2xpc3RlbmVyXSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBpc1N1cHBvcnRlZCA9IGVsZW1lbnQgJiYgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyO1xuICAgIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkV2ZW50IGxpc3RlbmVyIG5vdCBzdXBwb3J0ZWQgb24gdGhlIGVsZW1lbnQgcHJvdmlkZWRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXZlbnRMaXN0ZW5lcihldmVudDogV2luZG93RXZlbnRNYXBbS10pIHtcbiAgICAgIHNhdmVkSGFuZGxlci5jdXJyZW50KGV2ZW50KTtcbiAgICB9XG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudExpc3RlbmVyIGFzIGFueSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIgYXMgYW55KTtcbiAgICB9O1xuICB9LCBbZXZlbnROYW1lLCBlbGVtZW50XSk7XG59XG5cbi8qKlxuICogRGV0ZWN0IHdoZW4gZm9jdXMgY2hhbmdlcyBpbiBvdXIgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIGhhbmRsZUNoYW5nZVxuICogQHBhcmFtIHdoZW5cbiAqIEBwYXJhbSBvd25lckRvY3VtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VGb2N1c0NoYW5nZShcbiAgaGFuZGxlQ2hhbmdlOiAoXG4gICAgYWN0aXZlRWxlbWVudDogRWxlbWVudCB8IG51bGwsXG4gICAgcHJldmlvdXNBY3RpdmVFbGVtZW50OiBFbGVtZW50IHwgbnVsbCxcbiAgICBldmVudD86IEZvY3VzRXZlbnRcbiAgKSA9PiB2b2lkID0gY29uc29sZS5sb2csXG4gIHdoZW46IFwiZm9jdXNcIiB8IFwiYmx1clwiID0gXCJmb2N1c1wiLFxuICBvd25lckRvY3VtZW50OiBEb2N1bWVudCA9IGRvY3VtZW50XG4pIHtcbiAgbGV0IGxhc3RBY3RpdmVFbGVtZW50ID0gUmVhY3QudXNlUmVmKG93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsYXN0QWN0aXZlRWxlbWVudC5jdXJyZW50ID0gb3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoZXZlbnQ6IEZvY3VzRXZlbnQpIHtcbiAgICAgIGlmIChsYXN0QWN0aXZlRWxlbWVudC5jdXJyZW50ICE9PSBvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgaGFuZGxlQ2hhbmdlKFxuICAgICAgICAgIG93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCxcbiAgICAgICAgICBsYXN0QWN0aXZlRWxlbWVudC5jdXJyZW50LFxuICAgICAgICAgIGV2ZW50XG4gICAgICAgICk7XG4gICAgICAgIGxhc3RBY3RpdmVFbGVtZW50LmN1cnJlbnQgPSBvd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHdoZW4sIG9uQ2hhbmdlLCB0cnVlKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBvd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIod2hlbiwgb25DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFt3aGVuLCBoYW5kbGVDaGFuZ2UsIG93bmVyRG9jdW1lbnRdKTtcbn1cblxuLyoqXG4gKiBGb3JjZXMgYSByZS1yZW5kZXIsIHNpbWlsYXIgdG8gYGZvcmNlVXBkYXRlYCBpbiBjbGFzcyBjb21wb25lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9yY2VVcGRhdGUoKSB7XG4gIGxldCBbLCBkaXNwYXRjaF0gPSBSZWFjdC51c2VTdGF0ZTx7fT4oT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgZGlzcGF0Y2goT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBQYXNzZXMgb3IgYXNzaWducyBhIHZhbHVlIHRvIG11bHRpcGxlIHJlZnMgKHR5cGljYWxseSBhIERPTSBub2RlKS4gVXNlZnVsIGZvclxuICogZGVhbGluZyB3aXRoIGNvbXBvbmVudHMgdGhhdCBuZWVkIGFuIGV4cGxpY2l0IHJlZiBmb3IgRE9NIGNhbGN1bGF0aW9ucyBidXRcbiAqIGFsc28gZm9yd2FyZHMgcmVmcyBhc3NpZ25lZCBieSBhbiBhcHAuXG4gKlxuICogQHBhcmFtIHJlZnMgUmVmcyB0byBmb3JrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VGb3JrZWRSZWY8UmVmVmFsdWVUeXBlID0gYW55PihcbiAgLi4ucmVmczogKEFzc2lnbmFibGVSZWY8UmVmVmFsdWVUeXBlPiB8IG51bGwgfCB1bmRlZmluZWQpW11cbikge1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJlZnMuZXZlcnkoKHJlZikgPT4gcmVmID09IG51bGwpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChub2RlOiBhbnkpID0+IHtcbiAgICAgIHJlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICAgIGFzc2lnblJlZihyZWYsIG5vZGUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFsuLi5yZWZzXSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcHJldmlvdXMgdmFsdWUgb2YgYSByZWZlcmVuY2UgYWZ0ZXIgYSBjb21wb25lbnQgdXBkYXRlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUHJldmlvdXM8VmFsdWVUeXBlID0gYW55Pih2YWx1ZTogVmFsdWVUeXBlKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZjxWYWx1ZVR5cGUgfCBudWxsPihudWxsKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgY2FsbGJhY2sgdG8gYSByZWYgdG8gYXZvaWQgdHJpZ2dlcmluZyByZS1yZW5kZXJzIHdoZW4gcGFzc2VkIGFzIGFcbiAqIHByb3AgYW5kIGV4cG9zZWQgYXMgYSBzdGFibGUgZnVuY3Rpb24gdG8gYXZvaWQgZXhlY3V0aW5nIGVmZmVjdHMgd2hlblxuICogcGFzc2VkIGFzIGEgZGVwZW5kZW5jeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUNhbGxiYWNrPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG4gIGNhbGxiYWNrOiBUIHwgbnVsbCB8IHVuZGVmaW5lZFxuKTogVCB7XG4gIGxldCBjYWxsYmFja1JlZiA9IFJlYWN0LnVzZVJlZihjYWxsYmFjayk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2FsbGJhY2tSZWYuY3VycmVudCA9IGNhbGxiYWNrO1xuICB9KTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNhbGxiYWNrUmVmLmN1cnJlbnQgJiYgY2FsbGJhY2tSZWYuY3VycmVudCguLi5hcmdzKTtcbiAgICB9KSBhcyBULFxuICAgIFtdXG4gICk7XG59XG5cbi8qKlxuICogQ2FsbCBhbiBlZmZlY3QgYWZ0ZXIgYSBjb21wb25lbnQgdXBkYXRlLCBza2lwcGluZyB0aGUgaW5pdGlhbCBtb3VudC5cbiAqXG4gKiBAcGFyYW0gZWZmZWN0IEVmZmVjdCB0byBjYWxsXG4gKiBAcGFyYW0gZGVwcyBFZmZlY3QgZGVwZW5kZW5jeSBsaXN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VVcGRhdGVFZmZlY3QoXG4gIGVmZmVjdDogUmVhY3QuRWZmZWN0Q2FsbGJhY2ssXG4gIGRlcHM/OiBSZWFjdC5EZXBlbmRlbmN5TGlzdFxuKSB7XG4gIGNvbnN0IG1vdW50ZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgIGVmZmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIGRlcHMpO1xufVxuXG4vKipcbiAqIEp1c3QgYSBsaWwgc3RhdGUgbG9nZ2VyXG4gKlxuICogQHBhcmFtIHN0YXRlXG4gKiBAcGFyYW0gREVCVUdcbiAqL1xubGV0IHVzZVN0YXRlTG9nZ2VyOiAoc3RhdGU6IHN0cmluZywgREVCVUc6IGJvb2xlYW4pID0+IHZvaWQgPSBub29wO1xuXG5pZiAoX19ERVZfXykge1xuICB1c2VTdGF0ZUxvZ2dlciA9IGZ1bmN0aW9uIHVzZVN0YXRlTG9nZ2VyKHN0YXRlLCBERUJVRyA9IGZhbHNlKSB7XG4gICAgbGV0IGRlYnVnUmVmID0gUmVhY3QudXNlUmVmKERFQlVHKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgZGVidWdSZWYuY3VycmVudCA9IERFQlVHO1xuICAgIH0sIFtERUJVR10pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoZGVidWdSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zb2xlLmdyb3VwKFwiU3RhdGUgVXBkYXRlZFwiKTtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgXCIlY1wiICsgc3RhdGUsXG4gICAgICAgICAgXCJmb250LXdlaWdodDogbm9ybWFsOyBmb250LXNpemU6IDEyMCU7IGZvbnQtc3R5bGU6IGl0YWxpYztcIlxuICAgICAgICApO1xuICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgICB9XG4gICAgfSwgW3N0YXRlXSk7XG4gIH07XG59XG5cbmV4cG9ydCB7IHVzZVN0YXRlTG9nZ2VyIH07XG5cbi8qKlxuICogV3JhcHMgYSBsaWItZGVmaW5lZCBldmVudCBoYW5kbGVyIGFuZCBhIHVzZXItZGVmaW5lZCBldmVudCBoYW5kbGVyLCByZXR1cm5pbmdcbiAqIGEgc2luZ2xlIGhhbmRsZXIgdGhhdCBhbGxvd3MgYSB1c2VyIHRvIHByZXZlbnQgbGliLWRlZmluZWQgaGFuZGxlcnMgZnJvbVxuICogZmlyaW5nLlxuICpcbiAqIEBwYXJhbSB0aGVpckhhbmRsZXIgVXNlci1zdXBwbGllZCBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0gb3VySGFuZGxlciBMaWJyYXJ5LXN1cHBsaWVkIGV2ZW50IGhhbmRsZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBFdmVudDxFdmVudFR5cGUgZXh0ZW5kcyBSZWFjdC5TeW50aGV0aWNFdmVudCB8IEV2ZW50PihcbiAgdGhlaXJIYW5kbGVyOiAoKGV2ZW50OiBFdmVudFR5cGUpID0+IGFueSkgfCB1bmRlZmluZWQsXG4gIG91ckhhbmRsZXI6IChldmVudDogRXZlbnRUeXBlKSA9PiBhbnlcbik6IChldmVudDogRXZlbnRUeXBlKSA9PiBhbnkge1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgdGhlaXJIYW5kbGVyICYmIHRoZWlySGFuZGxlcihldmVudCk7XG4gICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm4gb3VySGFuZGxlcihldmVudCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBFeHBvcnQgdHlwZXNcbmV4cG9ydCB0eXBlIHtcbiAgQXMsXG4gIEFzc2lnbmFibGVSZWYsXG4gIENvbXBvbmVudFdpdGhBcyxcbiAgQ29tcG9uZW50V2l0aEZvcndhcmRlZFJlZixcbiAgRGlzdHJpYnV0aXZlT21pdCxcbiAgRWxlbWVudFRhZ05hbWVNYXAsXG4gIEZvcndhcmRSZWZFeG90aWNDb21wb25lbnRXaXRoQXMsXG4gIEZ1bmN0aW9uQ29tcG9uZW50V2l0aEFzLFxuICBNZW1vRXhvdGljQ29tcG9uZW50V2l0aEFzLFxuICBQcm9wc0Zyb21BcyxcbiAgUHJvcHNXaXRoQXMsXG4gIFNpbmdsZU9yQXJyYXksXG4gIFRoZW5BcmcsXG59O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQW9CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7QUFJQTtBQUVBOzs7Ozs7Ozs7OztBQVVBO0FBRUE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU9BO0FBQUE7QUFBQTtBQUFBO0FBUEE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBWUE7QUExQkE7QUE0QkE7QUFJQTs7Ozs7OztBQUtBO0FBR0E7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7QUFNQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFHQTtBQUFBOzs7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBU0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQU9BO0FBSUE7QUFFQTs7Ozs7OztBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUdBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUdBO0FBS0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBOzs7OztBQUdBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFRQTtBQWJBO0FBWEE7QUEyQkE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFIQTtBQUtBO0FBSUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFFQTs7Ozs7Ozs7QUFPQTtBQUdBO0FBQUE7OztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFkQTtBQWtCQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7OztBQUtBO0FBQUE7OztBQUNBO0FBQUE7OztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQWhCQTtBQW9CQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBOzs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBTEE7QUFBQTtBQVdBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBT0E7QUFFQTtBQUZBO0FBTUE7QUFFQTs7Ozs7Ozs7QUFNQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBQ0E7QUFEQTtBQVFBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQVJBO0FBTEE7QUFnQkE7QUFJQTs7Ozs7Ozs7OztBQVFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@reach/utils/dist/utils.esm.js\n");

/***/ }),

/***/ "../node_modules/highlight-words-core/dist/index.js":
/*!**********************************************************!*\
  !*** ../node_modules/highlight-words-core/dist/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n\n      /******/\n      id: moduleId,\n\n      /******/\n      loaded: false\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.loaded = true;\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /******/\n\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n  __webpack_require__.p = \"\";\n  /******/\n\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(0);\n  /******/\n}(\n/************************************************************************/\n\n/******/\n[\n/* 0 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  module.exports = __webpack_require__(1);\n  /***/\n},\n/* 1 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  var _utils = __webpack_require__(2);\n\n  Object.defineProperty(exports, 'combineChunks', {\n    enumerable: true,\n    get: function get() {\n      return _utils.combineChunks;\n    }\n  });\n  Object.defineProperty(exports, 'fillInChunks', {\n    enumerable: true,\n    get: function get() {\n      return _utils.fillInChunks;\n    }\n  });\n  Object.defineProperty(exports, 'findAll', {\n    enumerable: true,\n    get: function get() {\n      return _utils.findAll;\n    }\n  });\n  Object.defineProperty(exports, 'findChunks', {\n    enumerable: true,\n    get: function get() {\n      return _utils.findChunks;\n    }\n  });\n  /***/\n},\n/* 2 */\n\n/***/\nfunction (module, exports) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  /**\n   * Creates an array of chunk objects representing both higlightable and non highlightable pieces of text that match each search word.\n   * @return Array of \"chunks\" (where a Chunk is { start:number, end:number, highlight:boolean })\n   */\n\n  var findAll = exports.findAll = function findAll(_ref) {\n    var autoEscape = _ref.autoEscape,\n        _ref$caseSensitive = _ref.caseSensitive,\n        caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive,\n        _ref$findChunks = _ref.findChunks,\n        findChunks = _ref$findChunks === undefined ? defaultFindChunks : _ref$findChunks,\n        sanitize = _ref.sanitize,\n        searchWords = _ref.searchWords,\n        textToHighlight = _ref.textToHighlight;\n    return fillInChunks({\n      chunksToHighlight: combineChunks({\n        chunks: findChunks({\n          autoEscape: autoEscape,\n          caseSensitive: caseSensitive,\n          sanitize: sanitize,\n          searchWords: searchWords,\n          textToHighlight: textToHighlight\n        })\n      }),\n      totalLength: textToHighlight ? textToHighlight.length : 0\n    });\n  };\n  /**\n   * Takes an array of {start:number, end:number} objects and combines chunks that overlap into single chunks.\n   * @return {start:number, end:number}[]\n   */\n\n\n  var combineChunks = exports.combineChunks = function combineChunks(_ref2) {\n    var chunks = _ref2.chunks;\n    chunks = chunks.sort(function (first, second) {\n      return first.start - second.start;\n    }).reduce(function (processedChunks, nextChunk) {\n      // First chunk just goes straight in the array...\n      if (processedChunks.length === 0) {\n        return [nextChunk];\n      } else {\n        // ... subsequent chunks get checked to see if they overlap...\n        var prevChunk = processedChunks.pop();\n\n        if (nextChunk.start <= prevChunk.end) {\n          // It may be the case that prevChunk completely surrounds nextChunk, so take the\n          // largest of the end indeces.\n          var endIndex = Math.max(prevChunk.end, nextChunk.end);\n          processedChunks.push({\n            highlight: false,\n            start: prevChunk.start,\n            end: endIndex\n          });\n        } else {\n          processedChunks.push(prevChunk, nextChunk);\n        }\n\n        return processedChunks;\n      }\n    }, []);\n    return chunks;\n  };\n  /**\n   * Examine text for any matches.\n   * If we find matches, add them to the returned array as a \"chunk\" object ({start:number, end:number}).\n   * @return {start:number, end:number}[]\n   */\n\n\n  var defaultFindChunks = function defaultFindChunks(_ref3) {\n    var autoEscape = _ref3.autoEscape,\n        caseSensitive = _ref3.caseSensitive,\n        _ref3$sanitize = _ref3.sanitize,\n        sanitize = _ref3$sanitize === undefined ? defaultSanitize : _ref3$sanitize,\n        searchWords = _ref3.searchWords,\n        textToHighlight = _ref3.textToHighlight;\n    textToHighlight = sanitize(textToHighlight);\n    return searchWords.filter(function (searchWord) {\n      return searchWord;\n    }) // Remove empty words\n    .reduce(function (chunks, searchWord) {\n      searchWord = sanitize(searchWord);\n\n      if (autoEscape) {\n        searchWord = escapeRegExpFn(searchWord);\n      }\n\n      var regex = new RegExp(searchWord, caseSensitive ? 'g' : 'gi');\n      var match = void 0;\n\n      while (match = regex.exec(textToHighlight)) {\n        var _start = match.index;\n        var _end = regex.lastIndex; // We do not return zero-length matches\n\n        if (_end > _start) {\n          chunks.push({\n            highlight: false,\n            start: _start,\n            end: _end\n          });\n        } // Prevent browsers like Firefox from getting stuck in an infinite loop\n        // See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/\n\n\n        if (match.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n      }\n\n      return chunks;\n    }, []);\n  }; // Allow the findChunks to be overridden in findAll,\n  // but for backwards compatibility we export as the old name\n\n\n  exports.findChunks = defaultFindChunks;\n  /**\n   * Given a set of chunks to highlight, create an additional set of chunks\n   * to represent the bits of text between the highlighted text.\n   * @param chunksToHighlight {start:number, end:number}[]\n   * @param totalLength number\n   * @return {start:number, end:number, highlight:boolean}[]\n   */\n\n  var fillInChunks = exports.fillInChunks = function fillInChunks(_ref4) {\n    var chunksToHighlight = _ref4.chunksToHighlight,\n        totalLength = _ref4.totalLength;\n    var allChunks = [];\n\n    var append = function append(start, end, highlight) {\n      if (end - start > 0) {\n        allChunks.push({\n          start: start,\n          end: end,\n          highlight: highlight\n        });\n      }\n    };\n\n    if (chunksToHighlight.length === 0) {\n      append(0, totalLength, false);\n    } else {\n      var lastIndex = 0;\n      chunksToHighlight.forEach(function (chunk) {\n        append(lastIndex, chunk.start, false);\n        append(chunk.start, chunk.end, true);\n        lastIndex = chunk.end;\n      });\n      append(lastIndex, totalLength, false);\n    }\n\n    return allChunks;\n  };\n\n  function defaultSanitize(string) {\n    return string;\n  }\n\n  function escapeRegExpFn(string) {\n    return string.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n  }\n  /***/\n\n}\n/******/\n]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC13b3Jkcy1jb3JlL2Rpc3QvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjazovd2VicGFjay9ib290c3RyYXAgMmE5NTA3MGFmZmRmM2MwMDU0ZjE/OTM0YyIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvaW5kZXguanM/ZjBmNCIsIndlYnBhY2s6Ly8vd2VicGFjazovLy9zcmMvdXRpbHMuanM/ZTExOSJdLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAyYTk1MDcwYWZmZGYzYzAwNTRmMSIsIi8vIEBmbG93XG5cbmV4cG9ydCB7IGNvbWJpbmVDaHVua3MsIGZpbGxJbkNodW5rcywgZmluZEFsbCwgZmluZENodW5rcyB9IGZyb20gJy4vdXRpbHMnXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5kZXguanMiLCIvLyBAZmxvd1xuXG5leHBvcnQgdHlwZSBDaHVuayA9IHt8XG4gIGhpZ2hsaWdodDogYm9vbGVhbixcbiAgc3RhcnQ6IG51bWJlcixcbiAgZW5kOiBudW1iZXIsXG58fTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGNodW5rIG9iamVjdHMgcmVwcmVzZW50aW5nIGJvdGggaGlnbGlnaHRhYmxlIGFuZCBub24gaGlnaGxpZ2h0YWJsZSBwaWVjZXMgb2YgdGV4dCB0aGF0IG1hdGNoIGVhY2ggc2VhcmNoIHdvcmQuXG4gKiBAcmV0dXJuIEFycmF5IG9mIFwiY2h1bmtzXCIgKHdoZXJlIGEgQ2h1bmsgaXMgeyBzdGFydDpudW1iZXIsIGVuZDpudW1iZXIsIGhpZ2hsaWdodDpib29sZWFuIH0pXG4gKi9cbmV4cG9ydCBjb25zdCBmaW5kQWxsID0gKHtcbiAgYXV0b0VzY2FwZSxcbiAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuICBmaW5kQ2h1bmtzID0gZGVmYXVsdEZpbmRDaHVua3MsXG4gIHNhbml0aXplLFxuICBzZWFyY2hXb3JkcyxcbiAgdGV4dFRvSGlnaGxpZ2h0XG59OiB7XG4gIGF1dG9Fc2NhcGU/OiBib29sZWFuLFxuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbixcbiAgZmluZENodW5rcz86IHR5cGVvZiBkZWZhdWx0RmluZENodW5rcyxcbiAgc2FuaXRpemU/OiB0eXBlb2YgZGVmYXVsdFNhbml0aXplLFxuICBzZWFyY2hXb3JkczogQXJyYXk8c3RyaW5nPixcbiAgdGV4dFRvSGlnaGxpZ2h0OiBzdHJpbmcsXG59KTogQXJyYXk8Q2h1bms+ID0+IChcbiAgZmlsbEluQ2h1bmtzKHtcbiAgICBjaHVua3NUb0hpZ2hsaWdodDogY29tYmluZUNodW5rcyh7XG4gICAgICBjaHVua3M6IGZpbmRDaHVua3Moe1xuICAgICAgICBhdXRvRXNjYXBlLFxuICAgICAgICBjYXNlU2Vuc2l0aXZlLFxuICAgICAgICBzYW5pdGl6ZSxcbiAgICAgICAgc2VhcmNoV29yZHMsXG4gICAgICAgIHRleHRUb0hpZ2hsaWdodFxuICAgICAgfSlcbiAgICB9KSxcbiAgICB0b3RhbExlbmd0aDogdGV4dFRvSGlnaGxpZ2h0ID8gdGV4dFRvSGlnaGxpZ2h0Lmxlbmd0aCA6IDBcbiAgfSlcbilcblxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiB7c3RhcnQ6bnVtYmVyLCBlbmQ6bnVtYmVyfSBvYmplY3RzIGFuZCBjb21iaW5lcyBjaHVua3MgdGhhdCBvdmVybGFwIGludG8gc2luZ2xlIGNodW5rcy5cbiAqIEByZXR1cm4ge3N0YXJ0Om51bWJlciwgZW5kOm51bWJlcn1bXVxuICovXG5leHBvcnQgY29uc3QgY29tYmluZUNodW5rcyA9ICh7XG4gIGNodW5rc1xufToge1xuICBjaHVua3M6IEFycmF5PENodW5rPixcbn0pOiBBcnJheTxDaHVuaz4gPT4ge1xuICBjaHVua3MgPSBjaHVua3NcbiAgICAuc29ydCgoZmlyc3QsIHNlY29uZCkgPT4gZmlyc3Quc3RhcnQgLSBzZWNvbmQuc3RhcnQpXG4gICAgLnJlZHVjZSgocHJvY2Vzc2VkQ2h1bmtzLCBuZXh0Q2h1bmspID0+IHtcbiAgICAgIC8vIEZpcnN0IGNodW5rIGp1c3QgZ29lcyBzdHJhaWdodCBpbiB0aGUgYXJyYXkuLi5cbiAgICAgIGlmIChwcm9jZXNzZWRDaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbbmV4dENodW5rXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gLi4uIHN1YnNlcXVlbnQgY2h1bmtzIGdldCBjaGVja2VkIHRvIHNlZSBpZiB0aGV5IG92ZXJsYXAuLi5cbiAgICAgICAgY29uc3QgcHJldkNodW5rID0gcHJvY2Vzc2VkQ2h1bmtzLnBvcCgpXG4gICAgICAgIGlmIChuZXh0Q2h1bmsuc3RhcnQgPD0gcHJldkNodW5rLmVuZCkge1xuICAgICAgICAgIC8vIEl0IG1heSBiZSB0aGUgY2FzZSB0aGF0IHByZXZDaHVuayBjb21wbGV0ZWx5IHN1cnJvdW5kcyBuZXh0Q2h1bmssIHNvIHRha2UgdGhlXG4gICAgICAgICAgLy8gbGFyZ2VzdCBvZiB0aGUgZW5kIGluZGVjZXMuXG4gICAgICAgICAgY29uc3QgZW5kSW5kZXggPSBNYXRoLm1heChwcmV2Q2h1bmsuZW5kLCBuZXh0Q2h1bmsuZW5kKVxuICAgICAgICAgIHByb2Nlc3NlZENodW5rcy5wdXNoKHtoaWdobGlnaHQ6IGZhbHNlLCBzdGFydDogcHJldkNodW5rLnN0YXJ0LCBlbmQ6IGVuZEluZGV4fSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzZWRDaHVua3MucHVzaChwcmV2Q2h1bmssIG5leHRDaHVuaylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkQ2h1bmtzXG4gICAgICB9XG4gICAgfSwgW10pXG5cbiAgcmV0dXJuIGNodW5rc1xufVxuXG4vKipcbiAqIEV4YW1pbmUgdGV4dCBmb3IgYW55IG1hdGNoZXMuXG4gKiBJZiB3ZSBmaW5kIG1hdGNoZXMsIGFkZCB0aGVtIHRvIHRoZSByZXR1cm5lZCBhcnJheSBhcyBhIFwiY2h1bmtcIiBvYmplY3QgKHtzdGFydDpudW1iZXIsIGVuZDpudW1iZXJ9KS5cbiAqIEByZXR1cm4ge3N0YXJ0Om51bWJlciwgZW5kOm51bWJlcn1bXVxuICovXG5jb25zdCBkZWZhdWx0RmluZENodW5rcyA9ICh7XG4gIGF1dG9Fc2NhcGUsXG4gIGNhc2VTZW5zaXRpdmUsXG4gIHNhbml0aXplID0gZGVmYXVsdFNhbml0aXplLFxuICBzZWFyY2hXb3JkcyxcbiAgdGV4dFRvSGlnaGxpZ2h0XG59OiB7XG4gIGF1dG9Fc2NhcGU/OiBib29sZWFuLFxuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbixcbiAgc2FuaXRpemU/OiB0eXBlb2YgZGVmYXVsdFNhbml0aXplLFxuICBzZWFyY2hXb3JkczogQXJyYXk8c3RyaW5nPixcbiAgdGV4dFRvSGlnaGxpZ2h0OiBzdHJpbmcsXG59KTogQXJyYXk8Q2h1bms+ID0+IHtcbiAgdGV4dFRvSGlnaGxpZ2h0ID0gc2FuaXRpemUodGV4dFRvSGlnaGxpZ2h0KVxuXG4gIHJldHVybiBzZWFyY2hXb3Jkc1xuICAgIC5maWx0ZXIoc2VhcmNoV29yZCA9PiBzZWFyY2hXb3JkKSAvLyBSZW1vdmUgZW1wdHkgd29yZHNcbiAgICAucmVkdWNlKChjaHVua3MsIHNlYXJjaFdvcmQpID0+IHtcbiAgICAgIHNlYXJjaFdvcmQgPSBzYW5pdGl6ZShzZWFyY2hXb3JkKVxuXG4gICAgICBpZiAoYXV0b0VzY2FwZSkge1xuICAgICAgICBzZWFyY2hXb3JkID0gZXNjYXBlUmVnRXhwRm4oc2VhcmNoV29yZClcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHNlYXJjaFdvcmQsIGNhc2VTZW5zaXRpdmUgPyAnZycgOiAnZ2knKVxuXG4gICAgICBsZXQgbWF0Y2hcbiAgICAgIHdoaWxlICgobWF0Y2ggPSByZWdleC5leGVjKHRleHRUb0hpZ2hsaWdodCkpKSB7XG4gICAgICAgIGxldCBzdGFydCA9IG1hdGNoLmluZGV4XG4gICAgICAgIGxldCBlbmQgPSByZWdleC5sYXN0SW5kZXhcbiAgICAgICAgLy8gV2UgZG8gbm90IHJldHVybiB6ZXJvLWxlbmd0aCBtYXRjaGVzXG4gICAgICAgIGlmIChlbmQgPiBzdGFydCkge1xuICAgICAgICAgIGNodW5rcy5wdXNoKHtoaWdobGlnaHQ6IGZhbHNlLCBzdGFydCwgZW5kfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXZlbnQgYnJvd3NlcnMgbGlrZSBGaXJlZm94IGZyb20gZ2V0dGluZyBzdHVjayBpbiBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgIC8vIFNlZSBodHRwOi8vd3d3LnJlZ2V4Z3VydS5jb20vMjAwOC8wNC93YXRjaC1vdXQtZm9yLXplcm8tbGVuZ3RoLW1hdGNoZXMvXG4gICAgICAgIGlmIChtYXRjaC5pbmRleCA9PT0gcmVnZXgubGFzdEluZGV4KSB7XG4gICAgICAgICAgcmVnZXgubGFzdEluZGV4KytcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2h1bmtzXG4gICAgfSwgW10pXG59XG4vLyBBbGxvdyB0aGUgZmluZENodW5rcyB0byBiZSBvdmVycmlkZGVuIGluIGZpbmRBbGwsXG4vLyBidXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdlIGV4cG9ydCBhcyB0aGUgb2xkIG5hbWVcbmV4cG9ydCB7ZGVmYXVsdEZpbmRDaHVua3MgYXMgZmluZENodW5rc31cblxuLyoqXG4gKiBHaXZlbiBhIHNldCBvZiBjaHVua3MgdG8gaGlnaGxpZ2h0LCBjcmVhdGUgYW4gYWRkaXRpb25hbCBzZXQgb2YgY2h1bmtzXG4gKiB0byByZXByZXNlbnQgdGhlIGJpdHMgb2YgdGV4dCBiZXR3ZWVuIHRoZSBoaWdobGlnaHRlZCB0ZXh0LlxuICogQHBhcmFtIGNodW5rc1RvSGlnaGxpZ2h0IHtzdGFydDpudW1iZXIsIGVuZDpudW1iZXJ9W11cbiAqIEBwYXJhbSB0b3RhbExlbmd0aCBudW1iZXJcbiAqIEByZXR1cm4ge3N0YXJ0Om51bWJlciwgZW5kOm51bWJlciwgaGlnaGxpZ2h0OmJvb2xlYW59W11cbiAqL1xuZXhwb3J0IGNvbnN0IGZpbGxJbkNodW5rcyA9ICh7XG4gIGNodW5rc1RvSGlnaGxpZ2h0LFxuICB0b3RhbExlbmd0aFxufToge1xuICBjaHVua3NUb0hpZ2hsaWdodDogQXJyYXk8Q2h1bms+LFxuICB0b3RhbExlbmd0aDogbnVtYmVyLFxufSk6IEFycmF5PENodW5rPiA9PiB7XG4gIGNvbnN0IGFsbENodW5rcyA9IFtdXG4gIGNvbnN0IGFwcGVuZCA9IChzdGFydCwgZW5kLCBoaWdobGlnaHQpID0+IHtcbiAgICBpZiAoZW5kIC0gc3RhcnQgPiAwKSB7XG4gICAgICBhbGxDaHVua3MucHVzaCh7XG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmQsXG4gICAgICAgIGhpZ2hsaWdodFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpZiAoY2h1bmtzVG9IaWdobGlnaHQubGVuZ3RoID09PSAwKSB7XG4gICAgYXBwZW5kKDAsIHRvdGFsTGVuZ3RoLCBmYWxzZSlcbiAgfSBlbHNlIHtcbiAgICBsZXQgbGFzdEluZGV4ID0gMFxuICAgIGNodW5rc1RvSGlnaGxpZ2h0LmZvckVhY2goKGNodW5rKSA9PiB7XG4gICAgICBhcHBlbmQobGFzdEluZGV4LCBjaHVuay5zdGFydCwgZmFsc2UpXG4gICAgICBhcHBlbmQoY2h1bmsuc3RhcnQsIGNodW5rLmVuZCwgdHJ1ZSlcbiAgICAgIGxhc3RJbmRleCA9IGNodW5rLmVuZFxuICAgIH0pXG4gICAgYXBwZW5kKGxhc3RJbmRleCwgdG90YWxMZW5ndGgsIGZhbHNlKVxuICB9XG4gIHJldHVybiBhbGxDaHVua3Ncbn1cblxuZnVuY3Rpb24gZGVmYXVsdFNhbml0aXplIChzdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHJpbmdcbn1cblxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwRm4gKHN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFwtXFxbXFxdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZywgJ1xcXFwkJicpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMuanMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFMQTs7O0FBTUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7Ozs7O0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcENBOzs7Ozs7QUFBQTs7Ozs7O0FBQUE7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7OztBQ01BOzs7OztBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFEQTtBQVNBO0FBVkE7QUFmQTtBQTZCQTs7Ozs7O0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBbEJBO0FBcUJBO0FBMUJBO0FBNkJBOzs7Ozs7O0FBS0E7QUFZQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFMQTtBQVNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTNCQTtBQWZBO0FBOENBO0FBQ0E7QUFDQTtBQURBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFNQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUE3QkE7QUFDQTtBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/highlight-words-core/dist/index.js\n");

/***/ })

}]);